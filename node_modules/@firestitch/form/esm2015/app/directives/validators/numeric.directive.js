import { Directive, Input } from '@angular/core';
import { FsControlDirective } from './control.directive';
import { FsValidators } from '../../validators/validators';
import { VALIDATE_MESSAGE_PROVIDER } from '../../providers/validate-messages.provider';
import { isEnabled } from '../../helpers/is-enabled';
import * as i0 from "@angular/core";
export class FsFormNumericDirective extends FsControlDirective {
    set validationMessage(value) {
        this._validateMessages.numeric = value;
    }
    ngOnChanges() {
        this._control.updateValueAndValidity();
    }
    validate(control) {
        if (isEnabled(this.fsFormNumeric)) {
            return FsValidators.numeric(this._control);
        }
        else {
            return null;
        }
    }
}
FsFormNumericDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsFormNumericDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
FsFormNumericDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: FsFormNumericDirective, selector: "[fsFormNumeric]", inputs: { fsFormNumeric: "fsFormNumeric", validationMessage: ["fsFormNumericMessage", "validationMessage"] }, providers: [
        VALIDATE_MESSAGE_PROVIDER
    ], usesInheritance: true, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsFormNumericDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[fsFormNumeric]',
                    providers: [
                        VALIDATE_MESSAGE_PROVIDER
                    ],
                }]
        }], propDecorators: { fsFormNumeric: [{
                type: Input
            }], validationMessage: [{
                type: Input,
                args: ['fsFormNumericMessage']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibnVtZXJpYy5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvYXBwL2RpcmVjdGl2ZXMvdmFsaWRhdG9ycy9udW1lcmljLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBYSxNQUFNLGVBQWUsQ0FBQztBQUc1RCxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUN6RCxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sNkJBQTZCLENBQUM7QUFDM0QsT0FBTyxFQUFFLHlCQUF5QixFQUFFLE1BQU0sNENBQTRDLENBQUM7QUFFdkYsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLDBCQUEwQixDQUFDOztBQVNyRCxNQUFNLE9BQU8sc0JBQXVCLFNBQVEsa0JBQWtCO0lBSzVELElBQ1csaUJBQWlCLENBQUMsS0FBYTtRQUN4QyxJQUFJLENBQUMsaUJBQWlCLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQztJQUN6QyxDQUFDO0lBRU0sV0FBVztRQUNoQixJQUFJLENBQUMsUUFBUSxDQUFDLHNCQUFzQixFQUFFLENBQUM7SUFDekMsQ0FBQztJQUVNLFFBQVEsQ0FBQyxPQUF3QjtRQUN0QyxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLEVBQUU7WUFDakMsT0FBTyxZQUFZLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztTQUM1QzthQUFNO1lBQ0wsT0FBTyxJQUFJLENBQUM7U0FDYjtJQUNILENBQUM7O29IQXBCVSxzQkFBc0I7d0dBQXRCLHNCQUFzQix3SkFKdEI7UUFDVCx5QkFBeUI7S0FDMUI7NEZBRVUsc0JBQXNCO2tCQU5sQyxTQUFTO21CQUFDO29CQUNULFFBQVEsRUFBRSxpQkFBaUI7b0JBQzNCLFNBQVMsRUFBRTt3QkFDVCx5QkFBeUI7cUJBQzFCO2lCQUNGOzhCQUlRLGFBQWE7c0JBRG5CLEtBQUs7Z0JBSUssaUJBQWlCO3NCQUQzQixLQUFLO3VCQUFDLHNCQUFzQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERpcmVjdGl2ZSwgSW5wdXQsIE9uQ2hhbmdlcyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQWJzdHJhY3RDb250cm9sLCBWYWxpZGF0aW9uRXJyb3JzIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5pbXBvcnQgeyBGc0NvbnRyb2xEaXJlY3RpdmUgfSBmcm9tICcuL2NvbnRyb2wuZGlyZWN0aXZlJztcbmltcG9ydCB7IEZzVmFsaWRhdG9ycyB9IGZyb20gJy4uLy4uL3ZhbGlkYXRvcnMvdmFsaWRhdG9ycyc7XG5pbXBvcnQgeyBWQUxJREFURV9NRVNTQUdFX1BST1ZJREVSIH0gZnJvbSAnLi4vLi4vcHJvdmlkZXJzL3ZhbGlkYXRlLW1lc3NhZ2VzLnByb3ZpZGVyJztcbmltcG9ydCB7IEZzVmFsaWRhdG9yIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy92YWxpZGF0b3InO1xuaW1wb3J0IHsgaXNFbmFibGVkIH0gZnJvbSAnLi4vLi4vaGVscGVycy9pcy1lbmFibGVkJztcblxuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbZnNGb3JtTnVtZXJpY10nLFxuICBwcm92aWRlcnM6IFtcbiAgICBWQUxJREFURV9NRVNTQUdFX1BST1ZJREVSXG4gIF0sXG59KVxuZXhwb3J0IGNsYXNzIEZzRm9ybU51bWVyaWNEaXJlY3RpdmUgZXh0ZW5kcyBGc0NvbnRyb2xEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkNoYW5nZXMsIEZzVmFsaWRhdG9yIHtcblxuICBASW5wdXQoKVxuICBwdWJsaWMgZnNGb3JtTnVtZXJpYztcblxuICBASW5wdXQoJ2ZzRm9ybU51bWVyaWNNZXNzYWdlJylcbiAgcHVibGljIHNldCB2YWxpZGF0aW9uTWVzc2FnZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgdGhpcy5fdmFsaWRhdGVNZXNzYWdlcy5udW1lcmljID0gdmFsdWU7XG4gIH1cblxuICBwdWJsaWMgbmdPbkNoYW5nZXMoKTogdm9pZCB7XG4gICAgdGhpcy5fY29udHJvbC51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KCk7XG4gIH1cblxuICBwdWJsaWMgdmFsaWRhdGUoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwge1xuICAgIGlmIChpc0VuYWJsZWQodGhpcy5mc0Zvcm1OdW1lcmljKSkge1xuICAgICAgcmV0dXJuIEZzVmFsaWRhdG9ycy5udW1lcmljKHRoaXMuX2NvbnRyb2wpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxufVxuIl19