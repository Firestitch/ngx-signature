import { Directive, Input } from '@angular/core';
import { FsControlDirective } from './control.directive';
import { FsValidators } from '../../validators/validators';
import { VALIDATE_MESSAGE_PROVIDER } from '../../providers/validate-messages.provider';
import * as i0 from "@angular/core";
export class FsFormGreaterDirective extends FsControlDirective {
    set validationMessage(value) {
        this._validateMessages.greater = value;
    }
    ngOnChanges() {
        this._control.updateValueAndValidity();
    }
    validate(control) {
        const greater = parseFloat(this.fsFormGreater);
        const value = parseFloat(this._control.value);
        if (!isNaN(greater) && !isNaN(value) && value <= greater) {
            return { greater: { greater, actual: value } };
        }
        return FsValidators.numeric(this._control);
    }
}
FsFormGreaterDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsFormGreaterDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
FsFormGreaterDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: FsFormGreaterDirective, selector: "[fsFormGreater]", inputs: { fsFormGreater: "fsFormGreater", validationMessage: ["fsFormGreaterMessage", "validationMessage"] }, providers: [
        VALIDATE_MESSAGE_PROVIDER
    ], usesInheritance: true, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsFormGreaterDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[fsFormGreater]',
                    providers: [
                        VALIDATE_MESSAGE_PROVIDER
                    ],
                }]
        }], propDecorators: { fsFormGreater: [{
                type: Input
            }], validationMessage: [{
                type: Input,
                args: ['fsFormGreaterMessage']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JlYXRlci5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvYXBwL2RpcmVjdGl2ZXMvdmFsaWRhdG9ycy9ncmVhdGVyLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBYSxNQUFNLGVBQWUsQ0FBQztBQUc1RCxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUN6RCxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sNkJBQTZCLENBQUM7QUFDM0QsT0FBTyxFQUFFLHlCQUF5QixFQUFFLE1BQU0sNENBQTRDLENBQUM7O0FBVXZGLE1BQU0sT0FBTyxzQkFBdUIsU0FBUSxrQkFBa0I7SUFLNUQsSUFDVyxpQkFBaUIsQ0FBQyxLQUFhO1FBQ3hDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO0lBQ3pDLENBQUM7SUFFTSxXQUFXO1FBQ2hCLElBQUksQ0FBQyxRQUFRLENBQUMsc0JBQXNCLEVBQUUsQ0FBQztJQUN6QyxDQUFDO0lBRU0sUUFBUSxDQUFDLE9BQXdCO1FBQ3RDLE1BQU0sT0FBTyxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7UUFDL0MsTUFBTSxLQUFLLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFOUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsSUFBSSxLQUFLLElBQUksT0FBTyxFQUFFO1lBQ3hELE9BQU8sRUFBRSxPQUFPLEVBQUUsRUFBRSxPQUFPLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxFQUFFLENBQUM7U0FDaEQ7UUFFRCxPQUFPLFlBQVksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzdDLENBQUM7O29IQXZCVSxzQkFBc0I7d0dBQXRCLHNCQUFzQix3SkFKdEI7UUFDVCx5QkFBeUI7S0FDMUI7NEZBRVUsc0JBQXNCO2tCQU5sQyxTQUFTO21CQUFDO29CQUNULFFBQVEsRUFBRSxpQkFBaUI7b0JBQzNCLFNBQVMsRUFBRTt3QkFDVCx5QkFBeUI7cUJBQzFCO2lCQUNGOzhCQUlRLGFBQWE7c0JBRG5CLEtBQUs7Z0JBSUssaUJBQWlCO3NCQUQzQixLQUFLO3VCQUFDLHNCQUFzQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERpcmVjdGl2ZSwgSW5wdXQsIE9uQ2hhbmdlcyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQWJzdHJhY3RDb250cm9sLCBWYWxpZGF0aW9uRXJyb3JzIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5pbXBvcnQgeyBGc0NvbnRyb2xEaXJlY3RpdmUgfSBmcm9tICcuL2NvbnRyb2wuZGlyZWN0aXZlJztcbmltcG9ydCB7IEZzVmFsaWRhdG9ycyB9IGZyb20gJy4uLy4uL3ZhbGlkYXRvcnMvdmFsaWRhdG9ycyc7XG5pbXBvcnQgeyBWQUxJREFURV9NRVNTQUdFX1BST1ZJREVSIH0gZnJvbSAnLi4vLi4vcHJvdmlkZXJzL3ZhbGlkYXRlLW1lc3NhZ2VzLnByb3ZpZGVyJztcbmltcG9ydCB7IEZzVmFsaWRhdG9yIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy92YWxpZGF0b3InO1xuXG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tmc0Zvcm1HcmVhdGVyXScsXG4gIHByb3ZpZGVyczogW1xuICAgIFZBTElEQVRFX01FU1NBR0VfUFJPVklERVJcbiAgXSxcbn0pXG5leHBvcnQgY2xhc3MgRnNGb3JtR3JlYXRlckRpcmVjdGl2ZSBleHRlbmRzIEZzQ29udHJvbERpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uQ2hhbmdlcywgRnNWYWxpZGF0b3Ige1xuXG4gIEBJbnB1dCgpXG4gIHB1YmxpYyBmc0Zvcm1HcmVhdGVyO1xuXG4gIEBJbnB1dCgnZnNGb3JtR3JlYXRlck1lc3NhZ2UnKVxuICBwdWJsaWMgc2V0IHZhbGlkYXRpb25NZXNzYWdlKHZhbHVlOiBzdHJpbmcpIHtcbiAgICB0aGlzLl92YWxpZGF0ZU1lc3NhZ2VzLmdyZWF0ZXIgPSB2YWx1ZTtcbiAgfVxuXG4gIHB1YmxpYyBuZ09uQ2hhbmdlcygpOiB2b2lkIHtcbiAgICB0aGlzLl9jb250cm9sLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKTtcbiAgfVxuXG4gIHB1YmxpYyB2YWxpZGF0ZShjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCB7XG4gICAgY29uc3QgZ3JlYXRlciA9IHBhcnNlRmxvYXQodGhpcy5mc0Zvcm1HcmVhdGVyKTtcbiAgICBjb25zdCB2YWx1ZSA9IHBhcnNlRmxvYXQodGhpcy5fY29udHJvbC52YWx1ZSk7XG5cbiAgICBpZiAoIWlzTmFOKGdyZWF0ZXIpICYmICFpc05hTih2YWx1ZSkgJiYgdmFsdWUgPD0gZ3JlYXRlcikge1xuICAgICAgcmV0dXJuIHsgZ3JlYXRlcjogeyBncmVhdGVyLCBhY3R1YWw6IHZhbHVlIH0gfTtcbiAgICB9XG5cbiAgICByZXR1cm4gRnNWYWxpZGF0b3JzLm51bWVyaWModGhpcy5fY29udHJvbCk7XG4gIH1cblxufVxuIl19