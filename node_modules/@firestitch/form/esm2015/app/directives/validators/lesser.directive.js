import { Directive, Input } from '@angular/core';
import { FsControlDirective } from './control.directive';
import { FsValidators } from '../../validators/validators';
import { VALIDATE_MESSAGE_PROVIDER } from '../../providers/validate-messages.provider';
import * as i0 from "@angular/core";
export class FsFormLesserDirective extends FsControlDirective {
    set validationMessage(value) {
        this._validateMessages.lesser = value;
    }
    ngOnChanges() {
        this._control.updateValueAndValidity();
    }
    validate(control) {
        const lesser = parseFloat(this.fsFormLesser);
        const value = parseFloat(this._control.value);
        if (!isNaN(lesser) && !isNaN(value) && value >= lesser) {
            return { lesser: { lesser, actual: value } };
        }
        return FsValidators.numeric(this._control);
    }
}
FsFormLesserDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsFormLesserDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
FsFormLesserDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: FsFormLesserDirective, selector: "[fsFormLesser]", inputs: { fsFormLesser: "fsFormLesser", validationMessage: ["fsFormLesserMessage", "validationMessage"] }, providers: [
        VALIDATE_MESSAGE_PROVIDER
    ], usesInheritance: true, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsFormLesserDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[fsFormLesser]',
                    providers: [
                        VALIDATE_MESSAGE_PROVIDER
                    ],
                }]
        }], propDecorators: { fsFormLesser: [{
                type: Input
            }], validationMessage: [{
                type: Input,
                args: ['fsFormLesserMessage']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGVzc2VyLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9hcHAvZGlyZWN0aXZlcy92YWxpZGF0b3JzL2xlc3Nlci5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQWEsTUFBTSxlQUFlLENBQUM7QUFHNUQsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDekQsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBQzNELE9BQU8sRUFBRSx5QkFBeUIsRUFBRSxNQUFNLDRDQUE0QyxDQUFDOztBQVV2RixNQUFNLE9BQU8scUJBQXNCLFNBQVEsa0JBQWtCO0lBSzNELElBQ1csaUJBQWlCLENBQUMsS0FBYTtRQUN4QyxJQUFJLENBQUMsaUJBQWlCLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQztJQUN4QyxDQUFDO0lBRU0sV0FBVztRQUNoQixJQUFJLENBQUMsUUFBUSxDQUFDLHNCQUFzQixFQUFFLENBQUM7SUFDekMsQ0FBQztJQUVNLFFBQVEsQ0FBQyxPQUF3QjtRQUN0QyxNQUFNLE1BQU0sR0FBRyxVQUFVLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBQzdDLE1BQU0sS0FBSyxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRTlDLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLElBQUksS0FBSyxJQUFJLE1BQU0sRUFBRTtZQUN0RCxPQUFPLEVBQUUsTUFBTSxFQUFFLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsRUFBRSxDQUFDO1NBQzlDO1FBRUQsT0FBTyxZQUFZLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUM3QyxDQUFDOzttSEF2QlUscUJBQXFCO3VHQUFyQixxQkFBcUIsb0pBSnJCO1FBQ1QseUJBQXlCO0tBQzFCOzRGQUVVLHFCQUFxQjtrQkFOakMsU0FBUzttQkFBQztvQkFDVCxRQUFRLEVBQUUsZ0JBQWdCO29CQUMxQixTQUFTLEVBQUU7d0JBQ1QseUJBQXlCO3FCQUMxQjtpQkFDRjs4QkFJUSxZQUFZO3NCQURsQixLQUFLO2dCQUlLLGlCQUFpQjtzQkFEM0IsS0FBSzt1QkFBQyxxQkFBcUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEaXJlY3RpdmUsIElucHV0LCBPbkNoYW5nZXMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEFic3RyYWN0Q29udHJvbCwgVmFsaWRhdGlvbkVycm9ycyB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgRnNDb250cm9sRGlyZWN0aXZlIH0gZnJvbSAnLi9jb250cm9sLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBGc1ZhbGlkYXRvcnMgfSBmcm9tICcuLi8uLi92YWxpZGF0b3JzL3ZhbGlkYXRvcnMnO1xuaW1wb3J0IHsgVkFMSURBVEVfTUVTU0FHRV9QUk9WSURFUiB9IGZyb20gJy4uLy4uL3Byb3ZpZGVycy92YWxpZGF0ZS1tZXNzYWdlcy5wcm92aWRlcic7XG5pbXBvcnQgeyBGc1ZhbGlkYXRvciB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvdmFsaWRhdG9yJztcblxuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbZnNGb3JtTGVzc2VyXScsXG4gIHByb3ZpZGVyczogW1xuICAgIFZBTElEQVRFX01FU1NBR0VfUFJPVklERVJcbiAgXSxcbn0pXG5leHBvcnQgY2xhc3MgRnNGb3JtTGVzc2VyRGlyZWN0aXZlIGV4dGVuZHMgRnNDb250cm9sRGlyZWN0aXZlIGltcGxlbWVudHMgT25DaGFuZ2VzLCBGc1ZhbGlkYXRvciB7XG5cbiAgQElucHV0KClcbiAgcHVibGljIGZzRm9ybUxlc3NlcjtcblxuICBASW5wdXQoJ2ZzRm9ybUxlc3Nlck1lc3NhZ2UnKVxuICBwdWJsaWMgc2V0IHZhbGlkYXRpb25NZXNzYWdlKHZhbHVlOiBzdHJpbmcpIHtcbiAgICB0aGlzLl92YWxpZGF0ZU1lc3NhZ2VzLmxlc3NlciA9IHZhbHVlO1xuICB9XG5cbiAgcHVibGljIG5nT25DaGFuZ2VzKCk6IHZvaWQge1xuICAgIHRoaXMuX2NvbnRyb2wudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpO1xuICB9XG5cbiAgcHVibGljIHZhbGlkYXRlKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsIHtcbiAgICBjb25zdCBsZXNzZXIgPSBwYXJzZUZsb2F0KHRoaXMuZnNGb3JtTGVzc2VyKTtcbiAgICBjb25zdCB2YWx1ZSA9IHBhcnNlRmxvYXQodGhpcy5fY29udHJvbC52YWx1ZSk7XG5cbiAgICBpZiAoIWlzTmFOKGxlc3NlcikgJiYgIWlzTmFOKHZhbHVlKSAmJiB2YWx1ZSA+PSBsZXNzZXIpIHtcbiAgICAgIHJldHVybiB7IGxlc3NlcjogeyBsZXNzZXIsIGFjdHVhbDogdmFsdWUgfSB9O1xuICAgIH1cblxuICAgIHJldHVybiBGc1ZhbGlkYXRvcnMubnVtZXJpYyh0aGlzLl9jb250cm9sKTtcbiAgfVxuXG59XG4iXX0=