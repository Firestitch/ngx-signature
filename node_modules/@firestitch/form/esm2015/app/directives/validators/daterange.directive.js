import { Directive, Input } from '@angular/core';
import { FsControlDirective } from './control.directive';
import { FsValidators } from '../../validators/validators';
import { VALIDATE_MESSAGE_PROVIDER } from '../../providers/validate-messages.provider';
import { isEnabled } from '../../helpers/is-enabled';
import * as i0 from "@angular/core";
export class FsFormDateRangeDirective extends FsControlDirective {
    set validationMessage(value) {
        this._validateMessages.dateRange = value;
    }
    ngOnChanges() {
        this._control.updateValueAndValidity();
    }
    validate(control) {
        if (isEnabled(this.fsFormDateRange)) {
            return FsValidators.dateRange(this._control);
        }
        else {
            return null;
        }
    }
}
FsFormDateRangeDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsFormDateRangeDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
FsFormDateRangeDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: FsFormDateRangeDirective, selector: "[fsFormDateRange]", inputs: { fsFormDateRange: "fsFormDateRange", validationMessage: ["fsFormDateRangeMessage", "validationMessage"] }, providers: [
        VALIDATE_MESSAGE_PROVIDER
    ], usesInheritance: true, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsFormDateRangeDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[fsFormDateRange]',
                    providers: [
                        VALIDATE_MESSAGE_PROVIDER
                    ],
                }]
        }], propDecorators: { fsFormDateRange: [{
                type: Input
            }], validationMessage: [{
                type: Input,
                args: ['fsFormDateRangeMessage']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZXJhbmdlLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9hcHAvZGlyZWN0aXZlcy92YWxpZGF0b3JzL2RhdGVyYW5nZS5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQWEsTUFBTSxlQUFlLENBQUM7QUFHNUQsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDekQsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBQzNELE9BQU8sRUFBRSx5QkFBeUIsRUFBRSxNQUFNLDRDQUE0QyxDQUFDO0FBRXZGLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQzs7QUFTckQsTUFBTSxPQUFPLHdCQUF5QixTQUFRLGtCQUFrQjtJQUs5RCxJQUNXLGlCQUFpQixDQUFDLEtBQWE7UUFDeEMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7SUFDM0MsQ0FBQztJQUVNLFdBQVc7UUFDaEIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxzQkFBc0IsRUFBRSxDQUFDO0lBQ3pDLENBQUM7SUFFTSxRQUFRLENBQUMsT0FBd0I7UUFDdEMsSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxFQUFFO1lBQ25DLE9BQU8sWUFBWSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7U0FDOUM7YUFBTTtZQUNMLE9BQU8sSUFBSSxDQUFDO1NBQ2I7SUFDSCxDQUFDOztzSEFwQlUsd0JBQXdCOzBHQUF4Qix3QkFBd0IsZ0tBSnhCO1FBQ1QseUJBQXlCO0tBQzFCOzRGQUVVLHdCQUF3QjtrQkFOcEMsU0FBUzttQkFBQztvQkFDVCxRQUFRLEVBQUUsbUJBQW1CO29CQUM3QixTQUFTLEVBQUU7d0JBQ1QseUJBQXlCO3FCQUMxQjtpQkFDRjs4QkFJUSxlQUFlO3NCQURyQixLQUFLO2dCQUlLLGlCQUFpQjtzQkFEM0IsS0FBSzt1QkFBQyx3QkFBd0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEaXJlY3RpdmUsIElucHV0LCBPbkNoYW5nZXMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEFic3RyYWN0Q29udHJvbCwgVmFsaWRhdGlvbkVycm9ycyB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgRnNDb250cm9sRGlyZWN0aXZlIH0gZnJvbSAnLi9jb250cm9sLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBGc1ZhbGlkYXRvcnMgfSBmcm9tICcuLi8uLi92YWxpZGF0b3JzL3ZhbGlkYXRvcnMnO1xuaW1wb3J0IHsgVkFMSURBVEVfTUVTU0FHRV9QUk9WSURFUiB9IGZyb20gJy4uLy4uL3Byb3ZpZGVycy92YWxpZGF0ZS1tZXNzYWdlcy5wcm92aWRlcic7XG5pbXBvcnQgeyBGc1ZhbGlkYXRvciB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvdmFsaWRhdG9yJztcbmltcG9ydCB7IGlzRW5hYmxlZCB9IGZyb20gJy4uLy4uL2hlbHBlcnMvaXMtZW5hYmxlZCc7XG5cblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW2ZzRm9ybURhdGVSYW5nZV0nLFxuICBwcm92aWRlcnM6IFtcbiAgICBWQUxJREFURV9NRVNTQUdFX1BST1ZJREVSXG4gIF0sXG59KVxuZXhwb3J0IGNsYXNzIEZzRm9ybURhdGVSYW5nZURpcmVjdGl2ZSBleHRlbmRzIEZzQ29udHJvbERpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uQ2hhbmdlcywgRnNWYWxpZGF0b3Ige1xuXG4gIEBJbnB1dCgpXG4gIHB1YmxpYyBmc0Zvcm1EYXRlUmFuZ2U7XG5cbiAgQElucHV0KCdmc0Zvcm1EYXRlUmFuZ2VNZXNzYWdlJylcbiAgcHVibGljIHNldCB2YWxpZGF0aW9uTWVzc2FnZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgdGhpcy5fdmFsaWRhdGVNZXNzYWdlcy5kYXRlUmFuZ2UgPSB2YWx1ZTtcbiAgfVxuXG4gIHB1YmxpYyBuZ09uQ2hhbmdlcygpIHtcbiAgICB0aGlzLl9jb250cm9sLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKTtcbiAgfVxuXG4gIHB1YmxpYyB2YWxpZGF0ZShjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCB7XG4gICAgaWYgKGlzRW5hYmxlZCh0aGlzLmZzRm9ybURhdGVSYW5nZSkpIHtcbiAgICAgIHJldHVybiBGc1ZhbGlkYXRvcnMuZGF0ZVJhbmdlKHRoaXMuX2NvbnRyb2wpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbn1cbiJdfQ==