import { Injectable } from '@angular/core';
import { FsPrompt } from '@firestitch/prompt';
import { of } from 'rxjs';
import { FsFormDirective } from '../directives/form/form.directive';
import { confirmUnsaved } from '../helpers/confirm-unsaved';
import { map } from 'rxjs/operators';
import { confirmResultContinue } from '../helpers';
import * as i0 from "@angular/core";
import * as i1 from "@firestitch/prompt";
export class FormDeactivateGuard {
    constructor(_prompt) {
        this._prompt = _prompt;
    }
    canDeactivate(directive) {
        if (!('getForm' in directive)) {
            const error = `Directive ${directive.constructor.name} does not property implement interface FormDeactivate`;
            console.error(error);
            return of(true);
        }
        const form = directive.getForm();
        if (!(form instanceof FsFormDirective)) {
            const error = `Directive ${directive.constructor.name}.getForm() does not return a valid FsFormDirective`;
            console.error(error);
            return of(true);
        }
        return confirmUnsaved(form, this._prompt)
            .pipe(map((result) => {
            return confirmResultContinue(result);
        }));
    }
}
FormDeactivateGuard.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FormDeactivateGuard, deps: [{ token: i1.FsPrompt }], target: i0.ɵɵFactoryTarget.Injectable });
FormDeactivateGuard.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FormDeactivateGuard, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FormDeactivateGuard, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i1.FsPrompt }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm9ybS1kZWFjdGl2YXRlLmd1YXJkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2FwcC9ndWFyZHMvZm9ybS1kZWFjdGl2YXRlLmd1YXJkLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFM0MsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBQzlDLE9BQU8sRUFBYyxFQUFFLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDdEMsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLG1DQUFtQyxDQUFDO0FBRXBFLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUM1RCxPQUFPLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDckMsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sWUFBWSxDQUFDOzs7QUFLbkQsTUFBTSxPQUFPLG1CQUFtQjtJQUU5QixZQUFvQixPQUFpQjtRQUFqQixZQUFPLEdBQVAsT0FBTyxDQUFVO0lBQUcsQ0FBQztJQUV6QyxhQUFhLENBQUMsU0FBeUI7UUFFckMsSUFBSSxDQUFDLENBQUMsU0FBUyxJQUFJLFNBQVMsQ0FBQyxFQUFFO1lBQzdCLE1BQU0sS0FBSyxHQUFHLGFBQW1CLFNBQVUsQ0FBQyxXQUFXLENBQUMsSUFBSSx1REFBdUQsQ0FBQztZQUNwSCxPQUFPLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3JCLE9BQU8sRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ2pCO1FBRUQsTUFBTSxJQUFJLEdBQW9CLFNBQVMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUVsRCxJQUFJLENBQUMsQ0FBQyxJQUFJLFlBQVksZUFBZSxDQUFDLEVBQUU7WUFDdEMsTUFBTSxLQUFLLEdBQUcsYUFBYSxTQUFTLENBQUMsV0FBVyxDQUFDLElBQUksb0RBQW9ELENBQUM7WUFDMUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNyQixPQUFPLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUNqQjtRQUVELE9BQU8sY0FBYyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDO2FBQ3RDLElBQUksQ0FDSCxHQUFHLENBQUMsQ0FBQyxNQUFNLEVBQUUsRUFBRTtZQUNiLE9BQU8scUJBQXFCLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDdkMsQ0FBQyxDQUFDLENBQ0gsQ0FBQztJQUNOLENBQUM7O2lIQTFCVSxtQkFBbUI7cUhBQW5CLG1CQUFtQixjQUZsQixNQUFNOzRGQUVQLG1CQUFtQjtrQkFIL0IsVUFBVTttQkFBQztvQkFDVixVQUFVLEVBQUUsTUFBTTtpQkFDbkIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDYW5EZWFjdGl2YXRlIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcbmltcG9ydCB7IEZzUHJvbXB0IH0gZnJvbSAnQGZpcmVzdGl0Y2gvcHJvbXB0JztcbmltcG9ydCB7IE9ic2VydmFibGUsIG9mIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBGc0Zvcm1EaXJlY3RpdmUgfSBmcm9tICcuLi9kaXJlY3RpdmVzL2Zvcm0vZm9ybS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgRm9ybURlYWN0aXZhdGUgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2Zvcm0tZGVhY3RpdmF0ZSc7XG5pbXBvcnQgeyBjb25maXJtVW5zYXZlZCB9IGZyb20gJy4uL2hlbHBlcnMvY29uZmlybS11bnNhdmVkJztcbmltcG9ydCB7IG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IGNvbmZpcm1SZXN1bHRDb250aW51ZSB9IGZyb20gJy4uL2hlbHBlcnMnO1xuXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46ICdyb290J1xufSlcbmV4cG9ydCBjbGFzcyBGb3JtRGVhY3RpdmF0ZUd1YXJkIGltcGxlbWVudHMgQ2FuRGVhY3RpdmF0ZTxhbnk+IHtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9wcm9tcHQ6IEZzUHJvbXB0KSB7fVxuXG4gIGNhbkRlYWN0aXZhdGUoZGlyZWN0aXZlOiBGb3JtRGVhY3RpdmF0ZSk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuXG4gICAgaWYgKCEoJ2dldEZvcm0nIGluIGRpcmVjdGl2ZSkpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gYERpcmVjdGl2ZSAkeyg8YW55PmRpcmVjdGl2ZSkuY29uc3RydWN0b3IubmFtZX0gZG9lcyBub3QgcHJvcGVydHkgaW1wbGVtZW50IGludGVyZmFjZSBGb3JtRGVhY3RpdmF0ZWA7XG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgIHJldHVybiBvZih0cnVlKTtcbiAgICB9XG5cbiAgICBjb25zdCBmb3JtOiBGc0Zvcm1EaXJlY3RpdmUgPSBkaXJlY3RpdmUuZ2V0Rm9ybSgpO1xuXG4gICAgaWYgKCEoZm9ybSBpbnN0YW5jZW9mIEZzRm9ybURpcmVjdGl2ZSkpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gYERpcmVjdGl2ZSAke2RpcmVjdGl2ZS5jb25zdHJ1Y3Rvci5uYW1lfS5nZXRGb3JtKCkgZG9lcyBub3QgcmV0dXJuIGEgdmFsaWQgRnNGb3JtRGlyZWN0aXZlYDtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgcmV0dXJuIG9mKHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiBjb25maXJtVW5zYXZlZChmb3JtLCB0aGlzLl9wcm9tcHQpXG4gICAgICAucGlwZShcbiAgICAgICAgbWFwKChyZXN1bHQpID0+IHtcbiAgICAgICAgICByZXR1cm4gY29uZmlybVJlc3VsdENvbnRpbnVlKHJlc3VsdCk7XG4gICAgICAgIH0pLFxuICAgICAgKTtcbiAgfVxufVxuIl19