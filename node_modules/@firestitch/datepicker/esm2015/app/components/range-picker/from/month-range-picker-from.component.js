import { ChangeDetectionStrategy, Component, Input, } from '@angular/core';
import { takeUntil } from 'rxjs/operators';
import { startOfDay } from 'date-fns';
import { zonedTimeToUtc } from 'date-fns-tz';
import { PickerViewType } from '../../../../libs/common/enums/picker-view-type.enum';
import { FsDatePickerComponent } from '../../date-picker/date-picker.component';
import { RangePickerFromComponent } from '../base/range-picker-from.component';
import * as i0 from "@angular/core";
import * as i1 from "@firestitch/clear";
import * as i2 from "../../date-picker-trigger/date-picker-trigger.component";
export class MonthRangePickerFromComponent extends RangePickerFromComponent {
    constructor() {
        super(...arguments);
        this.view = PickerViewType.MonthRange;
        this._skipUpdateValue = false;
    }
    set fsMonthRangeFrom(value) {
        this._name = value;
    }
    set fsMonthRangeFromPicker(value) {
        this._name = value;
    }
    ngOnInit() {
        super.ngOnInit();
        this._subscribeToPickerRefUpdates();
    }
    cleared(event) {
        super.cleared(event);
        this._pickerRef.updateEndDate(null);
    }
    updateValue(value) {
        value = startOfDay(value);
        this._value = value;
        this.updateInput(this._value);
        if (value && this.timezone) {
            value = zonedTimeToUtc(value, this.timezone);
        }
        this.onChange(value);
        this.onTouch(value);
    }
    _tzChanged(originDate) {
        this._skipUpdateValue = true;
        super._tzChanged(originDate);
    }
    _processInputDate(date) {
        date = super._processInputDate(date);
        if (date) {
            date = startOfDay(date);
        }
        return date;
    }
    /**
     * When it's month range picker - we have to listen changes over rangePickerRef
     */
    _listenDialogValueChanges() {
        // NOOP
    }
    _subscribeToPickerRefUpdates() {
        this._pickerRefUpdates$(this._pickerRef.startDate$)
            .pipe(takeUntil(this._destroy$))
            .subscribe((newValue) => {
            if (this._skipUpdateValue) {
                this._skipUpdateValue = false;
                return;
            }
            this.updateValue(newValue);
            this._ngControl.control.markAsDirty();
            this._ngControl.control.updateValueAndValidity();
            this._cdRef.markForCheck();
        });
    }
}
MonthRangePickerFromComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: MonthRangePickerFromComponent, deps: null, target: i0.ɵɵFactoryTarget.Component });
MonthRangePickerFromComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: MonthRangePickerFromComponent, selector: "[fsMonthRangeFrom],[fsMonthRangeFromPicker]", inputs: { fsMonthRangeFrom: "fsMonthRangeFrom", fsMonthRangeFromPicker: "fsMonthRangeFromPicker" }, usesInheritance: true, ngImport: i0, template: "\n    <fs-clear [show]=\"value && !disabled && !readonly && clear\" (clear)=\"cleared($event)\"></fs-clear>\n    <fs-datepicker-trigger (click)=\"triggerClick()\" [disabled]=\"disabled || readonly\" [view]=\"view\"></fs-datepicker-trigger>\n  ", isInline: true, components: [{ type: i1.FsClearElementComponent, selector: "fs-clear", inputs: ["show"], outputs: ["clear"] }, { type: i2.FsDatePickerTriggerComponent, selector: "fs-datepicker-trigger", inputs: ["disabled", "view"], outputs: ["click"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: MonthRangePickerFromComponent, decorators: [{
            type: Component,
            args: [{
                    selector: '[fsMonthRangeFrom],[fsMonthRangeFromPicker]',
                    template: FsDatePickerComponent.template,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], propDecorators: { fsMonthRangeFrom: [{
                type: Input
            }], fsMonthRangeFromPicker: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9udGgtcmFuZ2UtcGlja2VyLWZyb20uY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vc3JjL2FwcC9jb21wb25lbnRzL3JhbmdlLXBpY2tlci9mcm9tL21vbnRoLXJhbmdlLXBpY2tlci1mcm9tLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0wsdUJBQXVCLEVBQ3ZCLFNBQVMsRUFDVCxLQUFLLEdBRU4sTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRTNDLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxVQUFVLENBQUM7QUFDdEMsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUU3QyxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0scURBQXFELENBQUM7QUFFckYsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0seUNBQXlDLENBQUM7QUFDaEYsT0FBTyxFQUFFLHdCQUF3QixFQUFFLE1BQU0scUNBQXFDLENBQUM7Ozs7QUFRL0UsTUFBTSxPQUFPLDZCQUE4QixTQUFRLHdCQUF3QjtJQUwzRTs7UUFlUyxTQUFJLEdBQUcsY0FBYyxDQUFDLFVBQVUsQ0FBQztRQUVoQyxxQkFBZ0IsR0FBRyxLQUFLLENBQUM7S0FxRWxDO0lBL0VDLElBQWEsZ0JBQWdCLENBQUMsS0FBSztRQUNqQyxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztJQUNyQixDQUFDO0lBRUQsSUFBYSxzQkFBc0IsQ0FBQyxLQUFLO1FBQ3ZDLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO0lBQ3JCLENBQUM7SUFNTSxRQUFRO1FBQ2IsS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBRWpCLElBQUksQ0FBQyw0QkFBNEIsRUFBRSxDQUFDO0lBQ3RDLENBQUM7SUFFTSxPQUFPLENBQUMsS0FBSztRQUNsQixLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRXJCLElBQUksQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3RDLENBQUM7SUFFTSxXQUFXLENBQUMsS0FBVztRQUM1QixLQUFLLEdBQUcsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRTFCLElBQUksQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDO1FBQ3BCLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRTlCLElBQUksS0FBSyxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDMUIsS0FBSyxHQUFHLGNBQWMsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1NBQzlDO1FBRUQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNyQixJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3RCLENBQUM7SUFFUyxVQUFVLENBQUMsVUFBdUI7UUFDMUMsSUFBSSxDQUFDLGdCQUFnQixHQUFHLElBQUksQ0FBQztRQUU3QixLQUFLLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQy9CLENBQUM7SUFFUyxpQkFBaUIsQ0FBQyxJQUFpQjtRQUMzQyxJQUFJLEdBQUcsS0FBSyxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxDQUFDO1FBRXJDLElBQUksSUFBSSxFQUFFO1lBQ1IsSUFBSSxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUN6QjtRQUVELE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVEOztPQUVHO0lBQ08seUJBQXlCO1FBQ2pDLE9BQU87SUFDVCxDQUFDO0lBRVMsNEJBQTRCO1FBQ3BDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQzthQUNoRCxJQUFJLENBQ0gsU0FBUyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FDMUI7YUFDQSxTQUFTLENBQUMsQ0FBQyxRQUFxQixFQUFFLEVBQUU7WUFDbkMsSUFBSSxJQUFJLENBQUMsZ0JBQWdCLEVBQUU7Z0JBQ3pCLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxLQUFLLENBQUM7Z0JBQzlCLE9BQU87YUFDUjtZQUVELElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUM7WUFFM0IsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsV0FBVyxFQUFFLENBQUM7WUFDdEMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsc0JBQXNCLEVBQUUsQ0FBQztZQUNqRCxJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksRUFBRSxDQUFDO1FBQzdCLENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQzs7MkhBaEZVLDZCQUE2QjsrR0FBN0IsNkJBQTZCOzRGQUE3Qiw2QkFBNkI7a0JBTHpDLFNBQVM7bUJBQUM7b0JBQ1QsUUFBUSxFQUFFLDZDQUE2QztvQkFDdkQsUUFBUSxFQUFFLHFCQUFxQixDQUFDLFFBQVE7b0JBQ3hDLGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNO2lCQUNoRDs4QkFHYyxnQkFBZ0I7c0JBQTVCLEtBQUs7Z0JBSU8sc0JBQXNCO3NCQUFsQyxLQUFLIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENvbXBvbmVudCxcbiAgSW5wdXQsXG4gIE9uSW5pdCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHsgc3RhcnRPZkRheSB9IGZyb20gJ2RhdGUtZm5zJztcbmltcG9ydCB7IHpvbmVkVGltZVRvVXRjIH0gZnJvbSAnZGF0ZS1mbnMtdHonO1xuXG5pbXBvcnQgeyBQaWNrZXJWaWV3VHlwZSB9IGZyb20gJy4uLy4uLy4uLy4uL2xpYnMvY29tbW9uL2VudW1zL3BpY2tlci12aWV3LXR5cGUuZW51bSc7XG5cbmltcG9ydCB7IEZzRGF0ZVBpY2tlckNvbXBvbmVudCB9IGZyb20gJy4uLy4uL2RhdGUtcGlja2VyL2RhdGUtcGlja2VyLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBSYW5nZVBpY2tlckZyb21Db21wb25lbnQgfSBmcm9tICcuLi9iYXNlL3JhbmdlLXBpY2tlci1mcm9tLmNvbXBvbmVudCc7XG5cblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnW2ZzTW9udGhSYW5nZUZyb21dLFtmc01vbnRoUmFuZ2VGcm9tUGlja2VyXScsXG4gIHRlbXBsYXRlOiBGc0RhdGVQaWNrZXJDb21wb25lbnQudGVtcGxhdGUsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxufSlcbmV4cG9ydCBjbGFzcyBNb250aFJhbmdlUGlja2VyRnJvbUNvbXBvbmVudCBleHRlbmRzIFJhbmdlUGlja2VyRnJvbUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG5cbiAgQElucHV0KCkgc2V0IGZzTW9udGhSYW5nZUZyb20odmFsdWUpIHtcbiAgICB0aGlzLl9uYW1lID0gdmFsdWU7XG4gIH1cblxuICBASW5wdXQoKSBzZXQgZnNNb250aFJhbmdlRnJvbVBpY2tlcih2YWx1ZSkge1xuICAgIHRoaXMuX25hbWUgPSB2YWx1ZTtcbiAgfVxuXG4gIHB1YmxpYyB2aWV3ID0gUGlja2VyVmlld1R5cGUuTW9udGhSYW5nZTtcblxuICBwcml2YXRlIF9za2lwVXBkYXRlVmFsdWUgPSBmYWxzZTtcblxuICBwdWJsaWMgbmdPbkluaXQoKSB7XG4gICAgc3VwZXIubmdPbkluaXQoKTtcblxuICAgIHRoaXMuX3N1YnNjcmliZVRvUGlja2VyUmVmVXBkYXRlcygpO1xuICB9XG5cbiAgcHVibGljIGNsZWFyZWQoZXZlbnQpIHtcbiAgICBzdXBlci5jbGVhcmVkKGV2ZW50KTtcblxuICAgIHRoaXMuX3BpY2tlclJlZi51cGRhdGVFbmREYXRlKG51bGwpO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZVZhbHVlKHZhbHVlOiBEYXRlKSB7XG4gICAgdmFsdWUgPSBzdGFydE9mRGF5KHZhbHVlKTtcblxuICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGVJbnB1dCh0aGlzLl92YWx1ZSk7XG5cbiAgICBpZiAodmFsdWUgJiYgdGhpcy50aW1lem9uZSkge1xuICAgICAgdmFsdWUgPSB6b25lZFRpbWVUb1V0Yyh2YWx1ZSwgdGhpcy50aW1lem9uZSk7XG4gICAgfVxuXG4gICAgdGhpcy5vbkNoYW5nZSh2YWx1ZSk7XG4gICAgdGhpcy5vblRvdWNoKHZhbHVlKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfdHpDaGFuZ2VkKG9yaWdpbkRhdGU6IERhdGUgfCBudWxsKSB7XG4gICAgdGhpcy5fc2tpcFVwZGF0ZVZhbHVlID0gdHJ1ZTtcblxuICAgIHN1cGVyLl90ekNoYW5nZWQob3JpZ2luRGF0ZSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX3Byb2Nlc3NJbnB1dERhdGUoZGF0ZTogRGF0ZSB8IG51bGwpOiBEYXRlIHwgbnVsbCB7XG4gICAgZGF0ZSA9IHN1cGVyLl9wcm9jZXNzSW5wdXREYXRlKGRhdGUpO1xuXG4gICAgaWYgKGRhdGUpIHtcbiAgICAgIGRhdGUgPSBzdGFydE9mRGF5KGRhdGUpO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZW4gaXQncyBtb250aCByYW5nZSBwaWNrZXIgLSB3ZSBoYXZlIHRvIGxpc3RlbiBjaGFuZ2VzIG92ZXIgcmFuZ2VQaWNrZXJSZWZcbiAgICovXG4gIHByb3RlY3RlZCBfbGlzdGVuRGlhbG9nVmFsdWVDaGFuZ2VzKCkge1xuICAgIC8vIE5PT1BcbiAgfVxuXG4gIHByb3RlY3RlZCBfc3Vic2NyaWJlVG9QaWNrZXJSZWZVcGRhdGVzKCkge1xuICAgIHRoaXMuX3BpY2tlclJlZlVwZGF0ZXMkKHRoaXMuX3BpY2tlclJlZi5zdGFydERhdGUkKVxuICAgICAgLnBpcGUoXG4gICAgICAgIHRha2VVbnRpbCh0aGlzLl9kZXN0cm95JCksXG4gICAgICApXG4gICAgICAuc3Vic2NyaWJlKChuZXdWYWx1ZTogRGF0ZSB8IG51bGwpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX3NraXBVcGRhdGVWYWx1ZSkge1xuICAgICAgICAgIHRoaXMuX3NraXBVcGRhdGVWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlVmFsdWUobmV3VmFsdWUpO1xuXG4gICAgICAgIHRoaXMuX25nQ29udHJvbC5jb250cm9sLm1hcmtBc0RpcnR5KCk7XG4gICAgICAgIHRoaXMuX25nQ29udHJvbC5jb250cm9sLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKTtcbiAgICAgICAgdGhpcy5fY2RSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgICB9KTtcbiAgfVxufVxuIl19