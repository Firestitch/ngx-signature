import { ChangeDetectionStrategy, Component, Input, } from '@angular/core';
import { takeUntil } from 'rxjs/operators';
import { zonedTimeToUtc } from 'date-fns-tz';
import { endOfDay } from 'date-fns';
import { PickerViewType } from '../../../../libs/common/enums/picker-view-type.enum';
import { FsDatePickerComponent } from '../../date-picker/date-picker.component';
import { RangePickerToComponent } from '../base/range-picker-to.component';
import * as i0 from "@angular/core";
import * as i1 from "@firestitch/clear";
import * as i2 from "../../date-picker-trigger/date-picker-trigger.component";
export class MonthRangePickerToComponent extends RangePickerToComponent {
    constructor() {
        super(...arguments);
        this.view = PickerViewType.MonthRange;
        this._skipUpdateValue = false;
    }
    set fsMonthRangeTo(value) {
        this._name = value;
    }
    set fsMonthRangeToPicker(value) {
        this._name = value;
    }
    updateValue(value) {
        if (value) {
            value = endOfDay(value);
        }
        this._value = value;
        this.updateInput(this._value);
        if (value && this.timezone) {
            value = zonedTimeToUtc(value, this.timezone);
        }
        this.onChange(value);
        this.onTouch(value);
    }
    _tzChanged(originDate) {
        this._skipUpdateValue = true;
        super._tzChanged(originDate);
    }
    _processInputDate(date) {
        date = super._processInputDate(date);
        if (date) {
            date = endOfDay(date);
        }
        return date;
    }
    /**
     * When it's month range picker - we have to listen changes over rangePickerRef
     */
    _listenDialogValueChanges() {
        // NOOP
    }
    _subscribeToPickerRefUpdates() {
        this._pickerRefUpdates$(this._pickerRef.endDate$)
            .pipe(takeUntil(this._destroy$))
            .subscribe((newValue) => {
            if (this._skipUpdateValue) {
                this._skipUpdateValue = false;
                return;
            }
            this.updateValue(newValue);
            this._ngControl.control.markAsDirty();
            this._ngControl.control.updateValueAndValidity();
            this._cdRef.markForCheck();
        });
    }
}
MonthRangePickerToComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: MonthRangePickerToComponent, deps: null, target: i0.ɵɵFactoryTarget.Component });
MonthRangePickerToComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: MonthRangePickerToComponent, selector: "[fsMonthRangeTo],[fsMonthRangeToPicker]", inputs: { fsMonthRangeTo: "fsMonthRangeTo", fsMonthRangeToPicker: "fsMonthRangeToPicker" }, usesInheritance: true, ngImport: i0, template: "\n    <fs-clear [show]=\"value && !disabled && !readonly && clear\" (clear)=\"cleared($event)\"></fs-clear>\n    <fs-datepicker-trigger (click)=\"triggerClick()\" [disabled]=\"disabled || readonly\" [view]=\"view\"></fs-datepicker-trigger>\n  ", isInline: true, components: [{ type: i1.FsClearElementComponent, selector: "fs-clear", inputs: ["show"], outputs: ["clear"] }, { type: i2.FsDatePickerTriggerComponent, selector: "fs-datepicker-trigger", inputs: ["disabled", "view"], outputs: ["click"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: MonthRangePickerToComponent, decorators: [{
            type: Component,
            args: [{
                    selector: '[fsMonthRangeTo],[fsMonthRangeToPicker]',
                    template: FsDatePickerComponent.template,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], propDecorators: { fsMonthRangeTo: [{
                type: Input
            }], fsMonthRangeToPicker: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9udGgtcmFuZ2UtcGlja2VyLXRvLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3NyYy9hcHAvY29tcG9uZW50cy9yYW5nZS1waWNrZXIvdG8vbW9udGgtcmFuZ2UtcGlja2VyLXRvLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0wsdUJBQXVCLEVBQ3ZCLFNBQVMsRUFDVCxLQUFLLEdBQ04sTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRTNDLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFDN0MsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLFVBQVUsQ0FBQztBQUVwQyxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0scURBQXFELENBQUM7QUFFckYsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0seUNBQXlDLENBQUM7QUFDaEYsT0FBTyxFQUFFLHNCQUFzQixFQUFFLE1BQU0sbUNBQW1DLENBQUM7Ozs7QUFRM0UsTUFBTSxPQUFPLDJCQUE0QixTQUFRLHNCQUFzQjtJQUx2RTs7UUFlUyxTQUFJLEdBQUcsY0FBYyxDQUFDLFVBQVUsQ0FBQztRQUVoQyxxQkFBZ0IsR0FBRyxLQUFLLENBQUM7S0EyRGxDO0lBckVDLElBQWEsY0FBYyxDQUFDLEtBQUs7UUFDL0IsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7SUFDckIsQ0FBQztJQUVELElBQWEsb0JBQW9CLENBQUMsS0FBSztRQUNyQyxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztJQUNyQixDQUFDO0lBTU0sV0FBVyxDQUFDLEtBQVc7UUFDNUIsSUFBSSxLQUFLLEVBQUU7WUFDVCxLQUFLLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQ3pCO1FBRUQsSUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUM7UUFDcEIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFOUIsSUFBSSxLQUFLLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUMxQixLQUFLLEdBQUcsY0FBYyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7U0FDOUM7UUFFRCxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3JCLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDdEIsQ0FBQztJQUVTLFVBQVUsQ0FBQyxVQUF1QjtRQUMxQyxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDO1FBRTdCLEtBQUssQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDL0IsQ0FBQztJQUVTLGlCQUFpQixDQUFDLElBQWlCO1FBQzNDLElBQUksR0FBRyxLQUFLLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFckMsSUFBSSxJQUFJLEVBQUU7WUFDUixJQUFJLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ3ZCO1FBRUQsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQ7O09BRUc7SUFDTyx5QkFBeUI7UUFDakMsT0FBTztJQUNULENBQUM7SUFFUyw0QkFBNEI7UUFDcEMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDO2FBQzlDLElBQUksQ0FDSCxTQUFTLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUMxQjthQUNBLFNBQVMsQ0FBQyxDQUFDLFFBQXFCLEVBQUUsRUFBRTtZQUNuQyxJQUFJLElBQUksQ0FBQyxnQkFBZ0IsRUFBRTtnQkFDekIsSUFBSSxDQUFDLGdCQUFnQixHQUFHLEtBQUssQ0FBQztnQkFDOUIsT0FBTzthQUNSO1lBRUQsSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUUzQixJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxXQUFXLEVBQUUsQ0FBQztZQUN0QyxJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxzQkFBc0IsRUFBRSxDQUFDO1lBQ2pELElBQUksQ0FBQyxNQUFNLENBQUMsWUFBWSxFQUFFLENBQUM7UUFDN0IsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDOzt5SEF0RVUsMkJBQTJCOzZHQUEzQiwyQkFBMkI7NEZBQTNCLDJCQUEyQjtrQkFMdkMsU0FBUzttQkFBQztvQkFDVCxRQUFRLEVBQUUseUNBQXlDO29CQUNuRCxRQUFRLEVBQUUscUJBQXFCLENBQUMsUUFBUTtvQkFDeEMsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07aUJBQ2hEOzhCQUdjLGNBQWM7c0JBQTFCLEtBQUs7Z0JBSU8sb0JBQW9CO3NCQUFoQyxLQUFLIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENvbXBvbmVudCxcbiAgSW5wdXQsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7IHpvbmVkVGltZVRvVXRjIH0gZnJvbSAnZGF0ZS1mbnMtdHonO1xuaW1wb3J0IHsgZW5kT2ZEYXkgfSBmcm9tICdkYXRlLWZucyc7XG5cbmltcG9ydCB7IFBpY2tlclZpZXdUeXBlIH0gZnJvbSAnLi4vLi4vLi4vLi4vbGlicy9jb21tb24vZW51bXMvcGlja2VyLXZpZXctdHlwZS5lbnVtJztcblxuaW1wb3J0IHsgRnNEYXRlUGlja2VyQ29tcG9uZW50IH0gZnJvbSAnLi4vLi4vZGF0ZS1waWNrZXIvZGF0ZS1waWNrZXIuY29tcG9uZW50JztcbmltcG9ydCB7IFJhbmdlUGlja2VyVG9Db21wb25lbnQgfSBmcm9tICcuLi9iYXNlL3JhbmdlLXBpY2tlci10by5jb21wb25lbnQnO1xuXG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ1tmc01vbnRoUmFuZ2VUb10sW2ZzTW9udGhSYW5nZVRvUGlja2VyXScsXG4gIHRlbXBsYXRlOiBGc0RhdGVQaWNrZXJDb21wb25lbnQudGVtcGxhdGUsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxufSlcbmV4cG9ydCBjbGFzcyBNb250aFJhbmdlUGlja2VyVG9Db21wb25lbnQgZXh0ZW5kcyBSYW5nZVBpY2tlclRvQ29tcG9uZW50IHtcblxuICBASW5wdXQoKSBzZXQgZnNNb250aFJhbmdlVG8odmFsdWUpIHtcbiAgICB0aGlzLl9uYW1lID0gdmFsdWU7XG4gIH1cblxuICBASW5wdXQoKSBzZXQgZnNNb250aFJhbmdlVG9QaWNrZXIodmFsdWUpIHtcbiAgICB0aGlzLl9uYW1lID0gdmFsdWU7XG4gIH1cblxuICBwdWJsaWMgdmlldyA9IFBpY2tlclZpZXdUeXBlLk1vbnRoUmFuZ2U7XG5cbiAgcHJpdmF0ZSBfc2tpcFVwZGF0ZVZhbHVlID0gZmFsc2U7XG5cbiAgcHVibGljIHVwZGF0ZVZhbHVlKHZhbHVlOiBEYXRlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB2YWx1ZSA9IGVuZE9mRGF5KHZhbHVlKTtcbiAgICB9XG5cbiAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMudXBkYXRlSW5wdXQodGhpcy5fdmFsdWUpO1xuXG4gICAgaWYgKHZhbHVlICYmIHRoaXMudGltZXpvbmUpIHtcbiAgICAgIHZhbHVlID0gem9uZWRUaW1lVG9VdGModmFsdWUsIHRoaXMudGltZXpvbmUpO1xuICAgIH1cblxuICAgIHRoaXMub25DaGFuZ2UodmFsdWUpO1xuICAgIHRoaXMub25Ub3VjaCh2YWx1ZSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX3R6Q2hhbmdlZChvcmlnaW5EYXRlOiBEYXRlIHwgbnVsbCkge1xuICAgIHRoaXMuX3NraXBVcGRhdGVWYWx1ZSA9IHRydWU7XG5cbiAgICBzdXBlci5fdHpDaGFuZ2VkKG9yaWdpbkRhdGUpO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9wcm9jZXNzSW5wdXREYXRlKGRhdGU6IERhdGUgfCBudWxsKTogRGF0ZSB8IG51bGwge1xuICAgIGRhdGUgPSBzdXBlci5fcHJvY2Vzc0lucHV0RGF0ZShkYXRlKTtcblxuICAgIGlmIChkYXRlKSB7XG4gICAgICBkYXRlID0gZW5kT2ZEYXkoZGF0ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGU7XG4gIH1cblxuICAvKipcbiAgICogV2hlbiBpdCdzIG1vbnRoIHJhbmdlIHBpY2tlciAtIHdlIGhhdmUgdG8gbGlzdGVuIGNoYW5nZXMgb3ZlciByYW5nZVBpY2tlclJlZlxuICAgKi9cbiAgcHJvdGVjdGVkIF9saXN0ZW5EaWFsb2dWYWx1ZUNoYW5nZXMoKSB7XG4gICAgLy8gTk9PUFxuICB9XG5cbiAgcHJvdGVjdGVkIF9zdWJzY3JpYmVUb1BpY2tlclJlZlVwZGF0ZXMoKSB7XG4gICAgdGhpcy5fcGlja2VyUmVmVXBkYXRlcyQodGhpcy5fcGlja2VyUmVmLmVuZERhdGUkKVxuICAgICAgLnBpcGUoXG4gICAgICAgIHRha2VVbnRpbCh0aGlzLl9kZXN0cm95JCksXG4gICAgICApXG4gICAgICAuc3Vic2NyaWJlKChuZXdWYWx1ZTogRGF0ZSB8IG51bGwpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX3NraXBVcGRhdGVWYWx1ZSkge1xuICAgICAgICAgIHRoaXMuX3NraXBVcGRhdGVWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlVmFsdWUobmV3VmFsdWUpO1xuXG4gICAgICAgIHRoaXMuX25nQ29udHJvbC5jb250cm9sLm1hcmtBc0RpcnR5KCk7XG4gICAgICAgIHRoaXMuX25nQ29udHJvbC5jb250cm9sLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKTtcbiAgICAgICAgdGhpcy5fY2RSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgICB9KTtcbiAgfVxufVxuIl19