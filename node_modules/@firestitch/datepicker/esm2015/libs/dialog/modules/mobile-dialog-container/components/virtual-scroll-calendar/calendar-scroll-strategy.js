import { Subject } from 'rxjs';
import { distinctUntilChanged } from 'rxjs/operators';
import { getYearsCycle, reduceCycle } from './helpers';
import { Injectable } from "@angular/core";
import * as i0 from "@angular/core";
export const YEARS_TO_BE_RENDERED = 200;
export const START_CYCLE_YEAR = 1900;
const RENDER_BUFFER = 500;
// height of month label and week days line
const MONTH_LABEL_HEIGHT = 78;
// height of week row
const WEEK_HEIGHT = 50;
/**
 * Implementation has been taken from Alex Inkin article, adopted and modified a bit
 * https://indepth.dev/posts/1091/writing-custom-virtual-scroll-strategy
 */
export class CalendarScrollStrategy {
    constructor() {
        this._index$ = new Subject();
        this.scrolledIndexChange = this._index$.pipe(distinctUntilChanged());
        this._viewport = null;
        this._firstTimeRender = true;
        this.yearsCycle = getYearsCycle(MONTH_LABEL_HEIGHT, WEEK_HEIGHT, START_CYCLE_YEAR);
        // Total height of 28 years cycle
        this.yearsCycleHeight = reduceCycle(this.yearsCycle);
    }
    attach(viewport) {
        this._viewport = viewport;
        // Here is "7" is number of "cycles" in years range
        // We are rendering 200 years from 1900 to 2100
        // Year calendar repeat itself every 28 years
        // 200 / 28 = 7.14
        this._viewport.setTotalContentSize(this.yearsCycleHeight * 7);
    }
    detach() {
        this._index$.complete();
        this._viewport = null;
    }
    onContentScrolled() {
        if (this._viewport) {
            this._updateRenderedRange();
        }
    }
    onDataLengthChanged() { }
    onContentRendered() { }
    onRenderedOffsetChanged() { }
    /**
     * Initial Date for render can be set on initialization step to reduce calculations
     */
    setInitialDate(date) {
        this._initialDate = date;
    }
    /**
     * Does scroll to month with provided index
     */
    scrollToIndex(index, behavior) {
        if (this._viewport) {
            this._viewport.scrollToOffset(this._getOffsetForIndex(index), behavior);
        }
    }
    /**
     * Does the same thing as scrollToIndex(), but for date
     */
    scrollToDate(date, behavior) {
        if (this._viewport) {
            this._viewport.scrollToOffset(this._getOffsetForDate(date), behavior);
        }
    }
    /**
     * Update the viewport's rendered range.
     */
    _updateRenderedRange() {
        if (!this._viewport) {
            return;
        }
        // This is for support setInitialDate() method.
        // Should be called only once at first render
        if (this._firstTimeRender) {
            if (this._initialDate) {
                this.scrollToDate(this._initialDate);
            }
            this._firstTimeRender = false;
        }
        const currentScrollOffset = this._viewport.measureScrollOffset();
        const { start: currentStart, end: currentEnd } = this._viewport.getRenderedRange();
        const viewportSize = this._viewport.getViewportSize();
        const dataLength = this._viewport.getDataLength();
        const firstVisibleIndex = this._getIndexForOffset(currentScrollOffset);
        // Usually we are rendering a bit more months than available in view port
        // It works when user scrolls fast, so we have a bit time to render new months while will scroll over "buffer"
        // So this is why rendered top offset is different from current scroll offset
        const topScrollBuffer = currentScrollOffset - this._getOffsetForIndex(currentStart);
        let newStart = currentStart;
        let newEnd = currentEnd;
        if (topScrollBuffer < RENDER_BUFFER && currentStart !== 0) {
            // Here we have multiplication by 2 because we want to double our render buffer
            newStart = Math.max(0, this._getIndexForOffset(currentScrollOffset - RENDER_BUFFER * 2));
            newEnd = Math.min(dataLength, this._getIndexForOffset(currentScrollOffset + viewportSize + RENDER_BUFFER));
        }
        else {
            const bottomScrollBuffer = this._getOffsetForIndex(currentEnd) - currentScrollOffset - viewportSize;
            if (bottomScrollBuffer < RENDER_BUFFER && currentEnd !== dataLength) {
                newStart = Math.max(0, this._getIndexForOffset(currentScrollOffset - RENDER_BUFFER));
                newEnd = Math.min(dataLength, 
                // Here we have multiplication by 2 because we want to double our render buffer
                this._getIndexForOffset(currentScrollOffset + viewportSize + RENDER_BUFFER * 2));
            }
        }
        this._viewport.setRenderedRange({ start: newStart, end: newEnd });
        this._viewport.setRenderedContentOffset(this._getOffsetForIndex(newStart));
        this._index$.next(firstVisibleIndex);
    }
    _getOffsetForIndex(index) {
        const month = index % 12;
        const year = (index - month) / 12;
        return this._computeHeight(year, month);
    }
    _getIndexForOffset(offset) {
        // the remaining number of pixels that cannot make up a complete cycle
        const remainder = offset % this.yearsCycleHeight;
        const numberOfFullCycles = (offset - remainder) / this.yearsCycleHeight;
        const years = numberOfFullCycles * 28; // years from START_CYCLE_YEAR to current offset
        let heightAccumulator = 0;
        // Cycle through every year and month in 28 year cycle
        for (let year = 0; year < this.yearsCycle.length; year++) {
            for (let month = 0; month < this.yearsCycle[year].length; month++) {
                heightAccumulator += this.yearsCycle[year][month];
                if (heightAccumulator - this.yearsCycle[year][month] / 2 > remainder) {
                    return Math.max((years + year) * 12 + month, 0);
                }
            }
        }
        return YEARS_TO_BE_RENDERED;
    }
    _getOffsetForDate(date) {
        if (!date) {
            return 0;
        }
        const year = date.getFullYear();
        const month = date.getMonth();
        const index = (year - START_CYCLE_YEAR) * 12 + month;
        return this._getOffsetForIndex(index);
    }
    // Compute height for given year and month, but year starts from 0 to YEARS_TO_BE_RENDERED
    _computeHeight(year, month) {
        const remainder = year % 28; // number of year in cycle of 28 repeated years
        const remainderHeight = reduceCycle(this.yearsCycle, remainder, month);
        const fullCycles = (year - remainder) / 28;
        const fullCyclesHeight = fullCycles * this.yearsCycleHeight;
        return fullCyclesHeight + remainderHeight;
    }
}
CalendarScrollStrategy.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: CalendarScrollStrategy, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
CalendarScrollStrategy.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: CalendarScrollStrategy });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: CalendarScrollStrategy, decorators: [{
            type: Injectable
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FsZW5kYXItc2Nyb2xsLXN0cmF0ZWd5LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vc3JjL2xpYnMvZGlhbG9nL21vZHVsZXMvbW9iaWxlLWRpYWxvZy1jb250YWluZXIvY29tcG9uZW50cy92aXJ0dWFsLXNjcm9sbC1jYWxlbmRhci9jYWxlbmRhci1zY3JvbGwtc3RyYXRlZ3kudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBRUEsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUMvQixPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUV0RCxPQUFPLEVBQUUsYUFBYSxFQUFFLFdBQVcsRUFBRSxNQUFNLFdBQVcsQ0FBQztBQUN2RCxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDOztBQUUzQyxNQUFNLENBQUMsTUFBTSxvQkFBb0IsR0FBRyxHQUFHLENBQUM7QUFDeEMsTUFBTSxDQUFDLE1BQU0sZ0JBQWdCLEdBQUcsSUFBSSxDQUFDO0FBRXJDLE1BQU0sYUFBYSxHQUFHLEdBQUcsQ0FBQztBQUUxQiwyQ0FBMkM7QUFDM0MsTUFBTSxrQkFBa0IsR0FBRyxFQUFFLENBQUM7QUFDOUIscUJBQXFCO0FBQ3JCLE1BQU0sV0FBVyxHQUFHLEVBQUUsQ0FBQztBQVF2Qjs7O0dBR0c7QUFFSCxNQUFNLE9BQU8sc0JBQXNCO0lBRG5DO1FBR21CLFlBQU8sR0FBRyxJQUFJLE9BQU8sRUFBVSxDQUFDO1FBRWpDLHdCQUFtQixHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLG9CQUFvQixFQUFFLENBQUMsQ0FBQztRQUV4RSxjQUFTLEdBQW9DLElBQUksQ0FBQztRQUVsRCxxQkFBZ0IsR0FBRyxJQUFJLENBQUM7UUFFZixlQUFVLEdBQUcsYUFBYSxDQUFDLGtCQUFrQixFQUFFLFdBQVcsRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDO1FBQy9GLGlDQUFp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QixDQUFDLElBQVU7UUFDbEMsSUFBSSxDQUFDLElBQUksRUFBRTtZQUNULE9BQU8sQ0FBQyxDQUFDO1NBQ1Y7UUFFRCxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7UUFDaEMsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQzlCLE1BQU0sS0FBSyxHQUFHLENBQUMsSUFBSSxHQUFHLGdCQUFnQixDQUFDLEdBQUcsRUFBRSxHQUFHLEtBQUssQ0FBQztRQUVyRCxPQUFPLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN4QyxDQUFDO0lBRUQsMEZBQTBGO0lBQ2xGLGNBQWMsQ0FBQyxJQUFZLEVBQUUsS0FBYztRQUNqRCxNQUFNLFNBQVMsR0FBRyxJQUFJLEdBQUcsRUFBRSxDQUFDLENBQUMsK0NBQStDO1FBQzVFLE1BQU0sZUFBZSxHQUFHLFdBQVcsQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLFNBQVMsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUN2RSxNQUFNLFVBQVUsR0FBRyxDQUFDLElBQUksR0FBRyxTQUFTLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDM0MsTUFBTSxnQkFBZ0IsR0FBRyxVQUFVLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDO1FBRTVELE9BQU8sZ0JBQWdCLEdBQUcsZUFBZSxDQUFDO0lBQzVDLENBQUM7O29IQTVLVSxzQkFBc0I7d0hBQXRCLHNCQUFzQjs0RkFBdEIsc0JBQXNCO2tCQURsQyxVQUFVIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2RrVmlydHVhbFNjcm9sbFZpZXdwb3J0LCBWaXJ0dWFsU2Nyb2xsU3RyYXRlZ3kgfSBmcm9tICdAYW5ndWxhci9jZGsvc2Nyb2xsaW5nJztcblxuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZGlzdGluY3RVbnRpbENoYW5nZWQgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7IGdldFllYXJzQ3ljbGUsIHJlZHVjZUN5Y2xlIH0gZnJvbSAnLi9oZWxwZXJzJztcbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuXG5leHBvcnQgY29uc3QgWUVBUlNfVE9fQkVfUkVOREVSRUQgPSAyMDA7XG5leHBvcnQgY29uc3QgU1RBUlRfQ1lDTEVfWUVBUiA9IDE5MDA7XG5cbmNvbnN0IFJFTkRFUl9CVUZGRVIgPSA1MDA7XG5cbi8vIGhlaWdodCBvZiBtb250aCBsYWJlbCBhbmQgd2VlayBkYXlzIGxpbmVcbmNvbnN0IE1PTlRIX0xBQkVMX0hFSUdIVCA9IDc4O1xuLy8gaGVpZ2h0IG9mIHdlZWsgcm93XG5jb25zdCBXRUVLX0hFSUdIVCA9IDUwO1xuXG5leHBvcnQgaW50ZXJmYWNlIEZzQ2FsZW5kYXJNb2JpbGVTY3JvbGxTdHJhdGVneSBleHRlbmRzIFZpcnR1YWxTY3JvbGxTdHJhdGVneSB7XG4gIHNldEluaXRpYWxEYXRlKGRhdGU6IERhdGUpOiB2b2lkO1xuICBzY3JvbGxUb0RhdGUoZGF0ZTogRGF0ZSwgYmVoYXZpb3I/OiBTY3JvbGxCZWhhdmlvcik6IHZvaWQ7XG59XG5cblxuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBoYXMgYmVlbiB0YWtlbiBmcm9tIEFsZXggSW5raW4gYXJ0aWNsZSwgYWRvcHRlZCBhbmQgbW9kaWZpZWQgYSBiaXRcbiAqIGh0dHBzOi8vaW5kZXB0aC5kZXYvcG9zdHMvMTA5MS93cml0aW5nLWN1c3RvbS12aXJ0dWFsLXNjcm9sbC1zdHJhdGVneVxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgQ2FsZW5kYXJTY3JvbGxTdHJhdGVneSBpbXBsZW1lbnRzIEZzQ2FsZW5kYXJNb2JpbGVTY3JvbGxTdHJhdGVneSB7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBfaW5kZXgkID0gbmV3IFN1YmplY3Q8bnVtYmVyPigpO1xuXG4gIHB1YmxpYyByZWFkb25seSBzY3JvbGxlZEluZGV4Q2hhbmdlID0gdGhpcy5faW5kZXgkLnBpcGUoZGlzdGluY3RVbnRpbENoYW5nZWQoKSk7XG5cbiAgcHJpdmF0ZSBfdmlld3BvcnQ6IENka1ZpcnR1YWxTY3JvbGxWaWV3cG9ydCB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIF9pbml0aWFsRGF0ZTogRGF0ZTtcbiAgcHJpdmF0ZSBfZmlyc3RUaW1lUmVuZGVyID0gdHJ1ZTtcblxuICBwcml2YXRlIHJlYWRvbmx5IHllYXJzQ3ljbGUgPSBnZXRZZWFyc0N5Y2xlKE1PTlRIX0xBQkVMX0hFSUdIVCwgV0VFS19IRUlHSFQsIFNUQVJUX0NZQ0xFX1lFQVIpO1xuICAvLyBUb3RhbCBoZWlnaHQgb2YgMjggeWVhcnMgY3ljbGVcbiAgcHJpdmF0ZSByZWFkb25seSB5ZWFyc0N5Y2xlSGVpZ2h0ID0gcmVkdWNlQ3ljbGUodGhpcy55ZWFyc0N5Y2xlKTtcblxuICBwdWJsaWMgYXR0YWNoKHZpZXdwb3J0OiBDZGtWaXJ0dWFsU2Nyb2xsVmlld3BvcnQpOiB2b2lkIHtcbiAgICB0aGlzLl92aWV3cG9ydCA9IHZpZXdwb3J0O1xuXG4gICAgLy8gSGVyZSBpcyBcIjdcIiBpcyBudW1iZXIgb2YgXCJjeWNsZXNcIiBpbiB5ZWFycyByYW5nZVxuICAgIC8vIFdlIGFyZSByZW5kZXJpbmcgMjAwIHllYXJzIGZyb20gMTkwMCB0byAyMTAwXG4gICAgLy8gWWVhciBjYWxlbmRhciByZXBlYXQgaXRzZWxmIGV2ZXJ5IDI4IHllYXJzXG4gICAgLy8gMjAwIC8gMjggPSA3LjE0XG4gICAgdGhpcy5fdmlld3BvcnQuc2V0VG90YWxDb250ZW50U2l6ZSh0aGlzLnllYXJzQ3ljbGVIZWlnaHQgKiA3KTtcbiAgfVxuXG4gIHB1YmxpYyBkZXRhY2goKTogdm9pZCB7XG4gICAgdGhpcy5faW5kZXgkLmNvbXBsZXRlKCk7XG4gICAgdGhpcy5fdmlld3BvcnQgPSBudWxsO1xuICB9XG5cbiAgcHVibGljIG9uQ29udGVudFNjcm9sbGVkKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLl92aWV3cG9ydCkge1xuICAgICAgdGhpcy5fdXBkYXRlUmVuZGVyZWRSYW5nZSgpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBvbkRhdGFMZW5ndGhDaGFuZ2VkKCk6IHZvaWQge31cbiAgcHVibGljIG9uQ29udGVudFJlbmRlcmVkKCk6IHZvaWQge31cbiAgcHVibGljIG9uUmVuZGVyZWRPZmZzZXRDaGFuZ2VkKCk6IHZvaWQge31cblxuICAvKipcbiAgICogSW5pdGlhbCBEYXRlIGZvciByZW5kZXIgY2FuIGJlIHNldCBvbiBpbml0aWFsaXphdGlvbiBzdGVwIHRvIHJlZHVjZSBjYWxjdWxhdGlvbnNcbiAgICovXG4gIHB1YmxpYyBzZXRJbml0aWFsRGF0ZShkYXRlOiBEYXRlKTogdm9pZCB7XG4gICAgdGhpcy5faW5pdGlhbERhdGUgPSBkYXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIERvZXMgc2Nyb2xsIHRvIG1vbnRoIHdpdGggcHJvdmlkZWQgaW5kZXhcbiAgICovXG4gIHB1YmxpYyBzY3JvbGxUb0luZGV4KGluZGV4OiBudW1iZXIsIGJlaGF2aW9yOiBTY3JvbGxCZWhhdmlvcik6IHZvaWQge1xuICAgIGlmICh0aGlzLl92aWV3cG9ydCkge1xuICAgICAgdGhpcy5fdmlld3BvcnQuc2Nyb2xsVG9PZmZzZXQodGhpcy5fZ2V0T2Zmc2V0Rm9ySW5kZXgoaW5kZXgpLCBiZWhhdmlvcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERvZXMgdGhlIHNhbWUgdGhpbmcgYXMgc2Nyb2xsVG9JbmRleCgpLCBidXQgZm9yIGRhdGVcbiAgICovXG4gIHB1YmxpYyBzY3JvbGxUb0RhdGUoZGF0ZTogRGF0ZSwgYmVoYXZpb3I/OiBTY3JvbGxCZWhhdmlvcik6IHZvaWQge1xuICAgIGlmICh0aGlzLl92aWV3cG9ydCkge1xuICAgICAgdGhpcy5fdmlld3BvcnQuc2Nyb2xsVG9PZmZzZXQodGhpcy5fZ2V0T2Zmc2V0Rm9yRGF0ZShkYXRlKSwgYmVoYXZpb3IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHZpZXdwb3J0J3MgcmVuZGVyZWQgcmFuZ2UuXG4gICAqL1xuICBwcml2YXRlIF91cGRhdGVSZW5kZXJlZFJhbmdlKCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5fdmlld3BvcnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGlzIGZvciBzdXBwb3J0IHNldEluaXRpYWxEYXRlKCkgbWV0aG9kLlxuICAgIC8vIFNob3VsZCBiZSBjYWxsZWQgb25seSBvbmNlIGF0IGZpcnN0IHJlbmRlclxuICAgIGlmICh0aGlzLl9maXJzdFRpbWVSZW5kZXIpIHtcbiAgICAgIGlmICh0aGlzLl9pbml0aWFsRGF0ZSkge1xuICAgICAgICB0aGlzLnNjcm9sbFRvRGF0ZSh0aGlzLl9pbml0aWFsRGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2ZpcnN0VGltZVJlbmRlciA9IGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGN1cnJlbnRTY3JvbGxPZmZzZXQgPSB0aGlzLl92aWV3cG9ydC5tZWFzdXJlU2Nyb2xsT2Zmc2V0KCk7XG4gICAgY29uc3QgeyBzdGFydDogY3VycmVudFN0YXJ0LCBlbmQ6IGN1cnJlbnRFbmQgfSA9IHRoaXMuX3ZpZXdwb3J0LmdldFJlbmRlcmVkUmFuZ2UoKTtcbiAgICBjb25zdCB2aWV3cG9ydFNpemUgPSB0aGlzLl92aWV3cG9ydC5nZXRWaWV3cG9ydFNpemUoKTtcbiAgICBjb25zdCBkYXRhTGVuZ3RoID0gdGhpcy5fdmlld3BvcnQuZ2V0RGF0YUxlbmd0aCgpO1xuICAgIGNvbnN0IGZpcnN0VmlzaWJsZUluZGV4ID0gdGhpcy5fZ2V0SW5kZXhGb3JPZmZzZXQoY3VycmVudFNjcm9sbE9mZnNldCk7XG5cbiAgICAvLyBVc3VhbGx5IHdlIGFyZSByZW5kZXJpbmcgYSBiaXQgbW9yZSBtb250aHMgdGhhbiBhdmFpbGFibGUgaW4gdmlldyBwb3J0XG4gICAgLy8gSXQgd29ya3Mgd2hlbiB1c2VyIHNjcm9sbHMgZmFzdCwgc28gd2UgaGF2ZSBhIGJpdCB0aW1lIHRvIHJlbmRlciBuZXcgbW9udGhzIHdoaWxlIHdpbGwgc2Nyb2xsIG92ZXIgXCJidWZmZXJcIlxuICAgIC8vIFNvIHRoaXMgaXMgd2h5IHJlbmRlcmVkIHRvcCBvZmZzZXQgaXMgZGlmZmVyZW50IGZyb20gY3VycmVudCBzY3JvbGwgb2Zmc2V0XG4gICAgY29uc3QgdG9wU2Nyb2xsQnVmZmVyID0gY3VycmVudFNjcm9sbE9mZnNldCAtIHRoaXMuX2dldE9mZnNldEZvckluZGV4KGN1cnJlbnRTdGFydClcblxuICAgIGxldCBuZXdTdGFydCA9IGN1cnJlbnRTdGFydDtcbiAgICBsZXQgbmV3RW5kID0gY3VycmVudEVuZDtcblxuICAgIGlmICh0b3BTY3JvbGxCdWZmZXIgPCBSRU5ERVJfQlVGRkVSICYmIGN1cnJlbnRTdGFydCAhPT0gMCkge1xuICAgICAgLy8gSGVyZSB3ZSBoYXZlIG11bHRpcGxpY2F0aW9uIGJ5IDIgYmVjYXVzZSB3ZSB3YW50IHRvIGRvdWJsZSBvdXIgcmVuZGVyIGJ1ZmZlclxuICAgICAgbmV3U3RhcnQgPSBNYXRoLm1heCgwLCB0aGlzLl9nZXRJbmRleEZvck9mZnNldChjdXJyZW50U2Nyb2xsT2Zmc2V0IC0gUkVOREVSX0JVRkZFUiAqIDIpKVxuICAgICAgbmV3RW5kID0gTWF0aC5taW4oXG4gICAgICAgIGRhdGFMZW5ndGgsXG4gICAgICAgIHRoaXMuX2dldEluZGV4Rm9yT2Zmc2V0KGN1cnJlbnRTY3JvbGxPZmZzZXQgKyB2aWV3cG9ydFNpemUgKyBSRU5ERVJfQlVGRkVSKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYm90dG9tU2Nyb2xsQnVmZmVyID0gdGhpcy5fZ2V0T2Zmc2V0Rm9ySW5kZXgoY3VycmVudEVuZCkgLSBjdXJyZW50U2Nyb2xsT2Zmc2V0IC0gdmlld3BvcnRTaXplO1xuXG4gICAgICBpZiAoYm90dG9tU2Nyb2xsQnVmZmVyIDwgUkVOREVSX0JVRkZFUiAmJiBjdXJyZW50RW5kICE9PSBkYXRhTGVuZ3RoKSB7XG4gICAgICAgIG5ld1N0YXJ0ID0gTWF0aC5tYXgoMCwgdGhpcy5fZ2V0SW5kZXhGb3JPZmZzZXQoY3VycmVudFNjcm9sbE9mZnNldCAtIFJFTkRFUl9CVUZGRVIpKTtcblxuICAgICAgICBuZXdFbmQgPSBNYXRoLm1pbihcbiAgICAgICAgICBkYXRhTGVuZ3RoLFxuICAgICAgICAgIC8vIEhlcmUgd2UgaGF2ZSBtdWx0aXBsaWNhdGlvbiBieSAyIGJlY2F1c2Ugd2Ugd2FudCB0byBkb3VibGUgb3VyIHJlbmRlciBidWZmZXJcbiAgICAgICAgICB0aGlzLl9nZXRJbmRleEZvck9mZnNldChjdXJyZW50U2Nyb2xsT2Zmc2V0ICsgdmlld3BvcnRTaXplICsgUkVOREVSX0JVRkZFUiAqIDIpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fdmlld3BvcnQuc2V0UmVuZGVyZWRSYW5nZSh7IHN0YXJ0OiBuZXdTdGFydCwgZW5kOiBuZXdFbmQgfSk7XG4gICAgdGhpcy5fdmlld3BvcnQuc2V0UmVuZGVyZWRDb250ZW50T2Zmc2V0KHRoaXMuX2dldE9mZnNldEZvckluZGV4KG5ld1N0YXJ0KSk7XG5cbiAgICB0aGlzLl9pbmRleCQubmV4dChmaXJzdFZpc2libGVJbmRleCk7XG4gIH1cblxuICBwcml2YXRlIF9nZXRPZmZzZXRGb3JJbmRleChpbmRleDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBjb25zdCBtb250aCA9IGluZGV4ICUgMTI7XG4gICAgY29uc3QgeWVhciA9IChpbmRleCAtIG1vbnRoKSAvIDEyO1xuXG4gICAgcmV0dXJuIHRoaXMuX2NvbXB1dGVIZWlnaHQoeWVhciwgbW9udGgpO1xuICB9XG5cbiAgcHJpdmF0ZSBfZ2V0SW5kZXhGb3JPZmZzZXQob2Zmc2V0OiBudW1iZXIpOiBudW1iZXIge1xuICAgIC8vIHRoZSByZW1haW5pbmcgbnVtYmVyIG9mIHBpeGVscyB0aGF0IGNhbm5vdCBtYWtlIHVwIGEgY29tcGxldGUgY3ljbGVcbiAgICBjb25zdCByZW1haW5kZXIgPSBvZmZzZXQgJSB0aGlzLnllYXJzQ3ljbGVIZWlnaHQ7XG4gICAgY29uc3QgbnVtYmVyT2ZGdWxsQ3ljbGVzICA9IChvZmZzZXQgLSByZW1haW5kZXIpIC8gdGhpcy55ZWFyc0N5Y2xlSGVpZ2h0O1xuICAgIGNvbnN0IHllYXJzID0gbnVtYmVyT2ZGdWxsQ3ljbGVzICogMjg7IC8vIHllYXJzIGZyb20gU1RBUlRfQ1lDTEVfWUVBUiB0byBjdXJyZW50IG9mZnNldFxuXG4gICAgbGV0IGhlaWdodEFjY3VtdWxhdG9yID0gMDtcblxuICAgIC8vIEN5Y2xlIHRocm91Z2ggZXZlcnkgeWVhciBhbmQgbW9udGggaW4gMjggeWVhciBjeWNsZVxuICAgIGZvciAobGV0IHllYXIgPSAwOyB5ZWFyIDwgdGhpcy55ZWFyc0N5Y2xlLmxlbmd0aDsgeWVhcisrKSB7XG4gICAgICBmb3IgKGxldCBtb250aCA9IDA7IG1vbnRoIDwgdGhpcy55ZWFyc0N5Y2xlW3llYXJdLmxlbmd0aDsgbW9udGgrKykge1xuICAgICAgICBoZWlnaHRBY2N1bXVsYXRvciArPSB0aGlzLnllYXJzQ3ljbGVbeWVhcl1bbW9udGhdO1xuXG4gICAgICAgIGlmIChoZWlnaHRBY2N1bXVsYXRvciAtIHRoaXMueWVhcnNDeWNsZVt5ZWFyXVttb250aF0gLyAyID4gcmVtYWluZGVyKSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGgubWF4KCh5ZWFycyArIHllYXIpICogMTIgKyBtb250aCwgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gWUVBUlNfVE9fQkVfUkVOREVSRUQ7XG4gIH1cblxuICBwcml2YXRlIF9nZXRPZmZzZXRGb3JEYXRlKGRhdGU6IERhdGUpOiBudW1iZXIge1xuICAgIGlmICghZGF0ZSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgY29uc3QgeWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICBjb25zdCBtb250aCA9IGRhdGUuZ2V0TW9udGgoKTtcbiAgICBjb25zdCBpbmRleCA9ICh5ZWFyIC0gU1RBUlRfQ1lDTEVfWUVBUikgKiAxMiArIG1vbnRoO1xuXG4gICAgcmV0dXJuIHRoaXMuX2dldE9mZnNldEZvckluZGV4KGluZGV4KTtcbiAgfVxuXG4gIC8vIENvbXB1dGUgaGVpZ2h0IGZvciBnaXZlbiB5ZWFyIGFuZCBtb250aCwgYnV0IHllYXIgc3RhcnRzIGZyb20gMCB0byBZRUFSU19UT19CRV9SRU5ERVJFRFxuICBwcml2YXRlIF9jb21wdXRlSGVpZ2h0KHllYXI6IG51bWJlciwgbW9udGg/OiBudW1iZXIpOiBudW1iZXIge1xuICAgIGNvbnN0IHJlbWFpbmRlciA9IHllYXIgJSAyODsgLy8gbnVtYmVyIG9mIHllYXIgaW4gY3ljbGUgb2YgMjggcmVwZWF0ZWQgeWVhcnNcbiAgICBjb25zdCByZW1haW5kZXJIZWlnaHQgPSByZWR1Y2VDeWNsZSh0aGlzLnllYXJzQ3ljbGUsIHJlbWFpbmRlciwgbW9udGgpO1xuICAgIGNvbnN0IGZ1bGxDeWNsZXMgPSAoeWVhciAtIHJlbWFpbmRlcikgLyAyODtcbiAgICBjb25zdCBmdWxsQ3ljbGVzSGVpZ2h0ID0gZnVsbEN5Y2xlcyAqIHRoaXMueWVhcnNDeWNsZUhlaWdodDtcblxuICAgIHJldHVybiBmdWxsQ3ljbGVzSGVpZ2h0ICsgcmVtYWluZGVySGVpZ2h0O1xuICB9XG59XG4iXX0=