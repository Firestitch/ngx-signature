import { ChangeDetectionStrategy, Component, ElementRef, Inject, Input, ViewChild, } from '@angular/core';
import { MatBottomSheetRef } from '@angular/material/bottom-sheet';
import { CdkVirtualScrollViewport, VIRTUAL_SCROLL_STRATEGY, } from '@angular/cdk/scrolling';
import { fromEvent, race, timer, Subject } from 'rxjs';
import { debounceTime, delay, filter, shareReplay, switchMap, take, takeUntil } from 'rxjs/operators';
import { isBefore } from 'date-fns';
import { FsCalendarDataSource } from './calendar-data-source';
import { FsDatePickerDialogModel } from '../../../../../dialog/classes/dialog-model';
import { CalendarScrollStrategy } from './calendar-scroll-strategy';
import { MatTabGroup } from '@angular/material/tabs';
import * as i0 from "@angular/core";
import * as i1 from "@angular/material/bottom-sheet";
import * as i2 from "../header/header.component";
import * as i3 from "../header-month-range/header-month-range.component";
import * as i4 from "@angular/cdk/scrolling";
import * as i5 from "../../../../../calendar/components/calendar/calendar.component";
import * as i6 from "@angular/common";
import * as i7 from "@firestitch/date";
export class FsDatePickerVirtualScrollCalendarComponent {
    constructor(_el, _bottomSheetRef, _scrollStrategy) {
        this._el = _el;
        this._bottomSheetRef = _bottomSheetRef;
        this._scrollStrategy = _scrollStrategy;
        this.autoClose = true;
        this.dataSource = new FsCalendarDataSource();
        this._destroy$ = new Subject();
    }
    get dialogRef() {
        return this._dialogRef;
    }
    get rangePickerRef() {
        return this.datePickerModel.rangePickerRef;
    }
    ngOnInit() {
        this._scrollStrategy.setInitialDate(this.datePickerModel.model || new Date());
        this._scrollToClosestMonth();
        if (this.parentTabGroup) {
            this._listenTabIndexChange();
        }
    }
    ngOnChanges(changes) {
        var _a, _b;
        if (((_a = changes.datePickerModel) === null || _a === void 0 ? void 0 : _a.currentValue)
            && ((_b = changes.datePickerModel) === null || _b === void 0 ? void 0 : _b.firstChange)
            && this.datePickerModel.view === 'monthrange') {
            this._initMonthRangeModels();
        }
    }
    ngOnDestroy() {
        this._destroy$.next();
        this._destroy$.complete();
    }
    dateChanged(date) {
        if (this.datePickerModel.view !== 'monthrange') {
            this.datePickerModel.model = date;
            this.close();
        }
        else {
            this.monthRangeChange(date);
        }
    }
    monthRangeChange(date) {
        const rangeRef = this.rangePickerRef;
        const { startDate, endDate } = rangeRef;
        if (!startDate && !endDate) {
            rangeRef.updateStartDate(date);
        }
        else if (startDate && !endDate) {
            if (isBefore(date, startDate)) {
                rangeRef.updateStartDate(date);
                rangeRef.updateEndDate(null);
            }
            else {
                rangeRef.updateEndDate(date);
            }
        }
        else if (startDate && endDate) {
            rangeRef.updateStartDate(date);
            rangeRef.updateEndDate(null);
        }
    }
    close() {
        if (this.autoClose) {
            this._bottomSheetRef.dismiss();
        }
    }
    scollIndexChange(activeIndex) {
        this._activeScrollIndex = activeIndex;
    }
    _scrollToClosestMonth() {
        const touchstart$ = fromEvent(this.virtualScroll.elementRef.nativeElement, 'touchstart');
        const touchend$ = fromEvent(this.virtualScroll.elementRef.nativeElement, 'touchend');
        const scrollDebounceTime = 80;
        touchstart$
            .pipe(switchMap(() => touchend$), switchMap(() => race(this.virtualScroll.elementScrolled(), timer(scrollDebounceTime)).pipe(debounceTime(scrollDebounceTime * 2), take(1), takeUntil(touchstart$))), takeUntil(this._destroy$))
            .subscribe(() => {
            this.virtualScroll.scrollToIndex(this._activeScrollIndex, 'smooth');
        });
    }
    _initMonthRangeModels() {
        this.modelFrom$ = this.datePickerModel
            .rangePickerRef
            .startDate$
            .pipe(shareReplay());
        this.modelTo$ = this.datePickerModel
            .rangePickerRef
            .endDate$
            .pipe(shareReplay());
    }
    _listenTabIndexChange() {
        this.parentTabGroup.selectedIndexChange
            .pipe(filter((index) => index === this.parentTabIndex), delay(0), takeUntil(this._destroy$))
            .subscribe(() => {
            this._scrollStrategy.scrollToDate(this.datePickerModel.model || new Date());
        });
    }
}
FsDatePickerVirtualScrollCalendarComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerVirtualScrollCalendarComponent, deps: [{ token: i0.ElementRef }, { token: i1.MatBottomSheetRef }, { token: VIRTUAL_SCROLL_STRATEGY }], target: i0.ɵɵFactoryTarget.Component });
FsDatePickerVirtualScrollCalendarComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: FsDatePickerVirtualScrollCalendarComponent, selector: "fs-datepicker-mobile-scroll-calendar", inputs: { datePickerModel: "datePickerModel", autoClose: "autoClose", parentTabGroup: "parentTabGroup", parentTabIndex: "parentTabIndex" }, providers: [
        {
            provide: VIRTUAL_SCROLL_STRATEGY,
            useClass: CalendarScrollStrategy,
        },
    ], viewQueries: [{ propertyName: "virtualScroll", first: true, predicate: CdkVirtualScrollViewport, descendants: true, static: true }], usesOnChanges: true, ngImport: i0, template: "<div class=\"header\">\n  <ng-container *ngIf=\"datePickerModel.view !== 'monthrange' else monthRangeHeader\">\n    <fs-date-picker-mobile-header\n      [calendarDate]=\"datePickerModel.model$ | async\"\n      [minYear]=\"datePickerModel.minYear\"\n      [maxYear]=\"datePickerModel.maxYear\"\n      [viewMode]=\"datePickerModel.calendarMode$ | async\"\n      [disabledDays]=\"datePickerModel.disabledDays$ | async\">\n    </fs-date-picker-mobile-header>\n  </ng-container>\n\n  <ng-template #monthRangeHeader>\n    <fs-date-picker-mobile-header-month-range\n      [rangeFrom]=\"modelFrom$ | async\"\n      [rangeTo]=\"modelTo$ | async\">\n    </fs-date-picker-mobile-header-month-range>\n  </ng-template>\n</div>\n\n<cdk-virtual-scroll-viewport class=\"view-port\" (scrolledIndexChange)=\"scollIndexChange($event)\">\n  <div *cdkVirtualFor=\"let item of dataSource\">\n    <div class=\"month-header\">\n      {{ item | fsDateFormat: 'full-date-dayless' }}\n    </div>\n    <fs-date-picker-calendar\n      [date]=\"datePickerModel.model$ | async\"\n      [drawMonth]=\"item\"\n      [rangeFrom]=\"modelFrom$ | async\"\n      [rangeTo]=\"modelTo$ | async\"\n      [highlightStartDate]=\"modelFrom$ | async\"\n      [highlightEndDate]=\"modelTo$ | async\"\n      [dateMode]=\"datePickerModel.calendarMode$ | async\"\n      [disabledDays]=\"datePickerModel.disabledDays$ | async\"\n      [hideExtraDays]=\"true\"\n      [period]=\"datePickerModel.period\"\n      [seedDate]=\"datePickerModel.seedDate\"\n      [periodWeeks]=\"datePickerModel.periodWeeks\"\n      (change)=\"dateChanged($event)\">\n    </fs-date-picker-calendar>\n  </div>\n</cdk-virtual-scroll-viewport>\n", styles: [".view-port{height:380px;overflow-y:auto}.month-header{text-align:center;line-height:50px;font-size:110%;font-weight:500}cdk-virtual-scroll-viewport::-webkit-scrollbar{width:0}\n"], components: [{ type: i2.FsDatePickerMobileHeaderComponent, selector: "fs-date-picker-mobile-header", inputs: ["viewMode", "minYear", "maxYear", "disabledDays", "calendarDate"], outputs: ["monthChange", "yearChange", "goNextMonth", "goPrevMonth", "viewModeChange"] }, { type: i3.FsDatePickerMobileHeaderMonthRangeComponent, selector: "fs-date-picker-mobile-header-month-range", inputs: ["rangeFrom", "rangeTo"] }, { type: i4.CdkVirtualScrollViewport, selector: "cdk-virtual-scroll-viewport", inputs: ["orientation", "appendOnly"], outputs: ["scrolledIndexChange"] }, { type: i5.FsDatePickerCalendarComponent, selector: "fs-date-picker-calendar", inputs: ["date", "period", "rangeFrom", "rangeTo", "highlightStartDate", "highlightEndDate", "dateMode", "disabledDays", "drawMonth", "seedDate", "periodWeeks", "hideExtraDays"], outputs: ["change", "rangeChange", "periodChange", "hoverDay"] }], directives: [{ type: i6.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i4.CdkVirtualForOf, selector: "[cdkVirtualFor][cdkVirtualForOf]", inputs: ["cdkVirtualForOf", "cdkVirtualForTrackBy", "cdkVirtualForTemplate", "cdkVirtualForTemplateCacheSize"] }], pipes: { "async": i6.AsyncPipe, "fsDateFormat": i7.FsDateFormatPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerVirtualScrollCalendarComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'fs-datepicker-mobile-scroll-calendar',
                    templateUrl: './virtual-scroll-calendar.component.html',
                    styleUrls: ['./virtual-scroll-calendar.component.scss'],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [
                        {
                            provide: VIRTUAL_SCROLL_STRATEGY,
                            useClass: CalendarScrollStrategy,
                        },
                    ],
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i1.MatBottomSheetRef }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [VIRTUAL_SCROLL_STRATEGY]
                }] }]; }, propDecorators: { datePickerModel: [{
                type: Input
            }], autoClose: [{
                type: Input
            }], parentTabGroup: [{
                type: Input
            }], parentTabIndex: [{
                type: Input
            }], virtualScroll: [{
                type: ViewChild,
                args: [CdkVirtualScrollViewport, { static: true }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmlydHVhbC1zY3JvbGwtY2FsZW5kYXIuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vc3JjL2xpYnMvZGlhbG9nL21vZHVsZXMvbW9iaWxlLWRpYWxvZy1jb250YWluZXIvY29tcG9uZW50cy92aXJ0dWFsLXNjcm9sbC1jYWxlbmRhci92aXJ0dWFsLXNjcm9sbC1jYWxlbmRhci5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9zcmMvbGlicy9kaWFsb2cvbW9kdWxlcy9tb2JpbGUtZGlhbG9nLWNvbnRhaW5lci9jb21wb25lbnRzL3ZpcnR1YWwtc2Nyb2xsLWNhbGVuZGFyL3ZpcnR1YWwtc2Nyb2xsLWNhbGVuZGFyLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCx1QkFBdUIsRUFDdkIsU0FBUyxFQUNULFVBQVUsRUFDVixNQUFNLEVBQ04sS0FBSyxFQUtMLFNBQVMsR0FDVixNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUVuRSxPQUFPLEVBQ0wsd0JBQXdCLEVBQ3hCLHVCQUF1QixHQUN4QixNQUFNLHdCQUF3QixDQUFDO0FBRWhDLE9BQU8sRUFBRSxTQUFTLEVBQWMsSUFBSSxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDbkUsT0FBTyxFQUNMLFlBQVksRUFDWixLQUFLLEVBQ0wsTUFBTSxFQUNOLFdBQVcsRUFDWCxTQUFTLEVBQ1QsSUFBSSxFQUNKLFNBQVMsRUFDVixNQUFNLGdCQUFnQixDQUFDO0FBRXhCLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxVQUFVLENBQUM7QUFFcEMsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDOUQsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0sNENBQTRD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QyxTQUFTO3NCQURmLEtBQUs7Z0JBSUMsY0FBYztzQkFEcEIsS0FBSztnQkFJQyxjQUFjO3NCQURwQixLQUFLO2dCQUlDLGFBQWE7c0JBRG5CLFNBQVM7dUJBQUMsd0JBQXdCLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENvbXBvbmVudCxcbiAgRWxlbWVudFJlZixcbiAgSW5qZWN0LFxuICBJbnB1dCxcbiAgT25DaGFuZ2VzLFxuICBPbkRlc3Ryb3ksXG4gIE9uSW5pdCxcbiAgU2ltcGxlQ2hhbmdlcyxcbiAgVmlld0NoaWxkLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgTWF0Qm90dG9tU2hlZXRSZWYgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbC9ib3R0b20tc2hlZXQnO1xuXG5pbXBvcnQge1xuICBDZGtWaXJ0dWFsU2Nyb2xsVmlld3BvcnQsXG4gIFZJUlRVQUxfU0NST0xMX1NUUkFURUdZLFxufSBmcm9tICdAYW5ndWxhci9jZGsvc2Nyb2xsaW5nJztcblxuaW1wb3J0IHsgZnJvbUV2ZW50LCBPYnNlcnZhYmxlLCByYWNlLCB0aW1lciwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtcbiAgZGVib3VuY2VUaW1lLFxuICBkZWxheSxcbiAgZmlsdGVyLFxuICBzaGFyZVJlcGxheSxcbiAgc3dpdGNoTWFwLFxuICB0YWtlLFxuICB0YWtlVW50aWxcbn0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQgeyBpc0JlZm9yZSB9IGZyb20gJ2RhdGUtZm5zJztcblxuaW1wb3J0IHsgRnNDYWxlbmRhckRhdGFTb3VyY2UgfSBmcm9tICcuL2NhbGVuZGFyLWRhdGEtc291cmNlJztcbmltcG9ydCB7IEZzRGF0ZVBpY2tlckRpYWxvZ01vZGVsIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vZGlhbG9nL2NsYXNzZXMvZGlhbG9nLW1vZGVsJztcbmltcG9ydCB7IEZzRGF0ZVBpY2tlckRpYWxvZ1JlZiB9IGZyb20gJy4uLy4uLy4uLy4uL2NsYXNzZXMvZGlhbG9nLXJlZic7XG5pbXBvcnQgeyBSYW5nZVBpY2tlclJlZiB9IGZyb20gJy4uLy4uLy4uLy4uLy4uLy4uL2FwcC9jbGFzc2VzL3JhbmdlLXBpY2tlci1yZWYnO1xuXG5pbXBvcnQgeyBGc0NhbGVuZGFyTW9iaWxlU2Nyb2xsU3RyYXRlZ3ksIENhbGVuZGFyU2Nyb2xsU3RyYXRlZ3kgfSBmcm9tICcuL2NhbGVuZGFyLXNjcm9sbC1zdHJhdGVneSc7XG5pbXBvcnQgeyBNYXRUYWJHcm91cCB9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsL3RhYnMnO1xuXG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2ZzLWRhdGVwaWNrZXItbW9iaWxlLXNjcm9sbC1jYWxlbmRhcicsXG4gIHRlbXBsYXRlVXJsOiAnLi92aXJ0dWFsLXNjcm9sbC1jYWxlbmRhci5jb21wb25lbnQuaHRtbCcsXG4gIHN0eWxlVXJsczogWycuL3ZpcnR1YWwtc2Nyb2xsLWNhbGVuZGFyLmNvbXBvbmVudC5zY3NzJ10sXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICBwcm92aWRlcnM6IFtcbiAgICB7XG4gICAgICBwcm92aWRlOiBWSVJUVUFMX1NDUk9MTF9TVFJBVEVHWSxcbiAgICAgIHVzZUNsYXNzOiBDYWxlbmRhclNjcm9sbFN0cmF0ZWd5LFxuICAgIH0sXG4gIF0sXG59KVxuZXhwb3J0IGNsYXNzIEZzRGF0ZVBpY2tlclZpcnR1YWxTY3JvbGxDYWxlbmRhckNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3kge1xuXG4gIEBJbnB1dCgpXG4gIHB1YmxpYyBkYXRlUGlja2VyTW9kZWw6IEZzRGF0ZVBpY2tlckRpYWxvZ01vZGVsO1xuXG4gIEBJbnB1dCgpXG4gIHB1YmxpYyBhdXRvQ2xvc2UgPSB0cnVlO1xuXG4gIEBJbnB1dCgpXG4gIHB1YmxpYyBwYXJlbnRUYWJHcm91cDogTWF0VGFiR3JvdXA7XG5cbiAgQElucHV0KClcbiAgcHVibGljIHBhcmVudFRhYkluZGV4OiBudW1iZXI7XG5cbiAgQFZpZXdDaGlsZChDZGtWaXJ0dWFsU2Nyb2xsVmlld3BvcnQsIHsgc3RhdGljOiB0cnVlIH0pXG4gIHB1YmxpYyB2aXJ0dWFsU2Nyb2xsOiBDZGtWaXJ0dWFsU2Nyb2xsVmlld3BvcnRcblxuICBwdWJsaWMgbW9kZWxGcm9tJDogT2JzZXJ2YWJsZTxEYXRlPjtcbiAgcHVibGljIG1vZGVsVG8kOiBPYnNlcnZhYmxlPERhdGU+O1xuXG4gIHB1YmxpYyBkYXRhU291cmNlID0gbmV3IEZzQ2FsZW5kYXJEYXRhU291cmNlKCk7XG5cbiAgcHJpdmF0ZSBfZGlhbG9nUmVmOiBGc0RhdGVQaWNrZXJEaWFsb2dSZWY7XG4gIHByaXZhdGUgX2FjdGl2ZVNjcm9sbEluZGV4OiBudW1iZXI7XG4gIHByaXZhdGUgX2Rlc3Ryb3kkID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIF9lbDogRWxlbWVudFJlZixcbiAgICBwcml2YXRlIF9ib3R0b21TaGVldFJlZjogTWF0Qm90dG9tU2hlZXRSZWY8YW55PixcbiAgICBASW5qZWN0KFZJUlRVQUxfU0NST0xMX1NUUkFURUdZKVxuICAgIHByaXZhdGUgX3Njcm9sbFN0cmF0ZWd5OiBGc0NhbGVuZGFyTW9iaWxlU2Nyb2xsU3RyYXRlZ3ksXG4gICkge31cblxuICBwdWJsaWMgZ2V0IGRpYWxvZ1JlZigpOiBGc0RhdGVQaWNrZXJEaWFsb2dSZWYge1xuICAgIHJldHVybiB0aGlzLl9kaWFsb2dSZWY7XG4gIH1cblxuICBwdWJsaWMgZ2V0IHJhbmdlUGlja2VyUmVmKCk6IFJhbmdlUGlja2VyUmVmIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuZGF0ZVBpY2tlck1vZGVsLnJhbmdlUGlja2VyUmVmO1xuICB9XG5cbiAgcHVibGljIG5nT25Jbml0KCkge1xuICAgIHRoaXMuX3Njcm9sbFN0cmF0ZWd5LnNldEluaXRpYWxEYXRlKHRoaXMuZGF0ZVBpY2tlck1vZGVsLm1vZGVsIHx8IG5ldyBEYXRlKCkpO1xuICAgIHRoaXMuX3Njcm9sbFRvQ2xvc2VzdE1vbnRoKCk7XG5cbiAgICBpZiAodGhpcy5wYXJlbnRUYWJHcm91cCkge1xuICAgICAgdGhpcy5fbGlzdGVuVGFiSW5kZXhDaGFuZ2UoKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuICAgIGlmIChjaGFuZ2VzLmRhdGVQaWNrZXJNb2RlbD8uY3VycmVudFZhbHVlXG4gICAgICAmJiBjaGFuZ2VzLmRhdGVQaWNrZXJNb2RlbD8uZmlyc3RDaGFuZ2VcbiAgICAgICYmIHRoaXMuZGF0ZVBpY2tlck1vZGVsLnZpZXcgPT09ICdtb250aHJhbmdlJykge1xuICAgICAgdGhpcy5faW5pdE1vbnRoUmFuZ2VNb2RlbHMoKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5fZGVzdHJveSQubmV4dCgpO1xuICAgIHRoaXMuX2Rlc3Ryb3kkLmNvbXBsZXRlKCk7XG4gIH1cblxuICBwdWJsaWMgZGF0ZUNoYW5nZWQoZGF0ZSk6IHZvaWQge1xuXG4gICAgaWYgKHRoaXMuZGF0ZVBpY2tlck1vZGVsLnZpZXcgIT09ICdtb250aHJhbmdlJykge1xuICAgICAgdGhpcy5kYXRlUGlja2VyTW9kZWwubW9kZWwgPSBkYXRlO1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1vbnRoUmFuZ2VDaGFuZ2UoZGF0ZSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIG1vbnRoUmFuZ2VDaGFuZ2UoZGF0ZSk6IHZvaWQge1xuICAgIGNvbnN0IHJhbmdlUmVmID0gdGhpcy5yYW5nZVBpY2tlclJlZjtcbiAgICBjb25zdCB7IHN0YXJ0RGF0ZSwgZW5kRGF0ZSB9ID0gcmFuZ2VSZWY7XG5cbiAgICBpZiAoIXN0YXJ0RGF0ZSAmJiAhZW5kRGF0ZSkge1xuICAgICAgcmFuZ2VSZWYudXBkYXRlU3RhcnREYXRlKGRhdGUpO1xuICAgIH0gZWxzZSBpZiAoc3RhcnREYXRlICYmICFlbmREYXRlKSB7XG4gICAgICBpZiAoaXNCZWZvcmUoZGF0ZSwgc3RhcnREYXRlKSkge1xuICAgICAgICByYW5nZVJlZi51cGRhdGVTdGFydERhdGUoZGF0ZSk7XG4gICAgICAgIHJhbmdlUmVmLnVwZGF0ZUVuZERhdGUobnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByYW5nZVJlZi51cGRhdGVFbmREYXRlKGRhdGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3RhcnREYXRlICYmIGVuZERhdGUpIHtcbiAgICAgIHJhbmdlUmVmLnVwZGF0ZVN0YXJ0RGF0ZShkYXRlKTtcbiAgICAgIHJhbmdlUmVmLnVwZGF0ZUVuZERhdGUobnVsbCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGNsb3NlKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmF1dG9DbG9zZSkge1xuICAgICAgdGhpcy5fYm90dG9tU2hlZXRSZWYuZGlzbWlzcygpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzY29sbEluZGV4Q2hhbmdlKGFjdGl2ZUluZGV4OiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLl9hY3RpdmVTY3JvbGxJbmRleCA9IGFjdGl2ZUluZGV4O1xuICB9XG5cbiAgcHJpdmF0ZSBfc2Nyb2xsVG9DbG9zZXN0TW9udGgoKTogdm9pZCB7XG4gICAgY29uc3QgdG91Y2hzdGFydCQgPSBmcm9tRXZlbnQoXG4gICAgICB0aGlzLnZpcnR1YWxTY3JvbGwuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LFxuICAgICAgJ3RvdWNoc3RhcnQnLFxuICAgICk7XG5cbiAgICBjb25zdCB0b3VjaGVuZCQgPSBmcm9tRXZlbnQoXG4gICAgICB0aGlzLnZpcnR1YWxTY3JvbGwuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LFxuICAgICAgJ3RvdWNoZW5kJyxcbiAgICApO1xuXG4gICAgY29uc3Qgc2Nyb2xsRGVib3VuY2VUaW1lID0gODA7XG5cbiAgICB0b3VjaHN0YXJ0JFxuICAgICAgLnBpcGUoXG4gICAgICAgIHN3aXRjaE1hcCgoKSA9PiB0b3VjaGVuZCQpLFxuICAgICAgICBzd2l0Y2hNYXAoKCkgPT5cbiAgICAgICAgICByYWNlPHVua25vd24+KFxuICAgICAgICAgICAgdGhpcy52aXJ0dWFsU2Nyb2xsLmVsZW1lbnRTY3JvbGxlZCgpLFxuICAgICAgICAgICAgdGltZXIoc2Nyb2xsRGVib3VuY2VUaW1lKSxcbiAgICAgICAgICApLnBpcGUoXG4gICAgICAgICAgICBkZWJvdW5jZVRpbWUoc2Nyb2xsRGVib3VuY2VUaW1lICogMiksXG4gICAgICAgICAgICB0YWtlKDEpLFxuICAgICAgICAgICAgdGFrZVVudGlsKHRvdWNoc3RhcnQkKSxcbiAgICAgICAgICApXG4gICAgICAgICksXG4gICAgICAgIHRha2VVbnRpbCh0aGlzLl9kZXN0cm95JCksXG4gICAgICApXG4gICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgdGhpcy52aXJ0dWFsU2Nyb2xsLnNjcm9sbFRvSW5kZXgodGhpcy5fYWN0aXZlU2Nyb2xsSW5kZXgsICdzbW9vdGgnKTtcbiAgICAgIH0pXG4gIH1cblxuICBwcml2YXRlIF9pbml0TW9udGhSYW5nZU1vZGVscygpOiB2b2lkIHtcbiAgICB0aGlzLm1vZGVsRnJvbSQgPSB0aGlzLmRhdGVQaWNrZXJNb2RlbFxuICAgICAgLnJhbmdlUGlja2VyUmVmXG4gICAgICAuc3RhcnREYXRlJFxuICAgICAgLnBpcGUoXG4gICAgICAgIHNoYXJlUmVwbGF5KCksXG4gICAgICApO1xuXG4gICAgdGhpcy5tb2RlbFRvJCA9IHRoaXMuZGF0ZVBpY2tlck1vZGVsXG4gICAgICAucmFuZ2VQaWNrZXJSZWZcbiAgICAgIC5lbmREYXRlJFxuICAgICAgLnBpcGUoXG4gICAgICAgIHNoYXJlUmVwbGF5KCksXG4gICAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBfbGlzdGVuVGFiSW5kZXhDaGFuZ2UoKTogdm9pZCB7XG4gICAgdGhpcy5wYXJlbnRUYWJHcm91cC5zZWxlY3RlZEluZGV4Q2hhbmdlXG4gICAgICAucGlwZShcbiAgICAgICAgZmlsdGVyKChpbmRleCkgPT4gaW5kZXggPT09IHRoaXMucGFyZW50VGFiSW5kZXgpLFxuICAgICAgICBkZWxheSgwKSxcbiAgICAgICAgdGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3kkKSxcbiAgICAgIClcbiAgICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICB0aGlzLl9zY3JvbGxTdHJhdGVneS5zY3JvbGxUb0RhdGUodGhpcy5kYXRlUGlja2VyTW9kZWwubW9kZWwgfHwgbmV3IERhdGUoKSk7XG4gICAgICB9KTtcbiAgfVxufVxuIiwiPGRpdiBjbGFzcz1cImhlYWRlclwiPlxuICA8bmctY29udGFpbmVyICpuZ0lmPVwiZGF0ZVBpY2tlck1vZGVsLnZpZXcgIT09ICdtb250aHJhbmdlJyBlbHNlIG1vbnRoUmFuZ2VIZWFkZXJcIj5cbiAgICA8ZnMtZGF0ZS1waWNrZXItbW9iaWxlLWhlYWRlclxuICAgICAgW2NhbGVuZGFyRGF0ZV09XCJkYXRlUGlja2VyTW9kZWwubW9kZWwkIHwgYXN5bmNcIlxuICAgICAgW21pblllYXJdPVwiZGF0ZVBpY2tlck1vZGVsLm1pblllYXJcIlxuICAgICAgW21heFllYXJdPVwiZGF0ZVBpY2tlck1vZGVsLm1heFllYXJcIlxuICAgICAgW3ZpZXdNb2RlXT1cImRhdGVQaWNrZXJNb2RlbC5jYWxlbmRhck1vZGUkIHwgYXN5bmNcIlxuICAgICAgW2Rpc2FibGVkRGF5c109XCJkYXRlUGlja2VyTW9kZWwuZGlzYWJsZWREYXlzJCB8IGFzeW5jXCI+XG4gICAgPC9mcy1kYXRlLXBpY2tlci1tb2JpbGUtaGVhZGVyPlxuICA8L25nLWNvbnRhaW5lcj5cblxuICA8bmctdGVtcGxhdGUgI21vbnRoUmFuZ2VIZWFkZXI+XG4gICAgPGZzLWRhdGUtcGlja2VyLW1vYmlsZS1oZWFkZXItbW9udGgtcmFuZ2VcbiAgICAgIFtyYW5nZUZyb21dPVwibW9kZWxGcm9tJCB8IGFzeW5jXCJcbiAgICAgIFtyYW5nZVRvXT1cIm1vZGVsVG8kIHwgYXN5bmNcIj5cbiAgICA8L2ZzLWRhdGUtcGlja2VyLW1vYmlsZS1oZWFkZXItbW9udGgtcmFuZ2U+XG4gIDwvbmctdGVtcGxhdGU+XG48L2Rpdj5cblxuPGNkay12aXJ0dWFsLXNjcm9sbC12aWV3cG9ydCBjbGFzcz1cInZpZXctcG9ydFwiIChzY3JvbGxlZEluZGV4Q2hhbmdlKT1cInNjb2xsSW5kZXhDaGFuZ2UoJGV2ZW50KVwiPlxuICA8ZGl2ICpjZGtWaXJ0dWFsRm9yPVwibGV0IGl0ZW0gb2YgZGF0YVNvdXJjZVwiPlxuICAgIDxkaXYgY2xhc3M9XCJtb250aC1oZWFkZXJcIj5cbiAgICAgIHt7IGl0ZW0gfCBmc0RhdGVGb3JtYXQ6ICdmdWxsLWRhdGUtZGF5bGVzcycgfX1cbiAgICA8L2Rpdj5cbiAgICA8ZnMtZGF0ZS1waWNrZXItY2FsZW5kYXJcbiAgICAgIFtkYXRlXT1cImRhdGVQaWNrZXJNb2RlbC5tb2RlbCQgfCBhc3luY1wiXG4gICAgICBbZHJhd01vbnRoXT1cIml0ZW1cIlxuICAgICAgW3JhbmdlRnJvbV09XCJtb2RlbEZyb20kIHwgYXN5bmNcIlxuICAgICAgW3JhbmdlVG9dPVwibW9kZWxUbyQgfCBhc3luY1wiXG4gICAgICBbaGlnaGxpZ2h0U3RhcnREYXRlXT1cIm1vZGVsRnJvbSQgfCBhc3luY1wiXG4gICAgICBbaGlnaGxpZ2h0RW5kRGF0ZV09XCJtb2RlbFRvJCB8IGFzeW5jXCJcbiAgICAgIFtkYXRlTW9kZV09XCJkYXRlUGlja2VyTW9kZWwuY2FsZW5kYXJNb2RlJCB8IGFzeW5jXCJcbiAgICAgIFtkaXNhYmxlZERheXNdPVwiZGF0ZVBpY2tlck1vZGVsLmRpc2FibGVkRGF5cyQgfCBhc3luY1wiXG4gICAgICBbaGlkZUV4dHJhRGF5c109XCJ0cnVlXCJcbiAgICAgIFtwZXJpb2RdPVwiZGF0ZVBpY2tlck1vZGVsLnBlcmlvZFwiXG4gICAgICBbc2VlZERhdGVdPVwiZGF0ZVBpY2tlck1vZGVsLnNlZWREYXRlXCJcbiAgICAgIFtwZXJpb2RXZWVrc109XCJkYXRlUGlja2VyTW9kZWwucGVyaW9kV2Vla3NcIlxuICAgICAgKGNoYW5nZSk9XCJkYXRlQ2hhbmdlZCgkZXZlbnQpXCI+XG4gICAgPC9mcy1kYXRlLXBpY2tlci1jYWxlbmRhcj5cbiAgPC9kaXY+XG48L2Nkay12aXJ0dWFsLXNjcm9sbC12aWV3cG9ydD5cbiJdfQ==