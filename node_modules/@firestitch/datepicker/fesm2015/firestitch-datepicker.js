import * as i0 from '@angular/core';
import { EventEmitter, Component, ChangeDetectionStrategy, Input, Output, NgModule, Injectable, Inject, ViewChild, Directive, HostBinding, HostListener, Optional, ElementRef, forwardRef, Self } from '@angular/core';
import * as i1 from '@angular/common';
import { CommonModule, DOCUMENT } from '@angular/common';
import * as i2 from '@angular/forms';
import { FormsModule, Validators, NG_VALUE_ACCESSOR, NG_VALIDATORS } from '@angular/forms';
import * as i4$1 from '@angular/material/button';
import { MatButtonModule } from '@angular/material/button';
import * as i1$1 from '@angular/material/icon';
import { MatIconModule } from '@angular/material/icon';
import { MatMenuModule } from '@angular/material/menu';
import { MatSelectModule } from '@angular/material/select';
import * as i1$3 from '@angular/material/tabs';
import { MatTabsModule } from '@angular/material/tabs';
import * as i2$1 from '@angular/cdk/layout';
import { LayoutModule } from '@angular/cdk/layout';
import * as i1$7 from '@firestitch/clear';
import { FsClearModule } from '@firestitch/clear';
import * as i1$4 from '@firestitch/scroll-picker';
import { FsScrollPickerModule } from '@firestitch/scroll-picker';
import { startOfDay, isValid, isDate, lightFormat, endOfDay, isWithinInterval, addWeeks, isBefore, differenceInYears, differenceInCalendarYears, isSameWeek, addYears, differenceInCalendarWeeks, subDays, getDaysInMonth, addDays, format, isAfter, eachDayOfInterval, subYears, isSameDay, setMonth, setYear, addMonths, subMonths, startOfMonth, endOfMonth, startOfYear, endOfYear, isEqual as isEqual$1 } from 'date-fns';
import { PortalInjector, ComponentPortal } from '@angular/cdk/portal';
import * as i1$5 from '@angular/cdk/overlay';
import { OverlayRef, OverlayConfig } from '@angular/cdk/overlay';
import * as i1$2 from '@angular/material/bottom-sheet';
import { MAT_BOTTOM_SHEET_DATA, MatBottomSheetRef } from '@angular/material/bottom-sheet';
import { Subject, BehaviorSubject, Subscription, fromEvent, race, timer, merge } from 'rxjs';
import { distinctUntilChanged, switchMap, debounceTime, take, takeUntil, shareReplay, filter, delay, skip, map, tap, finalize, pairwise } from 'rxjs/operators';
import * as i4 from '@angular/cdk/scrolling';
import { VIRTUAL_SCROLL_STRATEGY, CdkVirtualScrollViewport, ScrollingModule } from '@angular/cdk/scrolling';
import { DataSource } from '@angular/cdk/collections';
import * as i3 from '@firestitch/date';
import { FsDateModule, format as format$1 } from '@firestitch/date';
import * as i5 from '@angular/material/list';
import { MatListModule } from '@angular/material/list';
import { forEach, isEqual, isNumber } from 'lodash-es';
import { zonedTimeToUtc, utcToZonedTime } from 'date-fns-tz';
import * as parseMessyDate from 'parse-messy-time';
import * as i1$6 from '@angular/material/form-field';

function getStartDayDate() {
    return startOfDay(new Date());
}

function splitDateByComponents(date) {
    if (date && isValid(date) && isDate(date)) {
        return {
            date: lightFormat(date, 'yyyy-MM-dd'),
            hour: date.getHours(),
            minute: date.getMinutes(),
            year: date.getFullYear(),
            month: date.getMonth(),
            day: date.getDate(),
        };
    }
    else {
        return {
            date: null,
            hour: null,
            minute: null,
            year: null,
            month: null,
            day: null,
        };
    }
}

const WEEKDAYS = [
    'Sun',
    'Mon',
    'Tues',
    'Wed',
    'Thurs',
    'Fri',
    'Sat',
];

function isRangeDisabled(disabledDays, start, end) {
    if (!disabledDays || !disabledDays.length) {
        return false;
    }
    for (let i = 0; i < disabledDays.length; i++) {
        const value = disabledDays[i];
        const startDay = startOfDay(value[0]);
        const endDay = endOfDay(value[1]);
        const startDayIntersectWithDisabled = isWithinInterval(start, { start: startDay, end: endDay })
            || lightFormat(start, 'yyyy-MM-dd') === lightFormat(value[0], 'yyyy-MM-dd');
        const endDayIntersectWithDisabled = isWithinInterval(end, { start: startDay, end: endDay })
            || lightFormat(end, 'yyyy-MM-dd') === lightFormat(value[1], 'yyyy-MM-dd');
        if (startDayIntersectWithDisabled && endDayIntersectWithDisabled) {
            return true;
        }
    }
    return false;
}

function isDayDisabled(disabledDays, date) {
    const startDay = startOfDay(date);
    const endDay = endOfDay(date);
    return isRangeDisabled(disabledDays, startDay, endDay);
}

class Week {
    constructor(_dateStart, _seedDate, _periodWeeks) {
        this._dateStart = _dateStart;
        this._seedDate = _seedDate;
        this._periodWeeks = _periodWeeks;
        this.days = [];
        this.firstWeekInPeriod = false;
        this.lastWeekInPeriod = false;
        this._periodVisible = false;
        if (this._seedDate && this._periodWeeks) {
            this.periodId = this._getPeriodId();
        }
        this._dateEnd = addWeeks(this._dateStart, 1);
    }
    get dateStart() {
        return this._dateStart;
    }
    get dateEnd() {
        return this._dateEnd;
    }
    get periodLableVisible() {
        return this._periodVisible;
    }
    /**
     * Add related day
     * @param day
     */
    addDay(day) {
        this.days.push(day);
    }
    /**
     * Add related period
     * @param period
     */
    addPeriod(period) {
        this.period = period;
    }
    /**
     * Set visibility for period label
     * @param flag
     */
    setPeriodVisibility(flag) {
        this._periodVisible = flag;
    }
    /**
     * To be able to draw borders for week
     */
    markAsFirstVisiblePeriodWeek() {
        this.firstWeekInPeriod = true;
    }
    markAsLastVisiblePeriodWeek() {
        this.lastWeekInPeriod = true;
    }
    /**
     * Calculate period ID based on week date start and seed date
     */
    _getPeriodId() {
        /**
         * If week date start before seed date
         */
        if (isBefore(this._dateStart, this._seedDate)) {
            const diffInYears = differenceInYears(this._dateStart, this._seedDate);
            const diffInCalendarYears = differenceInCalendarYears(this._dateStart, this._seedDate);
            const seedDate = new Date(this._seedDate);
            /**
             * Check if week date start includes seed date
             */
            const sameWeek = isSameWeek(this._dateStart, addYears(seedDate, diffInYears), { weekStartsOn: this._seedDate.getDay() });
            if (sameWeek) {
                seedDate.setFullYear(seedDate.getFullYear() + (diffInYears || -1));
            }
            else {
                seedDate.setFullYear(seedDate.getFullYear() + (diffInCalendarYears || -1));
            }
            const weeksDiff = differenceInCalendarWeeks(this._dateStart, seedDate, { weekStartsOn: this._seedDate.getDay() }) / this._periodWeeks;
            // Sometimes weeksDiff can be integer and we use +0.1 for easy round
            return Math.ceil(weeksDiff + 0.1);
        }
        else {
            const diffInYears = differenceInYears(addWeeks(this._dateStart, 1), this._seedDate);
            const seedDate = new Date(this._seedDate);
            seedDate.setFullYear(seedDate.getFullYear() + diffInYears);
            const weeksDiff = differenceInCalendarWeeks(this._dateStart, seedDate, { weekStartsOn: this._seedDate.getDay() }) / this._periodWeeks;
            // Sometimes weeksDiff can be integer and we use +0.1 for easy round
            return Math.ceil(weeksDiff + 0.1);
        }
    }
}

class Period {
    constructor(periodId, startDate, seedDate, periodWeeks, _selected = false) {
        this.periodId = periodId;
        this.startDate = startDate;
        this.seedDate = seedDate;
        this.periodWeeks = periodWeeks;
        this._selected = _selected;
        this.mouseOver = false;
        this._weeks = [];
        this._countOfWeeks = 0;
        this._updatePeriodInterval();
    }
    get countOfWeeks() {
        return this._countOfWeeks;
    }
    get selected() {
        return this._selected;
    }
    get from() {
        return this._from;
    }
    get to() {
        return this._to;
    }
    get year() {
        return this._year;
    }
    set year(value) {
        this._year = value;
    }
    set selected(value) {
        this._selected = value;
        this._weeks.forEach((week) => {
            week.days.forEach((day) => {
                day.selected = value;
            });
        });
    }
    addWeek(week) {
        this._weeks.push(week);
        if (this.seedDate && this.periodWeeks) {
            this._sortWeeks();
            if (this._weeks.length === 1) {
                week.setPeriodVisibility(true);
            }
        }
        this._countOfWeeks = this._weeks.length;
    }
    /**
     * Mark weeks with special flags to be able to draw borders
     */
    markFirstLastWeeks() {
        const firstWeek = this._weeks[0];
        const lastWeek = this._weeks[this._weeks.length - 1];
        firstWeek.markAsFirstVisiblePeriodWeek();
        lastWeek.markAsLastVisiblePeriodWeek();
    }
    _sortWeeks() {
        this._weeks.sort((a, b) => {
            if (a.dateStart < b.dateStart) {
                return -1;
            }
            else if (a.dateStart > b.dateStart) {
                return 1;
            }
            else {
                return 0;
            }
        });
    }
    /**
     * Calc from, to, year params based on period date start
     */
    _updatePeriodInterval() {
        const diffInCalendarYears = differenceInCalendarYears(this.startDate, this.seedDate);
        const seedDate = new Date(this.seedDate);
        seedDate.setFullYear(seedDate.getFullYear() + diffInCalendarYears);
        const offsetFromSeedDate = (this.periodWeeks * (this.periodId - 1));
        this._from = addWeeks(seedDate, offsetFromSeedDate);
        this._to = addWeeks(this._from, this.periodWeeks);
        this._year = this._from.getFullYear();
    }
}

const CALENDAR_DAYS_NUMBER = 42;
class Month {
    constructor(date, seedDate, periodWeeks, _disabledDays, _hideExtraDays) {
        this.date = date;
        this.seedDate = seedDate;
        this.periodWeeks = periodWeeks;
        this._disabledDays = _disabledDays;
        this._hideExtraDays = _hideExtraDays;
        this.weeks = [];
        this._initMonth(date);
        if (this.seedDate && this.periodWeeks) {
            this._seedDay = seedDate.getDay();
            this._countTotalDaysInMonth(this._seedDay);
        }
        else {
            this._countTotalDaysInMonth(0);
        }
    }
    get seedDay() {
        return this._seedDay;
    }
    /**
     * Render days and weeks
     */
    renderDays() {
        let currentDate = subDays(this.date, this._prevMonthDaysCount);
        let daysToBeRendered = this._hideExtraDays
            ? getDaysInMonth(this.date) + this._prevMonthDaysCount
            : CALENDAR_DAYS_NUMBER;
        // only for week mode in mobile view!
        if (this._hideExtraDays && this.periodWeeks) {
            daysToBeRendered += 7 - (daysToBeRendered % 7);
        }
        let week;
        for (let d = 0; d < daysToBeRendered; d++) {
            const dayNumber = lightFormat(currentDate, 'd');
            if (d % 7 == 0) {
                week = new Week(currentDate, this.seedDate, this.periodWeeks);
                this.weeks.push(week);
            }
            const dayMuted = d - this._prevMonthDaysCount < 0
                || d >= this._daysInMonth + this._prevMonthDaysCount;
            week.addDay({
                mute: dayMuted,
                date: lightFormat(currentDate, 'yyyy-MM-dd'),
                number: dayNumber,
                month: currentDate.getMonth(),
                year: currentDate.getFullYear(),
                disabled: isDayDisabled(this._disabledDays, currentDate),
            });
            currentDate = addDays(currentDate, 1);
        }
        if (this.seedDate && this.periodWeeks) {
            this._groupWeeks();
            this._markFirstAndLastWeeks();
        }
    }
    getPeriodById(id) {
        if (!this.weeksByPeriod.has(id)) {
            return false;
        }
        return this.weeksByPeriod.get(id);
    }
    /**
     * Input period means that instance of period is not same instance
     * that was created for month.
     * It means that period and weeksByPeriod can have same periodIds but different object refs
     * @param period
     */
    updateSelectionForPeriod(period) {
        const p = this.getPeriodById(period.periodId);
        if (p && p.year === period.year) {
            p.selected = period.selected;
            return p;
        }
        else {
            return false;
        }
    }
    /**
     * Init base month field
     * @param date
     */
    _initMonth(date) {
        this.date = new Date(date);
        this.date.setDate(1);
        this._monthStartDay = this.date.getDay();
        this._daysInMonth = getDaysInMonth(this.date);
        this.name = format(this.date, 'MMMM');
        this.number = this.date.getMonth();
        this.year = this.date.getFullYear();
        this.monthAndYear = `${this.date.getFullYear()}-${this.date.getMonth()}`;
        this.months = [{ name: format(this.date, 'MMMM'), value: this.date.getMonth() }];
        this.years = [this.date.getFullYear()];
    }
    /**
     * Depends on week day start it counts total number of days in month
     * @param seedDay
     */
    _countTotalDaysInMonth(seedDay) {
        if (this._monthStartDay >= seedDay) {
            this._prevMonthDaysCount = this._monthStartDay - seedDay;
        }
        else {
            this._prevMonthDaysCount = 7 - (seedDay - this._monthStartDay);
        }
        // const totalDays = this._daysInMonth + this._prevMonthDaysCount;
        // this._totalDaysInMonth = Math.ceil(totalDays / 7) * 7;
    }
    /**
     * Just for easy usage
     */
    _groupWeeks() {
        this.weeksByPeriod = new Map();
        this.weeks.forEach((week) => {
            if (!this.weeksByPeriod.has(week.periodId)) {
                const newPeriod = new Period(week.periodId, week.dateStart, this.seedDate, this.periodWeeks);
                this.weeksByPeriod.set(week.periodId, newPeriod);
            }
            const period = this.weeksByPeriod
                .get(week.periodId);
            period.addWeek(week);
            week.addPeriod(period);
        });
    }
    _markFirstAndLastWeeks() {
        this.weeksByPeriod.forEach((period) => {
            period.markFirstLastWeeks();
        });
    }
}

class FsDatePickerCalendarComponent {
    constructor(element) {
        this.element = element;
        this.date = null;
        this.period = null;
        this.rangeFrom = null;
        this.rangeTo = null;
        this.highlightStartDate = null;
        this.highlightEndDate = null;
        this.dateMode = null;
        this.disabledDays = null;
        this.drawMonth = null;
        this.hideExtraDays = false;
        this.change = new EventEmitter();
        this.rangeChange = new EventEmitter();
        this.periodChange = new EventEmitter();
        this.hoverDay = new EventEmitter();
        this.selected = {};
        this.selectedRange = {};
        this.month = null;
        this.weekDaysList = [];
        this.currentDate = new Date();
        this.today = {
            date: format(this.currentDate, 'yyyy-MM-dd'),
            month: this.currentDate.getMonth(),
            year: this.currentDate.getFullYear()
        };
        this.highlightedRangeDays = null;
        // date | datetime | week
        this._calendarMode = 'date';
    }
    ngOnInit() {
        this._calendarMode = this.dateMode;
        if (this.dateMode === 'week') {
            if (this.period && this.seedDate) {
                this.selectedPeriod = new Period(this.period.period, this.period.from, this.seedDate, this.periodWeeks, true);
                this.selectedPeriod.year = this.period.from.getFullYear();
                const selectedPeriod = this.month.updateSelectionForPeriod(this.selectedPeriod);
                if (selectedPeriod) {
                    this.selectedPeriod = selectedPeriod;
                }
            }
        }
        else if (this.date) {
            this.selected = splitDateByComponents(this.date);
        }
    }
    ngOnChanges(changes) {
        if (changes) {
            if (changes.date) {
                this.selected = splitDateByComponents(this.date);
                this.updateDaysHighlighted();
            }
            else if (changes.highlightStartDate || changes.highlightEndDate) {
                this.updateDaysHighlighted();
            }
            if (changes.drawMonth) {
                if (changes.drawMonth.currentValue) {
                    this.drawMonths(changes.drawMonth.currentValue);
                }
            }
            if (changes.rangeFrom || changes.rangeTo) {
                this.selectedRange = {
                    from: this.rangeFrom && lightFormat(this.rangeFrom, 'yyyy-MM-dd') || null,
                    to: this.rangeTo && lightFormat(this.rangeTo, 'yyyy-MM-dd') || null,
                };
            }
        }
    }
    onMouseEnterDay(day) {
        this.hoverDay.emit(day);
    }
    mouseEnterWeek(week) {
        if (this.dateMode === 'week') {
            week.period.mouseOver = true;
        }
    }
    mouseLeaveWeek(week) {
        if (this.dateMode === 'week') {
            week.period.mouseOver = false;
        }
    }
    updateDaysHighlighted() {
        this.highlightedRangeDays = {
            data: {},
            min: null,
            max: null
        };
        let start = null;
        let end = null;
        if (this.highlightStartDate && this.highlightEndDate) {
            if (isAfter(this.highlightStartDate, this.highlightEndDate)) {
                start = this.highlightEndDate;
                end = this.highlightStartDate;
            }
            else {
                start = this.highlightStartDate;
                end = this.highlightEndDate;
            }
            start = startOfDay(start);
            end = startOfDay(end);
            const range = Array.from(eachDayOfInterval({ start, end }));
            if (!range.length) {
                return;
            }
            for (const day of range) {
                this.highlightedRangeDays.data[lightFormat(day, 'yyyy-MM-dd')] = true;
            }
            this.highlightedRangeDays.min = lightFormat(range[0], 'yyyy-MM-dd');
            this.highlightedRangeDays.max = lightFormat(range[range.length - 1], 'yyyy-MM-dd');
        }
    }
    createModel() {
        if (!this.date) {
            this.date = getStartDayDate();
        }
    }
    setDate(date) {
        this.date = date;
        this.change.emit(date);
    }
    /**
     *
     * @param day
     * @param week
     * @param event
     */
    dayClick(day, week, event) {
        if (this.dateMode === 'week') {
            this.selectPeriod(week.period);
        }
        else if (this.dateMode === 'monthrange') {
            this.selectMonthRange(day);
        }
        else {
            this.selectDay(day);
        }
    }
    selectDay(day) {
        if (day.disabled) {
            return;
        }
        if (!this.date) {
            this.createModel();
        }
        const date = new Date(day.year, day.month, day.number, this.date.getHours(), this.date.getMinutes(), this.date.getSeconds());
        this.setDate(date);
    }
    selectMonthRange(day) {
        const date = new Date(day.year, day.month, +day.number, 0, 0, 0);
        this.setDate(date);
    }
    selectPeriod(period) {
        if (this.selectedPeriod) {
            if (this.selectedPeriod === period) {
                this.selectedPeriod.selected = !this.selectedPeriod.selected;
            }
            else {
                this.selectedPeriod.selected = false;
                period.selected = true;
                this.selectedPeriod = period;
            }
        }
        else {
            period.selected = true;
            this.selectedPeriod = period;
        }
        if (this.selectedPeriod.selected) {
            this.periodChange.emit({
                period: this.selectedPeriod.periodId,
                from: this.selectedPeriod.from,
                to: this.selectedPeriod.to,
            });
        }
        else {
            this.periodChange.emit(null);
        }
    }
    drawMonths(date) {
        this.month = this.createMonth(date);
    }
    createMonth(date) {
        const month = new Month(date, this.seedDate, this.periodWeeks, this.disabledDays, this.hideExtraDays);
        if (this.dateMode === 'week') {
            this.weekDaysList = WEEKDAYS.map((_, i, arr) => {
                return arr[(i + month.seedDay) % 7];
            });
        }
        else {
            this.weekDaysList = WEEKDAYS.slice();
        }
        month.renderDays();
        if (this.dateMode === 'week' && this.selectedPeriod) {
            const selectedPeriod = month.updateSelectionForPeriod(this.selectedPeriod);
            if (selectedPeriod) {
                this.selectedPeriod = selectedPeriod;
            }
        }
        return month;
    }
}
FsDatePickerCalendarComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerCalendarComponent, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
FsDatePickerCalendarComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: FsDatePickerCalendarComponent, selector: "fs-date-picker-calendar", inputs: { date: "date", period: "period", rangeFrom: "rangeFrom", rangeTo: "rangeTo", highlightStartDate: "highlightStartDate", highlightEndDate: "highlightEndDate", dateMode: "dateMode", disabledDays: "disabledDays", drawMonth: "drawMonth", seedDate: "seedDate", periodWeeks: "periodWeeks", hideExtraDays: "hideExtraDays" }, outputs: { change: "change", rangeChange: "rangeChange", periodChange: "periodChange", hoverDay: "hoverDay" }, host: { classAttribute: "fs-date-picker-calendar" }, usesOnChanges: true, ngImport: i0, template: "<table\n  [class.month-range]=\"dateMode === 'monthrange'\"\n  [class.range-selected]=\"!!selectedRange.from && !!selectedRange.to\">\n  <thead>\n    <tr>\n      <th *ngIf=\"seedDate && periodWeeks\">#</th>\n      <th *ngFor=\"let wd of weekDaysList\">{{wd}}</th>\n    </tr>\n  </thead>\n\n  <tbody class=\"calendar calendar-{{ month.monthAndYear }}\" >\n    <ng-container *ngFor=\"let week of month.weeks\">\n      <tr class=\"week\"\n          [class.first-period-week]=\"week.firstWeekInPeriod\"\n          [class.last-period-week]=\"week.lastWeekInPeriod\"\n          [class.hover]=\"week.period?.mouseOver\"\n          (mouseenter)=\"mouseEnterWeek(week)\"\n          (mouseleave)=\"mouseLeaveWeek(week)\"\n      >\n        <ng-container *ngIf=\"week.periodLableVisible\">\n          <td class=\"period\"\n              [rowSpan]=\"week.period.countOfWeeks\"\n              [class.selected]=\"week.period.selected\"\n              (click)=\"selectPeriod(week.period)\">\n            {{ week.period.periodId }}\n          </td>\n        </ng-container>\n\n        <ng-container *ngFor=\"let day of week.days\">\n          <td class=\"tile day\"\n              [class.hidden-day]=\"hideExtraDays && day.mute\"\n              [class.now]=\"today.date == day.date\"\n              [class.mute]=\"day.mute\"\n              [class.selected]=\"(day.selected || day.date == selected.date && !day.mute)\"\n              [class.range-from]=\"day.date === selectedRange.from && !day.mute && selectedRange.from !== selectedRange.to\"\n              [class.range-to]=\"day.date === selectedRange.to && !day.mute && selectedRange.from !== selectedRange.to\"\n              [class.same-range-dates]=\"(hideExtraDays && !day.mute) && selectedRange.from === day.date && selectedRange.from === selectedRange.to\"\n              [class.highlighted]=\"!day.disabled && !day.mute && !!highlightedRangeDays.data[day.date]\"\n              [class.highlight-min-date]=\"day.date === highlightedRangeDays.min\"\n              [class.highlight-max-date]=\"day.date === highlightedRangeDays.max\"\n              [class.week-mode]=\"dateMode === 'week'\"\n              [class.disabled]=\"day.disabled\"\n              (click)=\"dayClick(day, week, $event)\"\n              (mouseenter)=\"onMouseEnterDay(day)\">\n            <div class=\"tile-content\">\n              <div class=\"tile-day-label\">\n                {{ day.number }}\n              </div>\n            </div>\n          </td>\n        </ng-container>\n      </tr>\n    </ng-container>\n\n  <!--<tr *ngIf=\"month.weeks.length < 6\">\n    <td colspan=\"7\" class=\"tile\"></td>\n  </tr>-->\n  </tbody>\n</table>\n", styles: [""], directives: [{ type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerCalendarComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'fs-date-picker-calendar',
                    templateUrl: './calendar.component.html',
                    styleUrls: ['./calendar.component.scss'],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    host: {
                        'class': 'fs-date-picker-calendar',
                    },
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { date: [{
                type: Input
            }], period: [{
                type: Input
            }], rangeFrom: [{
                type: Input
            }], rangeTo: [{
                type: Input
            }], highlightStartDate: [{
                type: Input
            }], highlightEndDate: [{
                type: Input
            }], dateMode: [{
                type: Input
            }], disabledDays: [{
                type: Input
            }], drawMonth: [{
                type: Input
            }], seedDate: [{
                type: Input
            }], periodWeeks: [{
                type: Input
            }], hideExtraDays: [{
                type: Input
            }], change: [{
                type: Output
            }], rangeChange: [{
                type: Output
            }], periodChange: [{
                type: Output
            }], hoverDay: [{
                type: Output
            }] } });

class FsDatePickerTimeComponent {
    constructor(element, _iterableDiffers) {
        this.element = element;
        this._iterableDiffers = _iterableDiffers;
        this.date = null;
        this.disabledMinutes = [];
        this.disabledHours = [];
        this.disabledTimes = [];
        this.expanded = false;
        this.minutes = true;
        this.showNotSelected = true;
        this.onChange = new EventEmitter();
        this.selected = {};
        this.disabledTimeMinutes = {};
        this.disabledTimeHours = {};
        this.disabledGroupedMinutes = {};
        this.timeHoursCollapsed = [
            [
                [0, 1, 2, 3],
                [4, 5, 6, 7],
                [8, 9, 10, 11]
            ],
            [
                [12, 13, 14, 15],
                [16, 17, 18, 19],
                [20, 21, 22, 23]
            ]
        ];
        this.timeMinutesCollapsed = [
            [0, 5],
            [10, 15],
            [20, 25],
            [30, 35],
            [40, 45],
            [50, 55]
        ];
        this.timeHoursExpanded = [
            [0, 12],
            [1, 13],
            [2, 14],
            [3, 15],
            [4, 16],
            [5, 17],
            [6, 18],
            [7, 19],
            [8, 20],
            [9, 21],
            [10, 22],
            [11, 23]
        ];
        this.timeMinutesExpanded = [
            [0, 1, 2, 3, 4],
            [5, 6, 7, 8, 9],
            [10, 11, 12, 13, 14],
            [15, 16, 17, 18, 19],
            [20, 21, 22, 23, 24],
            [25, 26, 27, 28, 29],
            [30, 31, 32, 33, 34],
            [35, 36, 37, 38, 39],
            [40, 41, 42, 43, 44],
            [45, 46, 47, 48, 49],
            [50, 51, 52, 53, 54],
            [55, 56, 57, 58, 59]
        ];
        this.disabledMinutesDiffer = null;
        this.disabledHoursDiffer = null;
        this.disabledTimesDiffer = null;
        this.disabledHoursDiffer = this._iterableDiffers.find([]).create(null);
        this.disabledMinutesDiffer = this._iterableDiffers.find([]).create(null);
        this.disabledTimesDiffer = this._iterableDiffers.find([]).create(null);
    }
    ngOnInit() {
        this.checkDisabledTime();
        this.nowHour = (new Date()).getHours();
        this.nowMinute = this.minutes
            ? (new Date()).getMinutes()
            : 0;
    }
    ngOnChanges(changes) {
        if (changes && changes.date) {
            this.selected = splitDateByComponents(this.date);
            if (!this.minutes) {
                this.selected.minute = 0;
                if (this.date) {
                    this.date.setMinutes(0);
                }
            }
        }
    }
    ngDoCheck() {
        if (this.disabledHoursDiffer.diff(this.disabledHours) ||
            this.disabledMinutesDiffer.diff(this.disabledMinutes) ||
            this.disabledTimesDiffer.diff(this.disabledTimes)) {
            this.checkDisabledTime();
        }
    }
    checkDisabledTime() {
        this.disabledTimeMinutes = {};
        this.disabledTimeHours = {};
        this.disabledGroupedMinutes = {};
        if (this.disabledMinutes !== undefined) {
            for (const range of this.disabledMinutes) {
                this.addDisabledMinutes(range);
            }
        }
        if (this.disabledHours !== undefined) {
            for (const range of this.disabledHours) {
                this.addDisabledHours(range);
            }
        }
        if (this.disabledTimes !== undefined) {
            for (const range of this.disabledTimes) {
                const min = Math.min(range[0], range[1]);
                const max = Math.max(range[0], range[1]);
                const minMinutes = min % 60;
                const maxMinutes = max % 60;
                const minHour = Math.floor(min / 60);
                const maxHour = Math.floor(max / 60);
                for (let h = 0; h <= 24; h++) {
                    this.disabledGroupedMinutes[h] = {};
                    if (h > minHour && h < maxHour) {
                        this.addDisabledHours(h);
                    }
                    else if (h == minHour && !minMinutes && minHour != maxHour) {
                        this.addDisabledHours(h);
                    }
                    if (h >= minHour && h <= maxHour) {
                        for (let m = minMinutes; m < maxMinutes; m++) {
                            const minute = h * m;
                            if (minute >= range[0] && minute <= range[1]) {
                                this.disabledGroupedMinutes[h][m] = true;
                            }
                        }
                    }
                }
            }
        }
    }
    addDisabledMinutes(range) {
        const min = Math.min(range[0], range[1]);
        const max = Math.max(range[0], range[1]);
        if (Array.isArray(range)) {
            for (let i = min; i <= max; i++) {
                this.disabledTimeMinutes[i] = true;
            }
        }
        else {
            this.disabledTimeMinutes[range] = true;
        }
    }
    addDisabledHours(range) {
        const min = Math.min(range[0], range[1]);
        const max = Math.max(range[0], range[1]);
        if (Array.isArray(range)) {
            for (let i = min; i <= max; i++) {
                this.disabledTimeHours[i] = true;
            }
        }
        else {
            this.disabledTimeHours[range] = true;
        }
    }
    createModel() {
        if (!this.date) {
            this.setDate(getStartDayDate());
        }
    }
    setDate(date) {
        this.date = date;
        this.onChange.emit(date);
    }
    hourClick(hour) {
        if (this.disabledTimeHours[hour]) {
            return;
        }
        let newDate;
        if (!this.date) {
            newDate = getStartDayDate();
        }
        else {
            newDate = new Date(this.date);
        }
        newDate.setHours(hour);
        this.setDate(newDate);
    }
    minuteClick(minute) {
        if (this.disabledTimeMinutes[minute]
            || (this.disabledGroupedMinutes[this.selected.hour] && this.disabledGroupedMinutes[this.selected.hour][minute])) {
            return;
        }
        let newDate;
        if (!this.date) {
            newDate = getStartDayDate();
        }
        else {
            newDate = new Date(this.date);
        }
        newDate.setMinutes(minute);
        this.setDate(newDate);
    }
}
FsDatePickerTimeComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerTimeComponent, deps: [{ token: i0.ElementRef }, { token: i0.IterableDiffers }], target: i0.ɵɵFactoryTarget.Component });
FsDatePickerTimeComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: FsDatePickerTimeComponent, selector: "fs-date-picker-time", inputs: { date: "date", disabledMinutes: "disabledMinutes", disabledHours: "disabledHours", disabledTimes: "disabledTimes", expanded: "expanded", minutes: "minutes", showNotSelected: "showNotSelected" }, outputs: { onChange: "onChange" }, usesOnChanges: true, ngImport: i0, template: "<div class=\"month-year time\" *ngIf=\"minutes && showNotSelected\">\n  <ng-container *ngIf=\"date; else noTime\">\n    {{ date | date:'h:mm aa'}}\n  </ng-container>\n  <ng-template #noTime>\n    Time Not Selected\n  </ng-template>\n</div>\n\n<div class=\"time-container\">\n  <table *ngIf=\"expanded; else contracted\">\n    <thead *ngIf=\"minutes\">\n      <tr>\n        <th class=\"hours-col\">\n          Hour\n        </th>\n        <th class=\"minutes-col\">\n          Minute\n        </th>\n      </tr>\n    </thead>\n    <tbody>\n      <tr>\n        <td class=\"hours-col\">\n          <div class=\"hours-container\">\n            <table>\n              <tr *ngFor=\"let hours of timeHoursExpanded\">\n                <td\n                  *ngFor=\"let hour of hours\"\n                  class=\"tile number hour\"\n                  (click)=\"hourClick(hour)\"\n                  [ngClass]=\"{\n                    disabled: disabledTimeHours[hour],\n                    now: nowHour === hour,\n                    selected: hour == selected.hour\n                  }\">\n                  <div class=\"tile-content\">\n                    <span *ngIf=\"hour < 12\">{{ hour ? hour : 12 }}<span class=\"am-pm\">am</span></span>\n                    <span *ngIf=\"hour >= 12\">{{ hour==12 ? 12 : hour-12 }}<span class=\"am-pm\">pm</span></span>\n                  </div>\n                </td>\n              </tr>\n            </table>\n          </div>\n        </td>\n        <td class=\"minutes-col\" *ngIf=\"minutes\">\n          <div class=\"minutes-container\">\n            <table>\n              <tr *ngFor=\"let minutes of timeMinutesExpanded\">\n                <td *ngFor=\"let minute of minutes\"\n                    class=\"tile number minute\"\n                    [ngClass]=\"{\n                      disabled: disabledTimeMinutes[minute] || (disabledGroupedMinutes[selected.hour] && disabledGroupedMinutes[selected.hour][minute]),\n                      selected: minute == selected.minute,\n                      now: nowMinute === minute\n                    }\"\n                    (click)=\"minuteClick(minute)\">\n                    <div class=\"tile-content\">{{ minute }}</div>\n                </td>\n              </tr>\n            </table>\n          </div>\n        </td>\n      </tr>\n    </tbody>\n  </table>\n</div>\n\n<ng-template #contracted>\n  <table>\n    <thead *ngIf=\"minutes\">\n      <tr>\n        <th class=\"hours-col\">\n          Hour\n        </th>\n        <th class=\"minutes-col\">\n          Minute\n        </th>\n      </tr>\n    </thead>\n    <tbody>\n      <tr>\n        <td class=\"hours-col\">\n          <table>\n            <tbody *ngFor=\"let group of timeHoursCollapsed; let i = index\">\n            <tr *ngFor=\"let hours of group\">\n              <td\n                *ngFor=\"let hour of hours\"\n                class=\"tile number hour\"\n                (click)=\"hourClick(hour)\"\n                [ngClass]=\"{\n                  disabled: disabledTimeHours[hour],\n                  selected: hour == selected.hour,\n                  now: nowHour === hour\n                }\">\n                <div class=\"tile-content\">\n                  <span *ngIf=\"hour < 12\">{{ hour ? hour : 12 }}<span class=\"am-pm\">am</span></span>\n                  <span *ngIf=\"hour >= 12\">{{ hour==12 ? 12 : hour-12 }}<span class=\"am-pm\">pm</span></span>\n                </div>\n              </td>\n            </tr>\n            </tbody>\n          </table>\n        </td>\n\n        <td class=\"minutes-col\" *ngIf=\"minutes\">\n          <table>\n            <tr *ngFor=\"let minutes of timeMinutesCollapsed\">\n              <td\n                *ngFor=\"let minute of minutes\"\n                class=\"tile number minute\"\n                [ngClass]=\"{\n                  disabled: disabledTimeMinutes[minute] || (disabledGroupedMinutes[selected.hour] && disabledGroupedMinutes[selected.hour][minute]),\n                  selected: minute == selected.minute,\n                  now: nowMinute === minute\n                }\"\n                  (click)=\"minuteClick(minute)\">\n                <div class=\"tile-content\">{{ minute }}</div>\n              </td>\n            </tr>\n          </table>\n        </td>\n      </tr>\n    </tbody>\n  </table>\n</ng-template>\n", styles: ["thead th{text-align:center}tbody .minutes-col,tbody .hours-col{padding:0}tbody .minutes-col{padding-left:20px}tbody .hours-container{margin-right:20px}tbody .minutes-container,tbody .hours-container{max-height:300px;overflow:auto}.time-container table{width:100%}.time-container table .am-pm{font-size:13px;padding-left:2px}\n"], directives: [{ type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }], pipes: { "date": i1.DatePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerTimeComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'fs-date-picker-time',
                    templateUrl: './time.component.html',
                    styleUrls: ['./time.component.scss'],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.IterableDiffers }]; }, propDecorators: { date: [{
                type: Input
            }], disabledMinutes: [{
                type: Input
            }], disabledHours: [{
                type: Input
            }], disabledTimes: [{
                type: Input
            }], expanded: [{
                type: Input
            }], minutes: [{
                type: Input
            }], showNotSelected: [{
                type: Input
            }], onChange: [{
                type: Output
            }] } });

class FsDatePickerCalendarModule {
}
FsDatePickerCalendarModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerCalendarModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
FsDatePickerCalendarModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerCalendarModule, declarations: [FsDatePickerCalendarComponent,
        FsDatePickerTimeComponent], imports: [CommonModule,
        MatIconModule], exports: [FsDatePickerCalendarComponent,
        FsDatePickerTimeComponent] });
FsDatePickerCalendarModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerCalendarModule, imports: [[
            CommonModule,
            MatIconModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerCalendarModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        MatIconModule,
                    ],
                    declarations: [
                        FsDatePickerCalendarComponent,
                        FsDatePickerTimeComponent,
                    ],
                    exports: [
                        FsDatePickerCalendarComponent,
                        FsDatePickerTimeComponent,
                    ],
                }]
        }] });

function getYearsCycle(monthLabelHeight, weekHeight, startCycleYear) {
    // Create array of 28 years.
    // Calendar repeats every 28 years
    return Array.from({ length: 28 }, (_, i) => {
        // Create array of 12 months for every year
        return Array.from({ length: 12 }, (__, month) => {
            // Calculate total height of calendar for every month
            return monthLabelHeight + weekCount(i, month, startCycleYear) * weekHeight;
        });
    });
}
/**
 * Calculate total height of calendars from 0 year to lastYear
 */
function reduceCycle(yearsCycle, lastYear = 28, lastMonth = 12) {
    return yearsCycle.reduce((total, year, yearIndex) => {
        if (yearIndex <= lastYear) {
            const heightOfMonthsInYear = year.reduce((sum, month, monthIndex) => {
                if (yearIndex < lastYear || (yearIndex === lastYear && monthIndex < lastMonth)) {
                    sum += month;
                }
                return sum;
            }, 0);
            total += heightOfMonthsInYear;
        }
        return total;
    }, 0);
}
/**
 * Returns number of weeks for given month
 */
function weekCount(yearCycleIndex, month, startCycleYear) {
    const firstOfMonth = new Date(yearCycleIndex + startCycleYear, month, 1);
    const lastOfMonth = new Date(yearCycleIndex + startCycleYear, month + 1, 0);
    const days = firstOfMonth.getDay() + lastOfMonth.getDate();
    return Math.ceil(days / 7);
}

const YEARS_TO_BE_RENDERED = 200;
const START_CYCLE_YEAR = 1900;
const RENDER_BUFFER = 500;
// height of month label and week days line
const MONTH_LABEL_HEIGHT = 78;
// height of week row
const WEEK_HEIGHT = 50;
/**
 * Implementation has been taken from Alex Inkin article, adopted and modified a bit
 * https://indepth.dev/posts/1091/writing-custom-virtual-scroll-strategy
 */
class CalendarScrollStrategy {
    constructor() {
        this._index$ = new Subject();
        this.scrolledIndexChange = this._index$.pipe(distinctUntilChanged());
        this._viewport = null;
        this._firstTimeRender = true;
        this.yearsCycle = getYearsCycle(MONTH_LABEL_HEIGHT, WEEK_HEIGHT, START_CYCLE_YEAR);
        // Total height of 28 years cycle
        this.yearsCycleHeight = reduceCycle(this.yearsCycle);
    }
    attach(viewport) {
        this._viewport = viewport;
        // Here is "7" is number of "cycles" in years range
        // We are rendering 200 years from 1900 to 2100
        // Year calendar repeat itself every 28 years
        // 200 / 28 = 7.14
        this._viewport.setTotalContentSize(this.yearsCycleHeight * 7);
    }
    detach() {
        this._index$.complete();
        this._viewport = null;
    }
    onContentScrolled() {
        if (this._viewport) {
            this._updateRenderedRange();
        }
    }
    onDataLengthChanged() { }
    onContentRendered() { }
    onRenderedOffsetChanged() { }
    /**
     * Initial Date for render can be set on initialization step to reduce calculations
     */
    setInitialDate(date) {
        this._initialDate = date;
    }
    /**
     * Does scroll to month with provided index
     */
    scrollToIndex(index, behavior) {
        if (this._viewport) {
            this._viewport.scrollToOffset(this._getOffsetForIndex(index), behavior);
        }
    }
    /**
     * Does the same thing as scrollToIndex(), but for date
     */
    scrollToDate(date, behavior) {
        if (this._viewport) {
            this._viewport.scrollToOffset(this._getOffsetForDate(date), behavior);
        }
    }
    /**
     * Update the viewport's rendered range.
     */
    _updateRenderedRange() {
        if (!this._viewport) {
            return;
        }
        // This is for support setInitialDate() method.
        // Should be called only once at first render
        if (this._firstTimeRender) {
            if (this._initialDate) {
                this.scrollToDate(this._initialDate);
            }
            this._firstTimeRender = false;
        }
        const currentScrollOffset = this._viewport.measureScrollOffset();
        const { start: currentStart, end: currentEnd } = this._viewport.getRenderedRange();
        const viewportSize = this._viewport.getViewportSize();
        const dataLength = this._viewport.getDataLength();
        const firstVisibleIndex = this._getIndexForOffset(currentScrollOffset);
        // Usually we are rendering a bit more months than available in view port
        // It works when user scrolls fast, so we have a bit time to render new months while will scroll over "buffer"
        // So this is why rendered top offset is different from current scroll offset
        const topScrollBuffer = currentScrollOffset - this._getOffsetForIndex(currentStart);
        let newStart = currentStart;
        let newEnd = currentEnd;
        if (topScrollBuffer < RENDER_BUFFER && currentStart !== 0) {
            // Here we have multiplication by 2 because we want to double our render buffer
            newStart = Math.max(0, this._getIndexForOffset(currentScrollOffset - RENDER_BUFFER * 2));
            newEnd = Math.min(dataLength, this._getIndexForOffset(currentScrollOffset + viewportSize + RENDER_BUFFER));
        }
        else {
            const bottomScrollBuffer = this._getOffsetForIndex(currentEnd) - currentScrollOffset - viewportSize;
            if (bottomScrollBuffer < RENDER_BUFFER && currentEnd !== dataLength) {
                newStart = Math.max(0, this._getIndexForOffset(currentScrollOffset - RENDER_BUFFER));
                newEnd = Math.min(dataLength, 
                // Here we have multiplication by 2 because we want to double our render buffer
                this._getIndexForOffset(currentScrollOffset + viewportSize + RENDER_BUFFER * 2));
            }
        }
        this._viewport.setRenderedRange({ start: newStart, end: newEnd });
        this._viewport.setRenderedContentOffset(this._getOffsetForIndex(newStart));
        this._index$.next(firstVisibleIndex);
    }
    _getOffsetForIndex(index) {
        const month = index % 12;
        const year = (index - month) / 12;
        return this._computeHeight(year, month);
    }
    _getIndexForOffset(offset) {
        // the remaining number of pixels that cannot make up a complete cycle
        const remainder = offset % this.yearsCycleHeight;
        const numberOfFullCycles = (offset - remainder) / this.yearsCycleHeight;
        const years = numberOfFullCycles * 28; // years from START_CYCLE_YEAR to current offset
        let heightAccumulator = 0;
        // Cycle through every year and month in 28 year cycle
        for (let year = 0; year < this.yearsCycle.length; year++) {
            for (let month = 0; month < this.yearsCycle[year].length; month++) {
                heightAccumulator += this.yearsCycle[year][month];
                if (heightAccumulator - this.yearsCycle[year][month] / 2 > remainder) {
                    return Math.max((years + year) * 12 + month, 0);
                }
            }
        }
        return YEARS_TO_BE_RENDERED;
    }
    _getOffsetForDate(date) {
        if (!date) {
            return 0;
        }
        const year = date.getFullYear();
        const month = date.getMonth();
        const index = (year - START_CYCLE_YEAR) * 12 + month;
        return this._getOffsetForIndex(index);
    }
    // Compute height for given year and month, but year starts from 0 to YEARS_TO_BE_RENDERED
    _computeHeight(year, month) {
        const remainder = year % 28; // number of year in cycle of 28 repeated years
        const remainderHeight = reduceCycle(this.yearsCycle, remainder, month);
        const fullCycles = (year - remainder) / 28;
        const fullCyclesHeight = fullCycles * this.yearsCycleHeight;
        return fullCyclesHeight + remainderHeight;
    }
}
CalendarScrollStrategy.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: CalendarScrollStrategy, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
CalendarScrollStrategy.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: CalendarScrollStrategy });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: CalendarScrollStrategy, decorators: [{
            type: Injectable
        }] });

class FsCalendarDataSource extends DataSource {
    constructor() {
        super();
        this._cachedMonths = [];
        this._fetchedPages = new Set();
        this._dataStream = new BehaviorSubject(this._cachedMonths);
        this._subscription = new Subscription();
        this._prepareMonthsList();
        this._dataStream.next(this._cachedMonths);
    }
    connect(collectionViewer) {
        const sub = collectionViewer
            .viewChange
            .subscribe((range) => {
            for (let i = range.start; i <= range.end; i++) {
                this._fetchPage(i);
            }
        });
        this._subscription.add(sub);
        return this._dataStream;
    }
    disconnect() {
        this._subscription.unsubscribe();
    }
    _fetchPage(page) {
        if (this._fetchedPages.has(page)) {
            return;
        }
        this._fetchedPages.add(page);
        const yearOffset = Math.floor(page / 12);
        const monthOffset = page % 12;
        const month = new Date(yearOffset + START_CYCLE_YEAR, monthOffset, 1);
        this._cachedMonths.splice(page, 1, month);
        this._dataStream.next(this._cachedMonths);
    }
    _prepareMonthsList() {
        this._cachedMonths = Array
            .from({ length: YEARS_TO_BE_RENDERED * 12 }, // number of rendered years multiply by number of months in year
        (_, i) => {
            return new Date(Math.floor(i / 12) + START_CYCLE_YEAR, i % 12, 1);
        });
    }
}

var PickerViewType;
(function (PickerViewType) {
    PickerViewType["Date"] = "date";
    PickerViewType["DateTime"] = "datetime";
    PickerViewType["Time"] = "time";
    PickerViewType["Week"] = "week";
    PickerViewType["MonthRange"] = "monthrange";
})(PickerViewType || (PickerViewType = {}));

function getDisabledDays(minDate, maxDate, minYear, maxYear) {
    const result = [];
    if (minDate) {
        const from = subYears(new Date(), minYear);
        const to = new Date(minDate);
        result.push([from, to]);
    }
    if (maxDate) {
        result.push([new Date(maxDate), addYears(new Date(), maxYear)]);
    }
    return result;
}

function getDisabledTimes(model, ref) {
    if (!ref) {
        return;
    }
    const arr = [];
    if ((ref.view === 'time' && ref.startDate) ||
        (ref.view === 'datetime' && ref.startDate && model && isSameDay(ref.startDate, model))) {
        const from = (ref.startDate.getMinutes()) + ((ref.startDate.getHours()) * 60);
        arr.push([0, from]);
    }
    return arr;
}

class FsDatePickerDialogModel {
    constructor(pickerOptions) {
        /**
         * year | month | date
         *
         * Current mode of calendar. For ranges consist values for both: start and end date
         */
        this.dateMode = null;
        this.minDate = null;
        this.maxDate = null;
        this.startOfDay = true;
        this.seedDate = null;
        this.periodWeeks = null;
        this.minutes = true;
        this._minYear = null;
        this._maxYear = null;
        this._model$ = new BehaviorSubject(null);
        this._period$ = new BehaviorSubject(null);
        this._now$ = new BehaviorSubject(new Date());
        this._disabledDays$ = new BehaviorSubject([]);
        this._disabledTimes$ = new BehaviorSubject([]);
        this._calendarDate$ = new BehaviorSubject(this.now);
        this._calendarMode$ = new BehaviorSubject('date');
        this._timeExpanded$ = new BehaviorSubject(false);
        /**
         * date | datetime | time | week
         * View is options selected on init. Can't be changed manually
         */
        this._view$ = new BehaviorSubject('date');
        this._initCalendar(pickerOptions);
        this._updateDisabled();
    }
    get now() {
        return this._now$.value;
    }
    set calendarDate(value) {
        this._calendarDate$.next(value);
    }
    get calendarDate() {
        return this._calendarDate$.value;
    }
    get calendarDate$() {
        return this._calendarDate$;
    }
    get view$() {
        return this._view$.asObservable();
    }
    get view() {
        return this._view$.value;
    }
    set view(view) {
        this._view$.next(view);
    }
    get isDateView() {
        return this.view === PickerViewType.Date;
    }
    get isDateTimeView() {
        return this.view === PickerViewType.DateTime;
    }
    get isTimeView() {
        return this.view === PickerViewType.Time;
    }
    get isWeekView() {
        return this.view === PickerViewType.Week;
    }
    get isMonthRangeView() {
        return this.view === PickerViewType.MonthRange;
    }
    get calendarMode$() {
        return this._calendarMode$;
    }
    get calendarMode() {
        return this._calendarMode$.value;
    }
    set model(value) {
        if (isValid(value)) {
            if (this.isDateView && this.startOfDay) {
                value = startOfDay(value);
            }
            /**
             * For cases when we have datetime view type and have opened "To" date picker.
             * If "From" date is already selected it means that we have some Time range to be disabled.
             * When user select "To" date without time (only clicks on date) we have to pull up time for selected date.
             */
            if (this.isDateTimeView
                && this._pickerOptions.rangeType === 'to'
                && !this.model
                && value) {
                if (isBefore(value, this.rangePickerRef.startDate)) {
                    value = new Date(this.rangePickerRef.startDate);
                }
            }
        }
        else {
            value = null;
        }
        this._model$.next(value);
        this._updateDisabledTimes();
    }
    get model() {
        return this._model$.value;
    }
    get model$() {
        return this._model$;
    }
    set period(value) {
        this._period$.next(value);
    }
    get period() {
        return this._period$.value;
    }
    get period$() {
        return this._period$;
    }
    set disabledDays(value) {
        this._disabledDays$.next(value);
    }
    get disabledDays$() {
        return this._disabledDays$;
    }
    set disabledTimes(value) {
        this._disabledTimes$.next(value);
    }
    get disabledTimes$() {
        return this._disabledTimes$;
    }
    set minYear(minYear) {
        this._minYear = minYear || (new Date().getFullYear() - 100);
    }
    get minYear() {
        return this._minYear;
    }
    set maxYear(maxYear) {
        this._maxYear = maxYear || (new Date().getFullYear() + 100);
    }
    get maxYear() {
        return this._maxYear;
    }
    set _calendarMode(value) {
        this._calendarMode$.next(value);
    }
    get timeExpanded$() {
        return this._timeExpanded$.asObservable();
    }
    get timeExpanded() {
        return this._timeExpanded$.value;
    }
    set timeExpanded(flag) {
        this._timeExpanded$.next(flag);
    }
    get rangePickerRef() {
        return this._pickerOptions.pickerRef;
    }
    setCalendarMonth(month) {
        this.calendarDate = setMonth(this.calendarDate, month);
    }
    setCalendarYear(year) {
        this.calendarDate = setYear(this.calendarDate, year);
        this._updateDisabled();
    }
    nextMonth() {
        this.calendarDate = addMonths(this.calendarDate, 1);
    }
    prevMonth() {
        this.calendarDate = subMonths(this.calendarDate, 1);
    }
    setCalendarMode(mode) {
        this._calendarMode = mode;
    }
    _initCalendar(options) {
        var _a;
        this._pickerOptions = Object.assign({}, options);
        this.view = options.view;
        switch (this.view) {
            case PickerViewType.Week:
                {
                    this.period = options.modelValue;
                    this.calendarDate = ((_a = options.modelValue) === null || _a === void 0 ? void 0 : _a.from) || new Date();
                }
                break;
            case PickerViewType.MonthRange:
                {
                    this.calendarDate = options.modelValue || new Date();
                }
                break;
            default: {
                this.model = options.modelValue;
                this.calendarDate = options.modelValue || new Date();
            }
        }
        this._calendarMode = options.view;
        this.minYear = options.minYear;
        this.maxYear = options.maxYear;
        this.minDate = options.minDate;
        this.maxDate = options.maxDate;
        this.startOfDay = options.startOfDay;
        this.minutes = options.minutes === undefined
            ? true
            : options.minutes;
        if (!isDate(options.seedDate) || !isValid(options.seedDate)) {
            this.seedDate = new Date((new Date().getFullYear()), 0, 1);
        }
        else {
            this.seedDate = options.seedDate;
        }
        this.periodWeeks = options.periodWeeks;
        this._updateDisabledDays();
    }
    _updateDisabled() {
        this._updateDisabledDays();
        this._updateDisabledTimes();
    }
    _updateDisabledDays() {
        if (this._pickerOptions.rangeType) {
            if (this._pickerOptions.rangeType === 'to') {
                this.disabledDays = getDisabledDays(this.minDate, this.maxDate, this.minYear, this.maxYear);
            }
        }
        else {
            this.disabledDays = getDisabledDays(this.minDate, this.maxDate, this.minYear, this.maxYear);
        }
    }
    _updateDisabledTimes() {
        const pickerView = this.view;
        if (pickerView !== PickerViewType.DateTime && pickerView !== PickerViewType.Time) {
            return;
        }
        if (this._pickerOptions.rangeType) {
            if (this._pickerOptions.rangeType === 'to') {
                this.disabledTimes = getDisabledTimes(this.model, this._pickerOptions.pickerRef);
            }
        }
        else {
            this.disabledTimes = getDisabledTimes(this.model, this._pickerOptions.pickerRef);
        }
    }
}

const MONTHS$1 = [
    { value: 0, name: 'January', abr: 'Jan' },
    { value: 1, name: 'February', abr: 'Feb' },
    { value: 2, name: 'March', abr: 'Mar' },
    { value: 3, name: 'April', abr: 'Apr' },
    { value: 4, name: 'May', abr: 'May' },
    { value: 5, name: 'June', abr: 'June' },
    { value: 6, name: 'July', abr: 'July' },
    { value: 7, name: 'August', abr: 'Aug' },
    { value: 8, name: 'September', abr: 'Sept' },
    { value: 9, name: 'October', abr: 'Oct' },
    { value: 10, name: 'November', abr: 'Nov' },
    { value: 11, name: 'December', abr: 'Dec' }
];

function isMonthDisabled(date, disabledDays) {
    const startMonth = startOfMonth(date);
    const endMonth = endOfMonth(date);
    return isRangeDisabled(disabledDays, startMonth, endMonth);
}

class FsDatePickerMobileHeaderComponent {
    constructor(_elRef) {
        this._elRef = _elRef;
        this.monthChange = new EventEmitter();
        this.yearChange = new EventEmitter();
        this.goNextMonth = new EventEmitter();
        this.goPrevMonth = new EventEmitter();
        this.viewModeChange = new EventEmitter();
        this.now = new Date();
        this.monthNow = this.now.getMonth();
        this.yearNow = this.now.getFullYear();
        this.yearsList = [];
        this.monthList = [];
    }
    get calendarMonth() {
        var _a;
        return (_a = this.calendarDate) === null || _a === void 0 ? void 0 : _a.getMonth();
    }
    get calendarYear() {
        var _a;
        return (_a = this.calendarDate) === null || _a === void 0 ? void 0 : _a.getFullYear();
    }
    get calendarDay() {
        var _a;
        return (_a = this.calendarDate) === null || _a === void 0 ? void 0 : _a.getDate();
    }
    ngOnChanges(changes) {
    }
    ngAfterViewInit() {
        this._createMonthsList();
        this._createYearsList();
    }
    selectMonth(month) {
        this.monthChange.emit(month);
        this.setViewMode('date');
    }
    selectYear(year) {
        this.yearChange.emit(year);
        this.setViewMode('date');
    }
    setViewMode(mode) {
        this.viewModeChange.emit(mode);
        if (mode === 'year') {
            this._scrollToSelectedYear();
        }
    }
    nextMonth() {
        this.goNextMonth.emit();
    }
    prevMonth() {
        this.goPrevMonth.emit();
    }
    _createYearsList() {
        this.yearsList = [];
        for (let y = this.minYear; y < this.maxYear; y++) {
            const year = new Date().setFullYear(y);
            this.yearsList.push({ value: y, disabled: this._isYearDisabled(year) });
        }
    }
    _createMonthsList() {
        const year = this.calendarMonth ? this.calendarYear : this.now.getFullYear();
        const checkIfMonthDisabled = (monthNumber, disabledDays) => {
            const month = new Date();
            month.setFullYear(year);
            month.setMonth(monthNumber);
            return isMonthDisabled(month, disabledDays);
        };
        this.monthList = [];
        for (const item of MONTHS$1) {
            const monthItem = Object.assign(Object.assign({}, item), { disabled: checkIfMonthDisabled(item.value, this.disabledDays) });
            this.monthList.push(monthItem);
        }
    }
    _isYearDisabled(date) {
        const startYear = startOfYear(date);
        const endYear = endOfYear(date);
        return isRangeDisabled(this.disabledDays, startYear, endYear);
    }
    _scrollToSelectedYear() {
        setTimeout(() => {
            const years = this._elRef.nativeElement.querySelector('.years');
            const selected = years.querySelector('.year.selected');
            if (selected) {
                years.scrollTop = selected.offsetTop;
            }
        }, 50);
    }
}
FsDatePickerMobileHeaderComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerMobileHeaderComponent, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
FsDatePickerMobileHeaderComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: FsDatePickerMobileHeaderComponent, selector: "fs-date-picker-mobile-header", inputs: { viewMode: "viewMode", minYear: "minYear", maxYear: "maxYear", disabledDays: "disabledDays", calendarDate: "calendarDate" }, outputs: { monthChange: "monthChange", yearChange: "yearChange", goNextMonth: "goNextMonth", goPrevMonth: "goPrevMonth", viewModeChange: "viewModeChange" }, usesOnChanges: true, ngImport: i0, template: "<div class=\"months\" *ngIf=\"viewMode == 'month'\">\n  <div\n    *ngFor=\"let month of monthList\"\n    (click)=\"selectMonth(month.value)\"\n    class=\"month\"\n    [ngClass]=\"{\n        now: monthNow == month.value,\n        selected: calendarMonth === month.value,\n        disabled: month.disabled\n      }\">\n    <div class=\"tile-content\">{{ month.abr }}</div>\n  </div>\n</div>\n\n<div class=\"years\" *ngIf=\"viewMode == 'year'\">\n  <ng-container *ngFor=\"let year of yearsList;\">\n    <div\n      class=\"year data-year-{{ year.value }}\"\n      (click)=\"selectYear(year.value)\"\n      [class.now]=\"yearNow == year.value\"\n      [class.selected]=\"calendarYear === year.value\"\n      [class.disabled]=\"year.disabled\">\n      <div class=\"tile-content\">{{ year.value }}</div>\n    </div>\n  </ng-container>\n  <div class=\"clear\"></div>\n</div>\n", styles: [".months{width:350px}.month-year{height:auto;padding:0 15px;justify-content:center}\n"], directives: [{ type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerMobileHeaderComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'fs-date-picker-mobile-header',
                    templateUrl: './header.component.html',
                    styleUrls: [
                        './header.component.scss',
                    ],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { viewMode: [{
                type: Input
            }], minYear: [{
                type: Input
            }], maxYear: [{
                type: Input
            }], disabledDays: [{
                type: Input
            }], calendarDate: [{
                type: Input
            }], monthChange: [{
                type: Output
            }], yearChange: [{
                type: Output
            }], goNextMonth: [{
                type: Output
            }], goPrevMonth: [{
                type: Output
            }], viewModeChange: [{
                type: Output
            }] } });

class FsDatePickerMobileHeaderMonthRangeComponent {
    constructor(_elRef) {
        this._elRef = _elRef;
    }
}
FsDatePickerMobileHeaderMonthRangeComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerMobileHeaderMonthRangeComponent, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
FsDatePickerMobileHeaderMonthRangeComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: FsDatePickerMobileHeaderMonthRangeComponent, selector: "fs-date-picker-mobile-header-month-range", inputs: { rangeFrom: "rangeFrom", rangeTo: "rangeTo" }, ngImport: i0, template: "<ng-container *ngIf=\"rangeFrom || rangeTo else notSelected\">\n  <ng-container *ngIf=\"rangeFrom else notSelected\">\n    {{ rangeFrom | fsDateFormat: 'day-date' }}\n  </ng-container>\n  &nbsp;\n  <ng-container *ngIf=\"rangeTo\">\n    <mat-icon>arrow_forward</mat-icon>&nbsp;\n    {{ rangeTo | fsDateFormat: 'day-date' }}\n  </ng-container>\n</ng-container>\n\n\n<ng-template #notSelected>\n  Not Selected\n</ng-template>\n", styles: [":host{display:flex;justify-content:center;align-items:center}\n"], components: [{ type: i1$1.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }], directives: [{ type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "fsDateFormat": i3.FsDateFormatPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerMobileHeaderMonthRangeComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'fs-date-picker-mobile-header-month-range',
                    templateUrl: './header-month-range.component.html',
                    styleUrls: [
                        './header-month-range.component.scss',
                    ],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { rangeFrom: [{
                type: Input
            }], rangeTo: [{
                type: Input
            }] } });

class FsDatePickerVirtualScrollCalendarComponent {
    constructor(_el, _bottomSheetRef, _scrollStrategy) {
        this._el = _el;
        this._bottomSheetRef = _bottomSheetRef;
        this._scrollStrategy = _scrollStrategy;
        this.autoClose = true;
        this.dataSource = new FsCalendarDataSource();
        this._destroy$ = new Subject();
    }
    get dialogRef() {
        return this._dialogRef;
    }
    get rangePickerRef() {
        return this.datePickerModel.rangePickerRef;
    }
    ngOnInit() {
        this._scrollStrategy.setInitialDate(this.datePickerModel.model || new Date());
        this._scrollToClosestMonth();
        if (this.parentTabGroup) {
            this._listenTabIndexChange();
        }
    }
    ngOnChanges(changes) {
        var _a, _b;
        if (((_a = changes.datePickerModel) === null || _a === void 0 ? void 0 : _a.currentValue)
            && ((_b = changes.datePickerModel) === null || _b === void 0 ? void 0 : _b.firstChange)
            && this.datePickerModel.view === 'monthrange') {
            this._initMonthRangeModels();
        }
    }
    ngOnDestroy() {
        this._destroy$.next();
        this._destroy$.complete();
    }
    dateChanged(date) {
        if (this.datePickerModel.view !== 'monthrange') {
            this.datePickerModel.model = date;
            this.close();
        }
        else {
            this.monthRangeChange(date);
        }
    }
    monthRangeChange(date) {
        const rangeRef = this.rangePickerRef;
        const { startDate, endDate } = rangeRef;
        if (!startDate && !endDate) {
            rangeRef.updateStartDate(date);
        }
        else if (startDate && !endDate) {
            if (isBefore(date, startDate)) {
                rangeRef.updateStartDate(date);
                rangeRef.updateEndDate(null);
            }
            else {
                rangeRef.updateEndDate(date);
            }
        }
        else if (startDate && endDate) {
            rangeRef.updateStartDate(date);
            rangeRef.updateEndDate(null);
        }
    }
    close() {
        if (this.autoClose) {
            this._bottomSheetRef.dismiss();
        }
    }
    scollIndexChange(activeIndex) {
        this._activeScrollIndex = activeIndex;
    }
    _scrollToClosestMonth() {
        const touchstart$ = fromEvent(this.virtualScroll.elementRef.nativeElement, 'touchstart');
        const touchend$ = fromEvent(this.virtualScroll.elementRef.nativeElement, 'touchend');
        const scrollDebounceTime = 80;
        touchstart$
            .pipe(switchMap(() => touchend$), switchMap(() => race(this.virtualScroll.elementScrolled(), timer(scrollDebounceTime)).pipe(debounceTime(scrollDebounceTime * 2), take(1), takeUntil(touchstart$))), takeUntil(this._destroy$))
            .subscribe(() => {
            this.virtualScroll.scrollToIndex(this._activeScrollIndex, 'smooth');
        });
    }
    _initMonthRangeModels() {
        this.modelFrom$ = this.datePickerModel
            .rangePickerRef
            .startDate$
            .pipe(shareReplay());
        this.modelTo$ = this.datePickerModel
            .rangePickerRef
            .endDate$
            .pipe(shareReplay());
    }
    _listenTabIndexChange() {
        this.parentTabGroup.selectedIndexChange
            .pipe(filter((index) => index === this.parentTabIndex), delay(0), takeUntil(this._destroy$))
            .subscribe(() => {
            this._scrollStrategy.scrollToDate(this.datePickerModel.model || new Date());
        });
    }
}
FsDatePickerVirtualScrollCalendarComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerVirtualScrollCalendarComponent, deps: [{ token: i0.ElementRef }, { token: i1$2.MatBottomSheetRef }, { token: VIRTUAL_SCROLL_STRATEGY }], target: i0.ɵɵFactoryTarget.Component });
FsDatePickerVirtualScrollCalendarComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: FsDatePickerVirtualScrollCalendarComponent, selector: "fs-datepicker-mobile-scroll-calendar", inputs: { datePickerModel: "datePickerModel", autoClose: "autoClose", parentTabGroup: "parentTabGroup", parentTabIndex: "parentTabIndex" }, providers: [
        {
            provide: VIRTUAL_SCROLL_STRATEGY,
            useClass: CalendarScrollStrategy,
        },
    ], viewQueries: [{ propertyName: "virtualScroll", first: true, predicate: CdkVirtualScrollViewport, descendants: true, static: true }], usesOnChanges: true, ngImport: i0, template: "<div class=\"header\">\n  <ng-container *ngIf=\"datePickerModel.view !== 'monthrange' else monthRangeHeader\">\n    <fs-date-picker-mobile-header\n      [calendarDate]=\"datePickerModel.model$ | async\"\n      [minYear]=\"datePickerModel.minYear\"\n      [maxYear]=\"datePickerModel.maxYear\"\n      [viewMode]=\"datePickerModel.calendarMode$ | async\"\n      [disabledDays]=\"datePickerModel.disabledDays$ | async\">\n    </fs-date-picker-mobile-header>\n  </ng-container>\n\n  <ng-template #monthRangeHeader>\n    <fs-date-picker-mobile-header-month-range\n      [rangeFrom]=\"modelFrom$ | async\"\n      [rangeTo]=\"modelTo$ | async\">\n    </fs-date-picker-mobile-header-month-range>\n  </ng-template>\n</div>\n\n<cdk-virtual-scroll-viewport class=\"view-port\" (scrolledIndexChange)=\"scollIndexChange($event)\">\n  <div *cdkVirtualFor=\"let item of dataSource\">\n    <div class=\"month-header\">\n      {{ item | fsDateFormat: 'full-date-dayless' }}\n    </div>\n    <fs-date-picker-calendar\n      [date]=\"datePickerModel.model$ | async\"\n      [drawMonth]=\"item\"\n      [rangeFrom]=\"modelFrom$ | async\"\n      [rangeTo]=\"modelTo$ | async\"\n      [highlightStartDate]=\"modelFrom$ | async\"\n      [highlightEndDate]=\"modelTo$ | async\"\n      [dateMode]=\"datePickerModel.calendarMode$ | async\"\n      [disabledDays]=\"datePickerModel.disabledDays$ | async\"\n      [hideExtraDays]=\"true\"\n      [period]=\"datePickerModel.period\"\n      [seedDate]=\"datePickerModel.seedDate\"\n      [periodWeeks]=\"datePickerModel.periodWeeks\"\n      (change)=\"dateChanged($event)\">\n    </fs-date-picker-calendar>\n  </div>\n</cdk-virtual-scroll-viewport>\n", styles: [".view-port{height:380px;overflow-y:auto}.month-header{text-align:center;line-height:50px;font-size:110%;font-weight:500}cdk-virtual-scroll-viewport::-webkit-scrollbar{width:0}\n"], components: [{ type: FsDatePickerMobileHeaderComponent, selector: "fs-date-picker-mobile-header", inputs: ["viewMode", "minYear", "maxYear", "disabledDays", "calendarDate"], outputs: ["monthChange", "yearChange", "goNextMonth", "goPrevMonth", "viewModeChange"] }, { type: FsDatePickerMobileHeaderMonthRangeComponent, selector: "fs-date-picker-mobile-header-month-range", inputs: ["rangeFrom", "rangeTo"] }, { type: i4.CdkVirtualScrollViewport, selector: "cdk-virtual-scroll-viewport", inputs: ["orientation", "appendOnly"], outputs: ["scrolledIndexChange"] }, { type: FsDatePickerCalendarComponent, selector: "fs-date-picker-calendar", inputs: ["date", "period", "rangeFrom", "rangeTo", "highlightStartDate", "highlightEndDate", "dateMode", "disabledDays", "drawMonth", "seedDate", "periodWeeks", "hideExtraDays"], outputs: ["change", "rangeChange", "periodChange", "hoverDay"] }], directives: [{ type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i4.CdkVirtualForOf, selector: "[cdkVirtualFor][cdkVirtualForOf]", inputs: ["cdkVirtualForOf", "cdkVirtualForTrackBy", "cdkVirtualForTemplate", "cdkVirtualForTemplateCacheSize"] }], pipes: { "async": i1.AsyncPipe, "fsDateFormat": i3.FsDateFormatPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerVirtualScrollCalendarComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'fs-datepicker-mobile-scroll-calendar',
                    templateUrl: './virtual-scroll-calendar.component.html',
                    styleUrls: ['./virtual-scroll-calendar.component.scss'],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [
                        {
                            provide: VIRTUAL_SCROLL_STRATEGY,
                            useClass: CalendarScrollStrategy,
                        },
                    ],
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i1$2.MatBottomSheetRef }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [VIRTUAL_SCROLL_STRATEGY]
                }] }]; }, propDecorators: { datePickerModel: [{
                type: Input
            }], autoClose: [{
                type: Input
            }], parentTabGroup: [{
                type: Input
            }], parentTabIndex: [{
                type: Input
            }], virtualScroll: [{
                type: ViewChild,
                args: [CdkVirtualScrollViewport, { static: true }]
            }] } });

class FsMobileTimePickerComponent {
    constructor(_bottomSheet) {
        this._bottomSheet = _bottomSheet;
        this.autoClose = true;
        this.showNotSelected = true;
    }
    dateChanged(date) {
        this.datePickerModel.model = date;
    }
    close() {
        if (this.autoClose) {
            this._bottomSheet.dismiss();
        }
    }
}
FsMobileTimePickerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsMobileTimePickerComponent, deps: [{ token: i1$2.MatBottomSheetRef }], target: i0.ɵɵFactoryTarget.Component });
FsMobileTimePickerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: FsMobileTimePickerComponent, selector: "fs-datepicker-mobile-timepicker", inputs: { datePickerModel: "datePickerModel", autoClose: "autoClose", showNotSelected: "showNotSelected" }, ngImport: i0, template: "<fs-date-picker-time\n  class=\"fs-date-picker-dialog\"\n  [date]=\"datePickerModel.model$ | async\"\n  [minutes]=\"datePickerModel.minutes\"\n  [disabledTimes]=\"datePickerModel.disabledTimes$ | async\"\n  [expanded]=\"datePickerModel.timeExpanded$ | async\"\n  [showNotSelected]=\"showNotSelected\"\n  (onChange)=\"dateChanged($event)\"\n></fs-date-picker-time>\n", styles: [":host ::ng-deep .month-year.time{display:none}\n"], components: [{ type: FsDatePickerTimeComponent, selector: "fs-date-picker-time", inputs: ["date", "disabledMinutes", "disabledHours", "disabledTimes", "expanded", "minutes", "showNotSelected"], outputs: ["onChange"] }], pipes: { "async": i1.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsMobileTimePickerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'fs-datepicker-mobile-timepicker',
                    templateUrl: './time-picker.component.html',
                    styleUrls: ['./time-picker.component.scss'],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1$2.MatBottomSheetRef }]; }, propDecorators: { datePickerModel: [{
                type: Input
            }], autoClose: [{
                type: Input
            }], showNotSelected: [{
                type: Input
            }] } });

class FDatePickerMobileDatetimePickerComponent {
    constructor() {
        this.tabChange = new EventEmitter();
    }
    selectedDateTimeTabChange(index) {
        this.tabChange.emit(index);
    }
}
FDatePickerMobileDatetimePickerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FDatePickerMobileDatetimePickerComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
FDatePickerMobileDatetimePickerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: FDatePickerMobileDatetimePickerComponent, selector: "fs-datepicker-mobile-datetime-picker", inputs: { datePickerModel: "datePickerModel" }, outputs: { tabChange: "tabChange" }, ngImport: i0, template: "<mat-tab-group mat-stretch-tabs\n               dynamicHeight\n               (selectedIndexChange)=\"selectedDateTimeTabChange($event)\"\n               #tabGroup>\n  <mat-tab>\n    <ng-template mat-tab-label>\n      <ng-container *ngIf=\"datePickerModel.model$ | async as model; else noDate\">\n        {{ model | date: 'MMM d, yyyy'}}\n      </ng-container>\n      <ng-template #noDate>Date</ng-template>\n    </ng-template>\n\n    <fs-datepicker-mobile-scroll-calendar [datePickerModel]=\"datePickerModel\"\n                                          [autoClose]=\"false\"\n                                          [parentTabGroup]=\"tabGroup\"\n                                          [parentTabIndex]=\"0\">\n    </fs-datepicker-mobile-scroll-calendar>\n\n  </mat-tab>\n\n  <mat-tab>\n    <ng-template mat-tab-label>\n      <ng-container *ngIf=\"datePickerModel.model$ | async as model; else noTime\">\n        {{ model | date: 'h:mm'}}\n        {{ model | date: 'aaa' | lowercase}}\n      </ng-container>\n      <ng-template #noTime>Time</ng-template>\n    </ng-template>\n\n    <fs-datepicker-mobile-timepicker [datePickerModel]=\"datePickerModel\"\n                                     [autoClose]=\"false\"\n                                     [showNotSelected]=\"false\">\n    </fs-datepicker-mobile-timepicker>\n  </mat-tab>\n</mat-tab-group>\n", styles: [""], components: [{ type: i1$3.MatTabGroup, selector: "mat-tab-group", inputs: ["color", "disableRipple"], exportAs: ["matTabGroup"] }, { type: i1$3.MatTab, selector: "mat-tab", inputs: ["disabled", "label", "aria-label", "aria-labelledby"], exportAs: ["matTab"] }, { type: FsDatePickerVirtualScrollCalendarComponent, selector: "fs-datepicker-mobile-scroll-calendar", inputs: ["datePickerModel", "autoClose", "parentTabGroup", "parentTabIndex"] }, { type: FsMobileTimePickerComponent, selector: "fs-datepicker-mobile-timepicker", inputs: ["datePickerModel", "autoClose", "showNotSelected"] }], directives: [{ type: i1$3.MatTabLabel, selector: "[mat-tab-label], [matTabLabel]" }, { type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i1.AsyncPipe, "date": i1.DatePipe, "lowercase": i1.LowerCasePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FDatePickerMobileDatetimePickerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'fs-datepicker-mobile-datetime-picker',
                    templateUrl: './date-time-picker.component.html',
                    styleUrls: ['./date-time-picker.component.scss'],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], propDecorators: { datePickerModel: [{
                type: Input
            }], tabChange: [{
                type: Output
            }] } });

class FsMobileCalendarDialogComponent {
    constructor(_data, _bottomSheetRef) {
        this._data = _data;
        this._bottomSheetRef = _bottomSheetRef;
        this.selectedDateTimeTab = 0;
        this._dialogRef = this._data.dateDialogRef;
    }
    get datePickerModel() {
        return this._dialogRef.pickerModel;
    }
    get dialogRef() {
        return this._dialogRef;
    }
    toggleTimeExpand() {
        this.datePickerModel.timeExpanded = !this.datePickerModel.timeExpanded;
    }
    selectedDateTimeTabChange(index) {
        this.selectedDateTimeTab = index;
    }
    close() {
        this._bottomSheetRef.dismiss();
    }
    datetimeTabChanged(index) {
        this.selectedDateTimeTab = index;
    }
}
FsMobileCalendarDialogComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsMobileCalendarDialogComponent, deps: [{ token: MAT_BOTTOM_SHEET_DATA }, { token: i1$2.MatBottomSheetRef }], target: i0.ɵɵFactoryTarget.Component });
FsMobileCalendarDialogComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: FsMobileCalendarDialogComponent, selector: "ng-component", ngImport: i0, template: "<div class=\"fs-date-picker-dialog\">\n  <div class=\"calendar-container\">\n    <ng-container [ngSwitch]=\"datePickerModel.view\">\n      <ng-template [ngSwitchCase]=\"'date'\">\n        <fs-datepicker-mobile-scroll-calendar [datePickerModel]=\"datePickerModel\">\n        </fs-datepicker-mobile-scroll-calendar>\n      </ng-template>\n\n      <ng-template [ngSwitchCase]=\"'week'\">\n        <fs-datepicker-mobile-scroll-calendar [datePickerModel]=\"datePickerModel\">\n        </fs-datepicker-mobile-scroll-calendar>\n      </ng-template>\n\n      <ng-template [ngSwitchCase]=\"'monthrange'\">\n        <fs-datepicker-mobile-scroll-calendar [datePickerModel]=\"datePickerModel\">\n        </fs-datepicker-mobile-scroll-calendar>\n      </ng-template>\n\n      <ng-template [ngSwitchCase]=\"'time'\">\n        <fs-datepicker-mobile-timepicker [datePickerModel]=\"datePickerModel\">\n        </fs-datepicker-mobile-timepicker>\n      </ng-template>\n\n      <ng-template [ngSwitchCase]=\"'datetime'\">\n        <fs-datepicker-mobile-datetime-picker [datePickerModel]=\"datePickerModel\"\n                                              (tabChange)=\"datetimeTabChanged($event)\">\n        </fs-datepicker-mobile-datetime-picker>\n      </ng-template>\n    </ng-container>\n  </div>\n</div>\n\n<mat-nav-list class=\"actions\">\n  <ng-container *ngIf=\"datePickerModel.minutes\n                    && (\n                      (datePickerModel.isDateTimeView && selectedDateTimeTab !== 0)\n                      || datePickerModel.isTimeView\n                    )\">\n    <mat-list-item (click)=\"toggleTimeExpand()\">\n      <button type=\"button\"\n              mat-button\n              class=\"button-more\">\n        <ng-container *ngIf=\"!(datePickerModel.timeExpanded$ | async); else lessMinutes\">\n          More Minutes\n        </ng-container>\n        <ng-template #lessMinutes>\n          Less Minutes\n        </ng-template>\n      </button>\n    </mat-list-item>\n\n  </ng-container>\n\n  <mat-list-item (click)=\"close()\">\n    <button mat-icon-button color=\"primary\">\n      Done\n    </button>\n  </mat-list-item>\n</mat-nav-list>\n", styles: ["fs-date-picker-calendar{display:block}:host ::ng-deep .actions .mat-list-item-content{justify-content:center}.example-viewport{height:328px}\n"], components: [{ type: FsDatePickerVirtualScrollCalendarComponent, selector: "fs-datepicker-mobile-scroll-calendar", inputs: ["datePickerModel", "autoClose", "parentTabGroup", "parentTabIndex"] }, { type: FsMobileTimePickerComponent, selector: "fs-datepicker-mobile-timepicker", inputs: ["datePickerModel", "autoClose", "showNotSelected"] }, { type: FDatePickerMobileDatetimePickerComponent, selector: "fs-datepicker-mobile-datetime-picker", inputs: ["datePickerModel"], outputs: ["tabChange"] }, { type: i5.MatNavList, selector: "mat-nav-list", inputs: ["disableRipple", "disabled"], exportAs: ["matNavList"] }, { type: i5.MatListItem, selector: "mat-list-item, a[mat-list-item], button[mat-list-item]", inputs: ["disableRipple", "disabled"], exportAs: ["matListItem"] }, { type: i4$1.MatButton, selector: "button[mat-button], button[mat-raised-button], button[mat-icon-button],             button[mat-fab], button[mat-mini-fab], button[mat-stroked-button],             button[mat-flat-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }], directives: [{ type: i1.NgSwitch, selector: "[ngSwitch]", inputs: ["ngSwitch"] }, { type: i1.NgSwitchCase, selector: "[ngSwitchCase]", inputs: ["ngSwitchCase"] }, { type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i1.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsMobileCalendarDialogComponent, decorators: [{
            type: Component,
            args: [{
                    templateUrl: './mobile-dialog.component.html',
                    styleUrls: ['./mobile-dialog.component.scss'],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [MAT_BOTTOM_SHEET_DATA]
                }] }, { type: i1$2.MatBottomSheetRef }]; } });

class FsDatePickerOverlayRef {
    constructor() {
        this._activeOverlayRef$ = new BehaviorSubject(null);
    }
    get destroy$() {
        return this._activeOverlayRef$
            .pipe(filter((ref) => !!ref), switchMap((ref) => {
            if (ref instanceof OverlayRef) {
                return merge(ref.detachments(), ref.backdropClick());
            }
            else {
                return merge(ref.afterDismissed(), ref.backdropClick());
            }
        }));
    }
    get activeOverlayRef() {
        return this._activeOverlayRef$.getValue();
    }
    setActiveOverlay(ref) {
        this._activeOverlayRef$.next(ref);
    }
    close() {
        var _a, _b, _c;
        if (this.activeOverlayRef instanceof OverlayRef) {
            (_a = this.activeOverlayRef) === null || _a === void 0 ? void 0 : _a.detach();
            (_b = this.activeOverlayRef) === null || _b === void 0 ? void 0 : _b.dispose();
        }
        if (this.activeOverlayRef instanceof MatBottomSheetRef) {
            (_c = this.activeOverlayRef) === null || _c === void 0 ? void 0 : _c.dismiss();
        }
        this.setActiveOverlay(null);
    }
}

class FsDatePickerDialogRef {
    constructor(_pickerOptions) {
        this._pickerOptions = _pickerOptions;
        this._overlayRef = new FsDatePickerOverlayRef();
        this._close$ = new Subject();
        /**
         * Visual components. Can be changed by summary widget but only if _view allowed to do this.
         */
        this._componentsDefault = {
            calendarStart: false,
            calendarEnd: false,
            timeStart: false,
            timeEnd: false
        };
        this._components = null;
        this._init();
    }
    get pickerModel() {
        return this._dialogModel;
    }
    get options() {
        return this._pickerOptions;
    }
    get value$() {
        return this._value$;
    }
    get pickerOverlayRef() {
        return this._overlayRef;
    }
    get close$() {
        return this._close$.asObservable();
    }
    get components() {
        return this._components;
    }
    updateValue(value) {
        this._dialogModel.model = value;
    }
    close() {
        this.pickerOverlayRef.close();
        this._close$.next();
        this._close$.complete();
    }
    _init() {
        this._initComponents();
        this._initModel();
    }
    _initModel() {
        this._dialogModel = new FsDatePickerDialogModel(this._pickerOptions);
        this._initValue();
    }
    _initValue() {
        if (this.options.view === 'week') {
            this._value$ = this._dialogModel.period$
                .pipe(skip(1));
        }
        else {
            this._value$ = this._dialogModel.model$
                .pipe(skip(1));
        }
    }
    _initComponents() {
        const value = Object.assign(Object.assign({}, this._componentsDefault), this._pickerOptions.components || {});
        const tempData = Object.assign({}, value);
        const allowable = [];
        if (['week', 'date', 'datetime', 'monthrange'].indexOf(this._pickerOptions.view) !== -1) {
            allowable.push('calendarStart');
            allowable.push('calendarEnd');
        }
        if (['time', 'datetime'].indexOf(this._pickerOptions.view) !== -1) {
            allowable.push('timeStart');
            allowable.push('timeEnd');
        }
        forEach(tempData, (item, index) => {
            tempData[index] = allowable.indexOf(index) !== -1 ? item : false;
        });
        // Updating components only if all value object is valid
        if (isEqual(value, tempData)) {
            this._components = value;
        }
    }
}

const MONTHS = [
    { value: 0, name: 'January', abr: 'Jan' },
    { value: 1, name: 'February', abr: 'Feb' },
    { value: 2, name: 'March', abr: 'Mar' },
    { value: 3, name: 'April', abr: 'Apr' },
    { value: 4, name: 'May', abr: 'May' },
    { value: 5, name: 'June', abr: 'June' },
    { value: 6, name: 'July', abr: 'July' },
    { value: 7, name: 'August', abr: 'Aug' },
    { value: 8, name: 'September', abr: 'Sept' },
    { value: 9, name: 'October', abr: 'Oct' },
    { value: 10, name: 'November', abr: 'Nov' },
    { value: 11, name: 'December', abr: 'Dec' }
];

class FsDateScrollPickerDialogComponent {
    constructor(element, _cdRef, _renderer, _document) {
        this.element = element;
        this._cdRef = _cdRef;
        this._renderer = _renderer;
        this._document = _document;
        this.changed = new EventEmitter();
        this.years = [];
        this.months = [];
        this.maxDay = 0;
    }
    ngOnInit() {
        const modelValue = this.model;
        this._generateYearsArray();
        this._generateMonthArray();
        this._generateDaysArray();
        if (modelValue && isValid(modelValue)) {
            this._setDate(modelValue);
        }
        else {
            const date = new Date();
            if (!this.showDay) {
                date.setDate(1);
            }
            if (!this.showMonth) {
                date.setMonth(1);
            }
            if (!this.showYear) {
                date.setFullYear(0);
            }
            this._setDate(date);
        }
        this._pullToRefreshDisable();
    }
    ngOnDestroy() {
        this._pullToRefreshDefault();
    }
    _setDate(date) {
        if (date) {
            this.day = date.getDate();
            this.year = date.getFullYear();
            this.month = date.getMonth();
        }
    }
    _getMonth(month) {
        return this.months.find(item => {
            return month === item.value;
        });
    }
    change() {
        if (!this.year) {
            this.year = this.showYear ? this.years[0] : 0;
        }
        if (!this.month) {
            this.month = this.months[0].value;
        }
        if (!this.day) {
            this.day = 1;
        }
        const daysInMonth = getDaysInMonth(new Date(this.year, this.month));
        if (this.day > daysInMonth) {
            this.day = daysInMonth;
        }
        const date = new Date(this.year, this.month, this.day);
        this.changed.emit(date);
        this._cdRef.markForCheck();
    }
    changeMonth() {
        this._generateDaysArray();
        this.change();
    }
    changeYear() {
        this._generateDaysArray();
        if (this.maxDate) {
            this._generateMonthArray();
        }
        this.change();
    }
    _generateDaysArray() {
        this.maxDay = 0;
        const maxDate = this.maxDate;
        const maxDay = maxDate && maxDate.getDate();
        const maxMonth = maxDate && maxDate.getMonth();
        const maxYear = maxDate && maxDate.getFullYear();
        if (this.month) {
            if (maxDay && maxMonth == this.month.value && maxYear === this.year) {
                this.maxDay = maxDay;
            }
            else {
                const daysInMonth = getDaysInMonth(new Date(this.year, this.month));
                this.maxDay = daysInMonth;
            }
        }
        if (!this.maxDay) {
            this.maxDay = 31;
        }
    }
    _generateMonthArray() {
        this.months = MONTHS;
    }
    _generateYearsArray() {
        let minYear = this.minYear;
        let maxYear = this.maxYear;
        if (!maxYear) {
            const today = new Date();
            maxYear = today.getFullYear();
        }
        for (minYear; minYear <= maxYear; minYear++) {
            this.years.push({ name: minYear, value: minYear });
        }
    }
    _pullToRefreshDisable() {
        this._renderer.addClass(this._document.body, 'fs-date-picker-prevent-pull-to-refresh');
    }
    _pullToRefreshDefault() {
        this._renderer.removeClass(this._document.body, 'fs-date-picker-prevent-pull-to-refresh');
    }
}
FsDateScrollPickerDialogComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDateScrollPickerDialogComponent, deps: [{ token: i0.ElementRef }, { token: i0.ChangeDetectorRef }, { token: i0.Renderer2 }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Component });
FsDateScrollPickerDialogComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: FsDateScrollPickerDialogComponent, selector: "fs-date-scroll-picker", inputs: { model: "model", showMonth: "showMonth", showDay: "showDay", showYear: "showYear", minYear: "minYear", maxYear: "maxYear", maxDate: "maxDate" }, outputs: { changed: "changed" }, ngImport: i0, template: "<div class=\"scroll-pickers\">\n  <fs-scroll-picker\n    *ngIf=\"showMonth\"\n    class=\"month\"\n    [values]=\"months\"\n    name=\"month\"\n    [(ngModel)]=\"month\"\n    (ngModelChange)=\"changeMonth()\">\n  </fs-scroll-picker>\n\n  <fs-scroll-picker\n      *ngIf=\"showDay\"\n      class=\"day\"\n      [valuesMin]=\"1\"\n      [valuesMax]=\"maxDay\"\n      name=\"day\"\n      [(ngModel)]=\"day\"\n      (ngModelChange)=\"change()\">\n  </fs-scroll-picker>\n\n  <fs-scroll-picker\n      *ngIf=\"showYear\"\n      class=\"year\"\n      [values]=\"years\"\n      name=\"year\"\n      [(ngModel)]=\"year\"\n      (ngModelChange)=\"changeYear()\">\n  </fs-scroll-picker>\n</div>", styles: [".scroll-pickers{display:flex;flex-direction:row;justify-content:center;background:#fff}.scroll-pickers fs-scroll-picker.day{width:80px}.scroll-pickers fs-scroll-picker.month{width:150px}.scroll-pickers fs-scroll-picker.year{width:100px}\n"], components: [{ type: i1$4.ScrollPickerComponent, selector: "fs-scroll-picker", inputs: ["values", "valuesMin", "valuesMax", "width"] }], directives: [{ type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i2.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDateScrollPickerDialogComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'fs-date-scroll-picker',
                    templateUrl: './date-scroll-picker.component.html',
                    styleUrls: ['./date-scroll-picker.component.scss'],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.ChangeDetectorRef }, { type: i0.Renderer2 }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }]; }, propDecorators: { model: [{
                type: Input
            }], showMonth: [{
                type: Input
            }], showDay: [{
                type: Input
            }], showYear: [{
                type: Input
            }], minYear: [{
                type: Input
            }], maxYear: [{
                type: Input
            }], maxDate: [{
                type: Input
            }], changed: [{
                type: Output
            }] } });

class FsDateScrollPickerDesktopComponent {
    constructor(_dialogRef) {
        this._dialogRef = _dialogRef;
    }
    get dialogRef() {
        return this._dialogRef;
    }
    change(date) {
        this._date = date;
    }
    close(save = false) {
        if (save) {
            this._dialogRef.updateValue(this._date);
        }
        this._dialogRef.close();
    }
}
FsDateScrollPickerDesktopComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDateScrollPickerDesktopComponent, deps: [{ token: FsDatePickerDialogRef }], target: i0.ɵɵFactoryTarget.Component });
FsDateScrollPickerDesktopComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: FsDateScrollPickerDesktopComponent, selector: "ng-component", ngImport: i0, template: "<div class=\"fs-date-picker-dialog fs-date-picker-dialog-shadow fs-date-picker-range\" tabindex=\"0\">\n  <div class=\"wrap\">\n    <fs-date-scroll-picker [model]=\"dialogRef.pickerModel.model\"\n                           [minYear]=\"dialogRef.options.minYear\"\n                           [maxDate]=\"dialogRef.options.maxDate\"\n                           [maxYear]=\"dialogRef.options.maxYear\"\n                           [showDay]=\"dialogRef.options.showDay\"\n                           [showMonth]=\"dialogRef.options.showMonth\"\n                           [showYear]=\"dialogRef.options.showYear\"\n                           (changed)=\"change($event)\">\n    </fs-date-scroll-picker>\n\n    <div class=\"buttons\">\n      <button type=\"button\" mat-button color=\"primary\" (click)=\"close(true)\">Select</button>\n      <button type=\"button\" mat-button (click)=\"close(false)\">Cancel</button>\n    </div>\n  </div>\n</div>\n", styles: [""], components: [{ type: FsDateScrollPickerDialogComponent, selector: "fs-date-scroll-picker", inputs: ["model", "showMonth", "showDay", "showYear", "minYear", "maxYear", "maxDate"], outputs: ["changed"] }, { type: i4$1.MatButton, selector: "button[mat-button], button[mat-raised-button], button[mat-icon-button],             button[mat-fab], button[mat-mini-fab], button[mat-stroked-button],             button[mat-flat-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDateScrollPickerDesktopComponent, decorators: [{
            type: Component,
            args: [{
                    templateUrl: './date-scroll-picker-desktop.component.html',
                    styleUrls: ['./date-scroll-picker-desktop.component.scss'],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: FsDatePickerDialogRef }]; } });

class FsDateScrollPickerMobileDialogComponent {
    constructor(_data, _bottomSheetRef) {
        this._data = _data;
        this._bottomSheetRef = _bottomSheetRef;
        this._dialogRef = _data.dateDialogRef;
    }
    get dialogRef() {
        return this._dialogRef;
    }
    change(date) {
        this._date = date;
    }
    close(save = false) {
        if (save) {
            this._dialogRef.updateValue(this._date);
        }
        this._bottomSheetRef.dismiss();
    }
}
FsDateScrollPickerMobileDialogComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDateScrollPickerMobileDialogComponent, deps: [{ token: MAT_BOTTOM_SHEET_DATA }, { token: i1$2.MatBottomSheetRef }], target: i0.ɵɵFactoryTarget.Component });
FsDateScrollPickerMobileDialogComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: FsDateScrollPickerMobileDialogComponent, selector: "ng-component", ngImport: i0, template: "<div class=\"fs-date-picker-dialog fs-date-picker-range\" tabindex=\"0\">\n  <div class=\"wrap\">\n    <fs-date-scroll-picker [model]=\"dialogRef.pickerModel.model\"\n                           [minYear]=\"dialogRef.options.minYear\"\n                           [maxDate]=\"dialogRef.options.maxDate\"\n                           [maxYear]=\"dialogRef.options.maxYear\"\n                           [showDay]=\"dialogRef.options.showDay\"\n                           [showMonth]=\"dialogRef.options.showMonth\"\n                           [showYear]=\"dialogRef.options.showYear\"\n                           (changed)=\"change($event)\">\n    </fs-date-scroll-picker>\n\n    <mat-nav-list class=\"actions\">\n      <mat-list-item (click)=\"close(true)\">\n        <button mat-icon-button color=\"primary\">\n          Select\n        </button>\n      </mat-list-item>\n\n      <mat-list-item (click)=\"close(false)\">\n        <button mat-icon-button>\n          Cancel\n        </button>\n      </mat-list-item>\n    </mat-nav-list>\n  </div>\n</div>\n", styles: [":host ::ng-deep .actions .mat-list-item-content{justify-content:center}\n"], components: [{ type: FsDateScrollPickerDialogComponent, selector: "fs-date-scroll-picker", inputs: ["model", "showMonth", "showDay", "showYear", "minYear", "maxYear", "maxDate"], outputs: ["changed"] }, { type: i5.MatNavList, selector: "mat-nav-list", inputs: ["disableRipple", "disabled"], exportAs: ["matNavList"] }, { type: i5.MatListItem, selector: "mat-list-item, a[mat-list-item], button[mat-list-item]", inputs: ["disableRipple", "disabled"], exportAs: ["matListItem"] }, { type: i4$1.MatButton, selector: "button[mat-button], button[mat-raised-button], button[mat-icon-button],             button[mat-fab], button[mat-mini-fab], button[mat-stroked-button],             button[mat-flat-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDateScrollPickerMobileDialogComponent, decorators: [{
            type: Component,
            args: [{
                    templateUrl: './date-scroll-picker-mobile-dialog.component.html',
                    styleUrls: ['./date-scroll-picker-mobile-dialog.component.scss'],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [MAT_BOTTOM_SHEET_DATA]
                }] }, { type: i1$2.MatBottomSheetRef }]; } });

class FsDatePickerHeaderMonthRangeComponent {
    constructor() {
        this.goNextMonth = new EventEmitter();
        this.goPrevMonth = new EventEmitter();
    }
    get calendarMonth() {
        var _a;
        return (_a = this.calendarDate) === null || _a === void 0 ? void 0 : _a.getMonth();
    }
    get calendarYear() {
        var _a;
        return (_a = this.calendarDate) === null || _a === void 0 ? void 0 : _a.getFullYear();
    }
    get calendarDay() {
        var _a;
        return (_a = this.calendarDate) === null || _a === void 0 ? void 0 : _a.getDate();
    }
    nextMonth() {
        this.goNextMonth.emit();
    }
    prevMonth() {
        this.goPrevMonth.emit();
    }
}
FsDatePickerHeaderMonthRangeComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerHeaderMonthRangeComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
FsDatePickerHeaderMonthRangeComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: FsDatePickerHeaderMonthRangeComponent, selector: "fs-date-picker-header-month-range", inputs: { calendarDate: "calendarDate", nextCalendarDate: "nextCalendarDate" }, outputs: { goNextMonth: "goNextMonth", goPrevMonth: "goPrevMonth" }, ngImport: i0, template: "<div class=\"current-month-header month-year\">\n  <div class=\"actions\">\n    <a (click)=\"prevMonth()\">\n      <mat-icon>navigate_before</mat-icon>\n    </a>\n  </div>\n  <span class=\"month-name\">\n    {{ calendarDate | fsDateFormat: 'full-date-dayless' }}\n  </span>\n</div>\n\n\n\n<div class=\"next-month-header month-year\">\n  <span class=\"month-name\">\n    {{ nextCalendarDate | fsDateFormat: 'full-date-dayless' }}\n  </span>\n  <div class=\"actions\">\n    <a (click)=\"nextMonth()\">\n      <mat-icon>navigate_next</mat-icon>\n    </a>\n  </div>\n</div>\n", styles: [":host{display:grid;grid-template-columns:1fr 1fr;grid-column-gap:40px}.month-year{padding:0;position:relative;justify-content:center}.current-month-header .actions{left:5px;position:absolute}.next-month-header .actions{right:5px;position:absolute}\n"], components: [{ type: i1$1.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }], pipes: { "fsDateFormat": i3.FsDateFormatPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerHeaderMonthRangeComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'fs-date-picker-header-month-range',
                    templateUrl: './header-month-range.component.html',
                    styleUrls: [
                        './header-month-range.component.scss',
                    ],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], propDecorators: { calendarDate: [{
                type: Input
            }], nextCalendarDate: [{
                type: Input
            }], goNextMonth: [{
                type: Output
            }], goPrevMonth: [{
                type: Output
            }] } });

class FsMonthRangePickerComponent {
    constructor() { }
    ngOnChanges(changes) {
        var _a, _b;
        if (((_a = changes.datePickerModel) === null || _a === void 0 ? void 0 : _a.currentValue)
            && ((_b = changes.datePickerModel) === null || _b === void 0 ? void 0 : _b.firstChange)
            && this.datePickerModel.view === 'monthrange') {
            this._initMonthRangeModels();
        }
    }
    viewModeChanged(mode) {
        this.datePickerModel.setCalendarMode(mode);
    }
    monthChanged(month) {
        this.datePickerModel.setCalendarMonth(month);
    }
    yearChanged(year) {
        this.datePickerModel.setCalendarYear(year);
    }
    nextMonth() {
        this.datePickerModel.nextMonth();
    }
    prevMonth() {
        this.datePickerModel.prevMonth();
    }
    dateChanged(date) {
        const rangeRef = this.datePickerModel.rangePickerRef;
        const { startDate, endDate } = rangeRef;
        if (!startDate && !endDate) {
            rangeRef.updateStartDate(date);
        }
        else if (startDate && !endDate) {
            if (isBefore(date, startDate)) {
                rangeRef.updateStartDate(date);
                rangeRef.updateEndDate(null);
            }
            else {
                rangeRef.updateEndDate(date);
            }
        }
        else if (startDate && endDate) {
            rangeRef.updateStartDate(date);
            rangeRef.updateEndDate(null);
        }
    }
    periodChanged(date) {
        this.datePickerModel.period = date;
        this.close();
    }
    setDateMode(mode) {
        this.datePickerModel.dateMode = mode;
    }
    close() {
        this.dialogRef.close();
    }
    _initMonthRangeModels() {
        this.leftCalendarDate$ = this.datePickerModel.calendarDate$;
        this.rightCalendarDate$ = this.datePickerModel.calendarDate$
            .pipe(map((value) => value && addMonths(value, 1) || null));
        this.modelFrom$ = this.datePickerModel
            .rangePickerRef
            .startDate$
            .pipe(shareReplay());
        this.modelTo$ = this.datePickerModel
            .rangePickerRef
            .endDate$
            .pipe(shareReplay());
    }
}
FsMonthRangePickerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsMonthRangePickerComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
FsMonthRangePickerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: FsMonthRangePickerComponent, selector: "fs-datepicker-month-range-picker", inputs: { dialogRef: "dialogRef", datePickerModel: "datePickerModel" }, usesOnChanges: true, ngImport: i0, template: "<div class=\"calendar-container\">\n  <div class=\"date-time\">\n    <div class=\"calendar-view\">\n      <fs-date-picker-header-month-range\n        [calendarDate]=\"leftCalendarDate$ | async\"\n        [nextCalendarDate]=\"rightCalendarDate$ | async\"\n        (goNextMonth)=\"nextMonth()\"\n        (goPrevMonth)=\"prevMonth()\"\n      >\n      </fs-date-picker-header-month-range>\n\n      <div class=\"month-range-container\">\n        <fs-date-picker-calendar\n          [rangeFrom]=\"modelFrom$ | async\"\n          [rangeTo]=\"modelTo$ | async\"\n          [drawMonth]=\"leftCalendarDate$ | async\"\n          [dateMode]=\"datePickerModel.calendarMode$ | async\"\n          [highlightStartDate]=\"modelFrom$ | async\"\n          [highlightEndDate]=\"modelTo$ | async\"\n          [disabledDays]=\"datePickerModel.disabledDays$ | async\"\n          [hideExtraDays]=\"true\"\n          (change)=\"dateChanged($event)\">\n        </fs-date-picker-calendar>\n\n        <fs-date-picker-calendar\n          [rangeFrom]=\"modelFrom$ | async\"\n          [rangeTo]=\"modelTo$ | async\"\n          [highlightStartDate]=\"modelFrom$ | async\"\n          [highlightEndDate]=\"modelTo$ | async\"\n          [drawMonth]=\"rightCalendarDate$ | async\"\n          [dateMode]=\"datePickerModel.calendarMode$ | async\"\n          [disabledDays]=\"datePickerModel.disabledDays$ | async\"\n          [hideExtraDays]=\"true\"\n          (change)=\"dateChanged($event)\">\n        </fs-date-picker-calendar>\n      </div>\n    </div>\n\n    <ng-container\n      *ngIf=\"datePickerModel.dateMode !== 'year' && datePickerModel.dateMode !== 'month'\">\n      <fs-date-picker-time\n        *ngIf=\"datePickerModel.view === 'datetime' || datePickerModel.view === 'time'\"\n        [date]=\"datePickerModel.model$ | async\"\n        [minutes]=\"datePickerModel.minutes\"\n        [disabledTimes]=\"datePickerModel.disabledTimes$ | async\"\n        (onChange)=\"dateChanged($event)\"\n      ></fs-date-picker-time>\n    </ng-container>\n  </div>\n\n  <div class=\"buttons\">\n    <button class=\"button-done\" type=\"button\" mat-button color=\"primary\" (click)=\"close()\">Done</button>\n  </div>\n</div>\n", styles: [".month-range-container{display:grid;grid-template-columns:1fr 1fr;grid-column-gap:40px;align-items:start;min-height:265px}fs-date-picker-calendar{display:flex}\n"], components: [{ type: FsDatePickerHeaderMonthRangeComponent, selector: "fs-date-picker-header-month-range", inputs: ["calendarDate", "nextCalendarDate"], outputs: ["goNextMonth", "goPrevMonth"] }, { type: FsDatePickerCalendarComponent, selector: "fs-date-picker-calendar", inputs: ["date", "period", "rangeFrom", "rangeTo", "highlightStartDate", "highlightEndDate", "dateMode", "disabledDays", "drawMonth", "seedDate", "periodWeeks", "hideExtraDays"], outputs: ["change", "rangeChange", "periodChange", "hoverDay"] }, { type: FsDatePickerTimeComponent, selector: "fs-date-picker-time", inputs: ["date", "disabledMinutes", "disabledHours", "disabledTimes", "expanded", "minutes", "showNotSelected"], outputs: ["onChange"] }, { type: i4$1.MatButton, selector: "button[mat-button], button[mat-raised-button], button[mat-icon-button],             button[mat-fab], button[mat-mini-fab], button[mat-stroked-button],             button[mat-flat-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }], directives: [{ type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i1.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsMonthRangePickerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'fs-datepicker-month-range-picker',
                    templateUrl: './month-range-picker.component.html',
                    styleUrls: ['./month-range-picker.component.scss'],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return []; }, propDecorators: { dialogRef: [{
                type: Input
            }], datePickerModel: [{
                type: Input
            }] } });

class FsDatePickerHeaderComponent {
    constructor(_elRef) {
        this._elRef = _elRef;
        this.monthChange = new EventEmitter();
        this.yearChange = new EventEmitter();
        this.goNextMonth = new EventEmitter();
        this.goPrevMonth = new EventEmitter();
        this.viewModeChange = new EventEmitter();
        this.now = new Date();
        this.monthNow = this.now.getMonth();
        this.yearNow = this.now.getFullYear();
        this.yearsList = [];
        this.monthList = [];
    }
    get calendarMonth() {
        var _a;
        return (_a = this.calendarDate) === null || _a === void 0 ? void 0 : _a.getMonth();
    }
    get calendarYear() {
        var _a;
        return (_a = this.calendarDate) === null || _a === void 0 ? void 0 : _a.getFullYear();
    }
    get calendarDay() {
        var _a;
        return (_a = this.calendarDate) === null || _a === void 0 ? void 0 : _a.getDate();
    }
    ngOnChanges(changes) {
    }
    ngAfterViewInit() {
        this._createMonthsList();
        this._createYearsList();
    }
    selectMonth(month) {
        this.monthChange.emit(month);
        this.setViewMode('date');
    }
    selectYear(year) {
        this.yearChange.emit(year);
        this.setViewMode('date');
    }
    setViewMode(mode) {
        this.viewModeChange.emit(mode);
        this._scrollToSelectedYear();
        this._scrollToSelectedMonth();
    }
    nextMonth() {
        this.goNextMonth.emit();
    }
    prevMonth() {
        this.goPrevMonth.emit();
    }
    _createYearsList() {
        this.yearsList = [];
        for (let y = this.minYear; y < this.maxYear; y++) {
            const year = new Date().setFullYear(y);
            this.yearsList.push({ value: y, disabled: this._isYearDisabled(year) });
        }
    }
    _createMonthsList() {
        const year = this.calendarMonth ? this.calendarYear : this.now.getFullYear();
        const checkIfMonthDisabled = (monthNumber, disabledDays) => {
            const month = new Date();
            month.setFullYear(year);
            month.setMonth(monthNumber);
            return isMonthDisabled(month, disabledDays);
        };
        this.monthList = [];
        for (const item of MONTHS$1) {
            const monthItem = Object.assign(Object.assign({}, item), { disabled: checkIfMonthDisabled(item.value, this.disabledDays) });
            this.monthList.push(monthItem);
        }
    }
    _isYearDisabled(date) {
        const startYear = startOfYear(date);
        const endYear = endOfYear(date);
        return isRangeDisabled(this.disabledDays, startYear, endYear);
    }
    _scrollToSelectedYear() {
        setTimeout(() => {
            const years = this._elRef.nativeElement.querySelector('.years');
            const selected = years.querySelector('.year.selected');
            if (selected) {
                selected.scrollIntoView({ behavior: 'auto', block: 'center' });
            }
        });
    }
    _scrollToSelectedMonth() {
        setTimeout(() => {
            const years = this._elRef.nativeElement.querySelector('.months');
            const selected = years.querySelector('.month.selected');
            if (selected) {
                selected.scrollIntoView({ behavior: 'auto', block: 'center' });
            }
        });
    }
}
FsDatePickerHeaderComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerHeaderComponent, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
FsDatePickerHeaderComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: FsDatePickerHeaderComponent, selector: "fs-date-picker-header", inputs: { viewMode: "viewMode", minYear: "minYear", maxYear: "maxYear", disabledDays: "disabledDays", calendarDate: "calendarDate" }, outputs: { monthChange: "monthChange", yearChange: "yearChange", goNextMonth: "goNextMonth", goPrevMonth: "goPrevMonth", viewModeChange: "viewModeChange" }, usesOnChanges: true, ngImport: i0, template: "<div class=\"months-years\" *ngIf=\"viewMode == 'month' || viewMode == 'year'\">\n  <div class=\"months\">\n    <div\n      *ngFor=\"let month of monthList\"\n      (click)=\"selectMonth(month.value)\"\n      class=\"month\"\n      [ngClass]=\"{\n          now: monthNow == month.value,\n          selected: calendarMonth === month.value,\n          disabled: month.disabled\n        }\">\n      <div class=\"tile-content\">{{ month.abr }}</div>\n    </div>\n  </div>\n\n  <div class=\"years\">\n    <ng-container *ngFor=\"let year of yearsList;\">\n      <div\n        class=\"year data-year-{{ year.value }}\"\n        (click)=\"selectYear(year.value)\"\n        [class.now]=\"yearNow == year.value\"\n        [class.selected]=\"calendarYear === year.value\"\n        [class.disabled]=\"year.disabled\">\n        <div class=\"tile-content\">{{ year.value }}</div>\n      </div>\n    </ng-container>\n    <div class=\"clear\"></div>\n  </div>\n</div>\n\n<div *ngIf=\"viewMode == 'week' || viewMode == 'date' || viewMode == 'datetime' || viewMode == 'monthrange'\" class=\"calendar\">\n  <div class=\"month-year\">\n    <a class=\"month-year-name\" (click)=\"setViewMode('month')\">\n      {{ calendarDate | fsDateFormat: 'full-date-dayless-yearless' }}\n\n      <span *ngIf=\"calendarDay\" class=\"day-name\">\n        {{ calendarDay }},\n      </span>\n\n      {{ calendarYear }}\n      <mat-icon class=\"action\">arrow_drop_down</mat-icon>\n    </a>\n\n    <div class=\"gap\"></div>\n\n    <div class=\"action\">\n      <a (click)=\"prevMonth()\" class=\"action\">\n        <mat-icon>navigate_before</mat-icon>\n      </a>\n      <a (click)=\"nextMonth()\" class=\"action\">\n        <mat-icon>navigate_next</mat-icon>\n      </a>\n    </div>\n  </div>\n\n</div>\n", styles: [".months{width:350px}.month-year-name{color:inherit;border-radius:3px;display:flex;align-items:center;padding:5px 5px 5px 10px}.month-year-name:hover{background-color:#eaeaea;border-radius:3px}.day-name{padding:0 4px}.actions a{padding:6px;color:#757575}a.action{color:#757575}.months-years{display:flex;height:100%;min-width:350px}.months-years .years{overflow:auto;width:100%}.months-years .years .year{text-align:center;height:50px;line-height:50px;outline:none;cursor:pointer;box-sizing:border-box}.months-years .months{width:100%;height:100%;overflow:auto}.months-years .months .tile-content{width:50px;height:50px}.months-years .months .month{text-align:center;display:flex;justify-content:center;flex-direction:column;cursor:pointer;outline:none;border-bottom:0;border-right:0;box-sizing:border-box}\n"], components: [{ type: i1$1.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }], directives: [{ type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }], pipes: { "fsDateFormat": i3.FsDateFormatPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerHeaderComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'fs-date-picker-header',
                    templateUrl: './header.component.html',
                    styleUrls: [
                        './header.component.scss',
                    ],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { viewMode: [{
                type: Input
            }], minYear: [{
                type: Input
            }], maxYear: [{
                type: Input
            }], disabledDays: [{
                type: Input
            }], calendarDate: [{
                type: Input
            }], monthChange: [{
                type: Output
            }], yearChange: [{
                type: Output
            }], goNextMonth: [{
                type: Output
            }], goPrevMonth: [{
                type: Output
            }], viewModeChange: [{
                type: Output
            }] } });

class FsDesktopDatePickerComponent {
    constructor() {
        this.timePickerExpanded = false;
    }
    viewModeChanged(mode) {
        this.datePickerModel.setCalendarMode(mode);
    }
    monthChanged(month) {
        this.datePickerModel.setCalendarMonth(month);
    }
    yearChanged(year) {
        this.datePickerModel.setCalendarYear(year);
    }
    nextMonth() {
        this.datePickerModel.nextMonth();
    }
    prevMonth() {
        this.datePickerModel.prevMonth();
    }
    dateChanged(date) {
        this.datePickerModel.model = date;
        if (!this.datePickerModel.isDateTimeView && !this.datePickerModel.isTimeView) {
            this.close();
        }
    }
    periodChanged(date) {
        this.datePickerModel.period = date;
        this.close();
    }
    toggleTimeExpand() {
        this.timePickerExpanded = !this.timePickerExpanded;
    }
    setDateMode(mode) {
        this.datePickerModel.dateMode = mode;
    }
    close() {
        this.dialogRef.close();
    }
}
FsDesktopDatePickerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDesktopDatePickerComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
FsDesktopDatePickerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: FsDesktopDatePickerComponent, selector: "fs-datepicker-desktop-datepicker", inputs: { dialogRef: "dialogRef", datePickerModel: "datePickerModel" }, ngImport: i0, template: "<div class=\"calendar-container\">\n  <div class=\"date-time\">\n    <div class=\"calendar-view\">\n      <fs-date-picker-header\n        [calendarDate]=\"datePickerModel.calendarDate$ | async\"\n        [minYear]=\"datePickerModel.minYear\"\n        [maxYear]=\"datePickerModel.maxYear\"\n        [viewMode]=\"datePickerModel.calendarMode$ | async\"\n        [disabledDays]=\"datePickerModel.disabledDays$ | async\"\n        (viewModeChange)=\"viewModeChanged($event)\"\n        (monthChange)=\"monthChanged($event)\"\n        (yearChange)=\"yearChanged($event)\"\n        (goNextMonth)=\"nextMonth()\"\n        (goPrevMonth)=\"prevMonth()\"\n      >\n      </fs-date-picker-header>\n\n      <ng-container *ngIf=\"dialogRef.components.calendarStart\">\n        <fs-date-picker-calendar\n          [date]=\"datePickerModel.model$ | async\"\n          [drawMonth]=\"datePickerModel.calendarDate$ | async\"\n          [dateMode]=\"datePickerModel.calendarMode$ | async\"\n          [disabledDays]=\"datePickerModel.disabledDays$ | async\"\n          [period]=\"datePickerModel.period\"\n          [seedDate]=\"datePickerModel.seedDate\"\n          [periodWeeks]=\"datePickerModel.periodWeeks\"\n          (change)=\"dateChanged($event)\"\n          (periodChange)=\"periodChanged($event)\">\n        </fs-date-picker-calendar>\n      </ng-container>\n    </div>\n\n    <ng-container\n      *ngIf=\"datePickerModel.dateMode !== 'year' && datePickerModel.dateMode !== 'month'\">\n      <fs-date-picker-time\n        *ngIf=\"datePickerModel.view === 'datetime' || datePickerModel.view === 'time'\"\n        [date]=\"datePickerModel.model$ | async\"\n        [minutes]=\"datePickerModel.minutes\"\n        [disabledTimes]=\"datePickerModel.disabledTimes$ | async\"\n        [expanded]=\"timePickerExpanded\"\n        (onChange)=\"dateChanged($event)\"\n      ></fs-date-picker-time>\n    </ng-container>\n  </div>\n\n  <div class=\"buttons\">\n    <button class=\"button-done\" type=\"button\" mat-button color=\"primary\" (click)=\"close()\">Done</button>\n    <button type=\"button\"\n            mat-button\n            class=\"button-more\"\n            *ngIf=\"datePickerModel.minutes\n                   && (datePickerModel.view === 'datetime' || datePickerModel.view === 'time')\n                   && !(datePickerModel.view === 'datetime' && datePickerModel.dateMode === 'date')\"\n            (click)=\"toggleTimeExpand()\">\n      <ng-container *ngIf=\"!timePickerExpanded; else lessMinutes\">\n        More Minutes\n      </ng-container>\n      <ng-template #lessMinutes>\n        Less Minutes\n      </ng-template>\n    </button>\n  </div>\n</div>\n", styles: [".date-time{display:flex}\n"], components: [{ type: FsDatePickerHeaderComponent, selector: "fs-date-picker-header", inputs: ["viewMode", "minYear", "maxYear", "disabledDays", "calendarDate"], outputs: ["monthChange", "yearChange", "goNextMonth", "goPrevMonth", "viewModeChange"] }, { type: FsDatePickerCalendarComponent, selector: "fs-date-picker-calendar", inputs: ["date", "period", "rangeFrom", "rangeTo", "highlightStartDate", "highlightEndDate", "dateMode", "disabledDays", "drawMonth", "seedDate", "periodWeeks", "hideExtraDays"], outputs: ["change", "rangeChange", "periodChange", "hoverDay"] }, { type: FsDatePickerTimeComponent, selector: "fs-date-picker-time", inputs: ["date", "disabledMinutes", "disabledHours", "disabledTimes", "expanded", "minutes", "showNotSelected"], outputs: ["onChange"] }, { type: i4$1.MatButton, selector: "button[mat-button], button[mat-raised-button], button[mat-icon-button],             button[mat-fab], button[mat-mini-fab], button[mat-stroked-button],             button[mat-flat-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }], directives: [{ type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i1.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDesktopDatePickerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'fs-datepicker-desktop-datepicker',
                    templateUrl: './date-picker.component.html',
                    styleUrls: ['./date-picker.component.scss'],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return []; }, propDecorators: { dialogRef: [{
                type: Input
            }], datePickerModel: [{
                type: Input
            }] } });

class FsDesktopCalendarDialogComponent {
    constructor(_dialogRef) {
        this._dialogRef = _dialogRef;
    }
    get datePickerModel() {
        return this._dialogRef.pickerModel;
    }
    get dialogRef() {
        return this._dialogRef;
    }
}
FsDesktopCalendarDialogComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDesktopCalendarDialogComponent, deps: [{ token: FsDatePickerDialogRef }], target: i0.ɵɵFactoryTarget.Component });
FsDesktopCalendarDialogComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: FsDesktopCalendarDialogComponent, selector: "ng-component", ngImport: i0, template: "<div\n  class=\"fs-date-picker-dialog fs-date-picker-dialog-shadow opened {{ 'dialog-view-' + datePickerModel.view }}\"\n  tabindex=\"0\"\n  [ngClass]=\"{\n      'has-view-date': datePickerModel.view === 'date' || datePickerModel.view === 'datetime',\n      'has-view-time': datePickerModel.view === 'time' || datePickerModel.view === 'datetime',\n      'date-mode-date-time': (datePickerModel.calendarMode$ | async) === 'datetime',\n      'date-mode-date': (datePickerModel.calendarMode$ | async) === 'date',\n      'date-mode-time': (datePickerModel.calendarMode$ | async) === 'time',\n      'date-mode-month': (datePickerModel.calendarMode$ | async) === 'month',\n      'date-mode-year': (datePickerModel.calendarMode$ | async) === 'year',\n      'date-mode-week': (datePickerModel.calendarMode$ | async) === 'week'\n    }\">\n\n  <ng-container *ngIf=\"datePickerModel.view === 'monthrange' else defaultPicker\">\n    <fs-datepicker-month-range-picker [dialogRef]=\"dialogRef\" [datePickerModel]=\"datePickerModel\">\n    </fs-datepicker-month-range-picker>\n  </ng-container>\n\n  <ng-template #defaultPicker>\n    <fs-datepicker-desktop-datepicker [dialogRef]=\"dialogRef\" [datePickerModel]=\"datePickerModel\">\n    </fs-datepicker-desktop-datepicker>\n  </ng-template>\n</div>\n", styles: [":host ::ng-deep .dialog-view-datetime fs-date-picker-time{margin-left:20px}:host ::ng-deep fs-date-picker-calendar{display:none}:host ::ng-deep .date-mode-time .month-year.time{display:none}:host ::ng-deep .date-mode-date fs-date-picker-calendar,:host ::ng-deep .date-mode-date-time fs-date-picker-calendar,:host ::ng-deep .date-mode-week fs-date-picker-calendar{display:flex;flex:1}\n"], components: [{ type: FsMonthRangePickerComponent, selector: "fs-datepicker-month-range-picker", inputs: ["dialogRef", "datePickerModel"] }, { type: FsDesktopDatePickerComponent, selector: "fs-datepicker-desktop-datepicker", inputs: ["dialogRef", "datePickerModel"] }], directives: [{ type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i1.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDesktopCalendarDialogComponent, decorators: [{
            type: Component,
            args: [{
                    templateUrl: './desktop-dialog.component.html',
                    styleUrls: ['./desktop-dialog.component.scss'],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: FsDatePickerDialogRef }]; } });

const MOBILE_BREAKPOINT = '(max-width: 737px)';
class FsDatePickerDialogFactory {
    constructor(_overlay, _breakpointObserver, _bottomSheet, _document) {
        this._overlay = _overlay;
        this._breakpointObserver = _breakpointObserver;
        this._bottomSheet = _bottomSheet;
        this._document = _document;
        this._resolutionChanged = false;
    }
    get _ESCKeyPressed$() {
        return fromEvent(this._document, 'keydown')
            .pipe(filter((event) => {
            return event.code === 'Escape';
        }));
    }
    openDatePicker(el, injector, options) {
        this._targetElRef = el;
        const dateDialogRef = new FsDatePickerDialogRef(options);
        this._openDatePicker(injector, 'date', dateDialogRef);
        return dateDialogRef;
    }
    openDateScrollPicker(el, injector, options) {
        this._targetElRef = el;
        const dateDialogRef = new FsDatePickerDialogRef(options);
        this._openDatePicker(injector, 'scroll', dateDialogRef);
        return dateDialogRef;
    }
    _openDatePicker(injector, type, dialogRef) {
        const layoutChanges = this._breakpointObserver
            .observe([
            MOBILE_BREAKPOINT,
        ])
            .pipe(map((result) => {
            return result.breakpoints[MOBILE_BREAKPOINT];
        }));
        layoutChanges
            .pipe(map((mobile) => {
            return this._openDatePickerComponent(mobile, injector, type, dialogRef);
        }), tap((ref) => {
            dialogRef.pickerOverlayRef.setActiveOverlay(ref);
        }), take(1), switchMap(() => {
            return layoutChanges
                .pipe(skip(1));
        }), debounceTime(100), distinctUntilChanged(), tap(() => {
            this._resolutionChanged = true;
        }), tap(() => {
            dialogRef.pickerOverlayRef.close();
        }), map((mobile) => {
            return this._openDatePickerComponent(mobile, injector, type, dialogRef);
        }), tap((ref) => {
            dialogRef.pickerOverlayRef.setActiveOverlay(ref);
        }), tap(() => {
            this._resolutionChanged = false;
        }), finalize(() => {
            dialogRef.close();
        }), takeUntil(dialogRef.pickerOverlayRef.destroy$
            .pipe(filter(() => !this._resolutionChanged))), takeUntil(dialogRef.close$), takeUntil(this._ESCKeyPressed$))
            .subscribe();
    }
    _openDatePickerComponent(mobile, injector, type, dialogRef) {
        if (mobile) {
            if (type === 'date') {
                return this._openDatePickerMobile(dialogRef);
            }
            else {
                return this._openDateScrollPickerMobile(dialogRef);
            }
        }
        else {
            if (type === 'date') {
                return this._openDatePickerDesktop(injector, dialogRef);
            }
            else {
                return this._openDateScrollPickerDesktop(injector, dialogRef);
            }
        }
    }
    _createOverlay(el, config = {}) {
        config = Object.assign(Object.assign({}, config), { positionStrategy: this._createPopupPositionStrategy(el), scrollStrategy: this._overlay.scrollStrategies.reposition(), hasBackdrop: true, backdropClass: [], panelClass: 'fs-datepicker-overlay-pane' });
        const overlayConfig = new OverlayConfig(config);
        return this._overlay.create(overlayConfig);
    }
    _createInjector(parentInjector, previewRef) {
        const injectionTokens = new WeakMap([
            [FsDatePickerDialogRef, previewRef],
        ]);
        return new PortalInjector(parentInjector, injectionTokens);
    }
    _createPopupPositionStrategy(el) {
        return this._createBasePopupPositionStrategy(el)
            .withPositions([
            {
                originX: 'start',
                originY: 'bottom',
                overlayX: 'start',
                overlayY: 'top',
                offsetY: 10,
                offsetX: -29
            },
            {
                originX: 'end',
                originY: 'top',
                overlayX: 'start',
                overlayY: 'bottom',
            },
            {
                originX: 'end',
                originY: 'top',
                overlayX: 'start',
                overlayY: 'center',
            },
            {
                originX: 'end',
                originY: 'bottom',
                overlayX: 'start',
                overlayY: 'bottom',
            },
            {
                originX: 'start',
                originY: 'bottom',
                overlayX: 'end',
                overlayY: 'top',
                offsetX: -29,
            },
            {
                originX: 'start',
                originY: 'bottom',
                overlayX: 'end',
                overlayY: 'center',
                offsetX: -29,
            },
        ]);
    }
    _createBasePopupPositionStrategy(el) {
        return this._overlay.position()
            .flexibleConnectedTo(el)
            .withGrowAfterOpen(false)
            .withFlexibleDimensions(false)
            .withPush(false);
    }
    _openDatePickerDesktop(parentInjector, previewRef) {
        const overlayRef = this._createOverlay(this._targetElRef, {
            positionStrategy: this._createBasePopupPositionStrategy(this._targetElRef),
        });
        const injector = this._createInjector(parentInjector, previewRef);
        const containerPortal = new ComponentPortal(FsDesktopCalendarDialogComponent, undefined, injector);
        overlayRef.attach(containerPortal);
        return overlayRef;
    }
    _openDatePickerMobile(dialogRef) {
        return this._bottomSheet.open(FsMobileCalendarDialogComponent, {
            data: {
                dateDialogRef: dialogRef,
            },
            restoreFocus: false,
        });
    }
    _openDateScrollPickerDesktop(parentInjector, previewRef) {
        const overlayRef = this._createOverlay(this._targetElRef, { scrollStrategy: this._overlay.scrollStrategies.block() });
        const injector = this._createInjector(parentInjector, previewRef);
        const containerPortal = new ComponentPortal(FsDateScrollPickerDesktopComponent, undefined, injector);
        overlayRef.attach(containerPortal);
        return overlayRef;
    }
    _openDateScrollPickerMobile(dialogRef) {
        return this._bottomSheet.open(FsDateScrollPickerMobileDialogComponent, {
            data: {
                dateDialogRef: dialogRef,
            }
        });
    }
}
FsDatePickerDialogFactory.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerDialogFactory, deps: [{ token: i1$5.Overlay }, { token: i2$1.BreakpointObserver }, { token: i1$2.MatBottomSheet }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Injectable });
FsDatePickerDialogFactory.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerDialogFactory });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerDialogFactory, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$5.Overlay }, { type: i2$1.BreakpointObserver }, { type: i1$2.MatBottomSheet }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }]; } });

class FsDatePickerDesktopDialogContainerModule {
}
FsDatePickerDesktopDialogContainerModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerDesktopDialogContainerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
FsDatePickerDesktopDialogContainerModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerDesktopDialogContainerModule, declarations: [FsDesktopCalendarDialogComponent,
        FsDatePickerHeaderComponent,
        FsDesktopDatePickerComponent,
        FsMonthRangePickerComponent,
        FsDatePickerHeaderMonthRangeComponent], imports: [CommonModule,
        MatButtonModule,
        MatIconModule,
        FsDatePickerCalendarModule,
        FsDateModule,
        ScrollingModule], exports: [FsDesktopCalendarDialogComponent] });
FsDatePickerDesktopDialogContainerModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerDesktopDialogContainerModule, imports: [[
            CommonModule,
            MatButtonModule,
            MatIconModule,
            FsDatePickerCalendarModule,
            FsDateModule,
            ScrollingModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerDesktopDialogContainerModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        MatButtonModule,
                        MatIconModule,
                        FsDatePickerCalendarModule,
                        FsDateModule,
                        ScrollingModule,
                    ],
                    declarations: [
                        FsDesktopCalendarDialogComponent,
                        FsDatePickerHeaderComponent,
                        FsDesktopDatePickerComponent,
                        FsMonthRangePickerComponent,
                        FsDatePickerHeaderMonthRangeComponent,
                    ],
                    exports: [
                        FsDesktopCalendarDialogComponent,
                    ],
                }]
        }] });

class FsDatePickerScrollPickerDialogContainerModule {
}
FsDatePickerScrollPickerDialogContainerModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerScrollPickerDialogContainerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
FsDatePickerScrollPickerDialogContainerModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerScrollPickerDialogContainerModule, declarations: [FsDateScrollPickerDesktopComponent,
        FsDateScrollPickerMobileDialogComponent,
        FsDateScrollPickerDialogComponent], imports: [CommonModule,
        FormsModule,
        MatButtonModule,
        FsScrollPickerModule,
        MatListModule], exports: [FsDateScrollPickerDesktopComponent,
        FsDateScrollPickerMobileDialogComponent] });
FsDatePickerScrollPickerDialogContainerModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerScrollPickerDialogContainerModule, imports: [[
            CommonModule,
            FormsModule,
            MatButtonModule,
            FsScrollPickerModule,
            MatListModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerScrollPickerDialogContainerModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        FormsModule,
                        MatButtonModule,
                        FsScrollPickerModule,
                        MatListModule,
                    ],
                    declarations: [
                        FsDateScrollPickerDesktopComponent,
                        FsDateScrollPickerMobileDialogComponent,
                        FsDateScrollPickerDialogComponent,
                    ],
                    exports: [
                        FsDateScrollPickerDesktopComponent,
                        FsDateScrollPickerMobileDialogComponent,
                    ],
                }]
        }] });

class FsDatePickerMobileDialogContainerModule {
}
FsDatePickerMobileDialogContainerModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerMobileDialogContainerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
FsDatePickerMobileDialogContainerModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerMobileDialogContainerModule, declarations: [FsMobileCalendarDialogComponent,
        FsDatePickerMobileHeaderComponent,
        FsMobileTimePickerComponent,
        FDatePickerMobileDatetimePickerComponent,
        FsDatePickerMobileHeaderMonthRangeComponent,
        FsDatePickerVirtualScrollCalendarComponent], imports: [CommonModule,
        MatTabsModule,
        MatButtonModule,
        MatIconModule,
        FsDatePickerCalendarModule,
        FsDateModule,
        ScrollingModule,
        MatListModule], exports: [FsMobileCalendarDialogComponent] });
FsDatePickerMobileDialogContainerModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerMobileDialogContainerModule, imports: [[
            CommonModule,
            MatTabsModule,
            MatButtonModule,
            MatIconModule,
            FsDatePickerCalendarModule,
            FsDateModule,
            ScrollingModule,
            MatListModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerMobileDialogContainerModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        MatTabsModule,
                        MatButtonModule,
                        MatIconModule,
                        FsDatePickerCalendarModule,
                        FsDateModule,
                        ScrollingModule,
                        MatListModule,
                    ],
                    declarations: [
                        FsMobileCalendarDialogComponent,
                        FsDatePickerMobileHeaderComponent,
                        FsMobileTimePickerComponent,
                        FDatePickerMobileDatetimePickerComponent,
                        FsDatePickerMobileHeaderMonthRangeComponent,
                        FsDatePickerVirtualScrollCalendarComponent,
                    ],
                    exports: [
                        FsMobileCalendarDialogComponent,
                    ],
                }]
        }] });

class FsDatePickerDialogModule {
    static forRoot() {
        return {
            ngModule: FsDatePickerDialogModule,
            providers: [
                FsDatePickerDialogFactory,
            ]
        };
    }
}
FsDatePickerDialogModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerDialogModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
FsDatePickerDialogModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerDialogModule, imports: [FsDatePickerDesktopDialogContainerModule,
        FsDatePickerScrollPickerDialogContainerModule,
        FsDatePickerMobileDialogContainerModule] });
FsDatePickerDialogModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerDialogModule, imports: [[
            FsDatePickerDesktopDialogContainerModule,
            FsDatePickerScrollPickerDialogContainerModule,
            FsDatePickerMobileDialogContainerModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerDialogModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        FsDatePickerDesktopDialogContainerModule,
                        FsDatePickerScrollPickerDialogContainerModule,
                        FsDatePickerMobileDialogContainerModule,
                    ],
                }]
        }] });

function parseDate(value) {
    let parsedDate = new Date(Date.parse(value));
    if (isValid(parsedDate)) {
        return parsedDate;
    }
    parsedDate = parseMessyDate(value);
    if (isValid(parsedDate)) {
        return parsedDate;
    }
    return null;
}

class FsDatePickerBaseComponent {
    constructor(renderer, elementRef, _cdRef) {
        this._cdRef = _cdRef;
        this.change$ = new EventEmitter();
        this.selected$ = new EventEmitter();
        this.blured$ = new EventEmitter();
        this.disabled = false;
        this.readonly = false;
        this.opened = false;
        this.dialog = null;
        this._destroy$ = new Subject();
        this._onChange = (value) => { };
        this._onTouch = () => { };
        this._validatorOnChange = () => { };
        this._clear = true;
        this._lastValueValid = false;
        /** The form control validator for whether the input parses. */
        this._parseValidator = () => {
            return this._lastValueValid
                ? null
                : { fsDatepickerParse: 'Invalid Date' };
        };
        this._validator = Validators.compose([this._parseValidator]);
        this.renderer = renderer;
        this.elementRef = elementRef;
    }
    set clear(value) {
        this._clear = value;
    }
    set timezone(value) {
        this._timezone = value;
        this.writeValue(this._originValue);
    }
    set readonlyState(isReadonly) {
        this.readonly = !!isReadonly || isReadonly === '';
    }
    registerOnChange(fn) { this._onChange = fn; }
    registerOnTouched(fn) { this._onTouch = fn; }
    registerOnValidatorChange(fn) { this._validatorOnChange = fn; }
    ngOnInit() {
        fromEvent(this.el, 'focus')
            .pipe(takeUntil(this._destroy$))
            .subscribe(() => {
            this.open();
            this.el.focus();
        });
        fromEvent(this.el, 'keydown')
            .pipe(tap(() => this.close()), filter((event) => ['Tab', 'Enter', 'Escape'].includes(event.key)), takeUntil(this._destroy$))
            .subscribe((event) => {
            if (event.key === 'Enter') {
                this.inputChange(this.el.value);
            }
            this.close();
            this.el.blur();
        });
    }
    get el() {
        return this.elementRef.nativeElement;
    }
    get clear() {
        return this._clear;
    }
    get value() {
        return this._value;
    }
    get timezone() {
        return this._timezone;
    }
    set value(value) {
        if (value && this.timezone) {
            value = zonedTimeToUtc(value, this.timezone);
        }
        this._value = value;
        this._lastValueValid = !value || isValid(value);
        this._onChange(this.value);
        this.updateInput(this.value);
        this.change$.emit(this.value);
    }
    writeValue(obj) { }
    get dateDialogRef() {
        return this._dateDialogRef;
    }
    cleared(event) {
        event.stopPropagation();
        event.preventDefault();
        this.value = null;
        this.clearInput();
        this.selected$.next(null);
    }
    ngOnDestroy() {
        if (this.dateDialogRef) {
            this.dateDialogRef.close();
        }
        this._destroy$.next();
        this._destroy$.complete();
    }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
        this._cdRef.markForCheck();
    }
    validate(c) {
        return this._validator ? this._validator(c) : null;
    }
    open() {
        this.renderer.addClass(document.body, 'fs-date-picker-open');
        this.opened = true;
        this._dateDialogRef.value$
            .pipe(takeUntil(this._dateDialogRef.close$), takeUntil(this._destroy$))
            .subscribe((value) => {
            this.value = value;
            this.selected$.emit(value);
        });
        this._dateDialogRef.close$
            .pipe(take(1), takeUntil(this._destroy$))
            .subscribe(() => {
            this._dateDialogRef = null;
            this.renderer.removeClass(document.body, 'fs-date-picker-open');
            this._cdRef.markForCheck();
        });
    }
    clearInput() {
        this.elementRef.nativeElement.value = null;
    }
    triggerClick() {
        this.el.focus();
        this.el.select();
        this.open();
    }
    updateValue(date) {
        this._value = date;
        this._onChange(this.value);
        this._onTouch();
        this.change$.emit(this.value);
    }
    setReadonly() {
        setTimeout(() => {
            this.elementRef.nativeElement.setAttribute('readonly', true);
        });
    }
    close() {
        if (this._dateDialogRef) {
            this._dateDialogRef.close();
        }
    }
    validateDate(date) {
        this._lastValueValid = !date || isValid(date);
    }
    _inputKeyup(event, value) {
        if (event.key === 'Enter') {
            this.inputChange(value);
        }
    }
    _inputChange(value, target) {
        var _a;
        if (((_a = this.ngModelOptions) === null || _a === void 0 ? void 0 : _a.updateOn) !== 'blur') {
            this.inputChange(value);
        }
    }
    _inputBlur(value) {
        var _a;
        if (((_a = this.ngModelOptions) === null || _a === void 0 ? void 0 : _a.updateOn) === 'blur') {
            this.inputChange(value);
        }
        this.updateInput(this.value);
        this.blured$.emit(this.value);
    }
    inputChange(value) {
        if (!!value) {
            const lastValueWasValid = this._lastValueValid;
            const date = parseDate(value);
            this.validateDate(date);
            if (!isEqual$1(date, this._value)) {
                this.updateValue(date);
            }
            else if (lastValueWasValid !== this._lastValueValid) {
                this._validatorOnChange();
            }
        }
        else {
            this.updateValue(null);
        }
    }
}
FsDatePickerBaseComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerBaseComponent, deps: [{ token: i0.Renderer2 }, { token: i0.ElementRef }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive });
FsDatePickerBaseComponent.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: FsDatePickerBaseComponent, inputs: { ngModelOptions: "ngModelOptions", clear: "clear", timezone: "timezone", readonlyState: ["readonly", "readonlyState"] }, outputs: { change$: "change", selected$: "selected", blured$: "blured" }, host: { listeners: { "keyup": "_inputKeyup($event,$event.target.value)", "input": "_inputChange($event.target.value,$event.target)", "blur": "_inputBlur($event.target.value)" }, properties: { "class.fs-input-disabled": "this.disabled", "attr.readonly": "this.readonly", "class.fs-input-readonly": "this.readonly" } }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerBaseComponent, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }, { type: i0.ElementRef }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { ngModelOptions: [{
                type: Input
            }], clear: [{
                type: Input
            }], timezone: [{
                type: Input
            }], change$: [{
                type: Output,
                args: ['change']
            }], selected$: [{
                type: Output,
                args: ['selected']
            }], blured$: [{
                type: Output,
                args: ['blured']
            }], disabled: [{
                type: HostBinding,
                args: ['class.fs-input-disabled']
            }, {
                type: HostBinding,
                args: ['attr.readonly']
            }], readonlyState: [{
                type: Input,
                args: ['readonly']
            }], readonly: [{
                type: HostBinding,
                args: ['class.fs-input-readonly']
            }, {
                type: HostBinding,
                args: ['attr.readonly']
            }], _inputKeyup: [{
                type: HostListener,
                args: ['keyup', ['$event', '$event.target.value']]
            }], _inputChange: [{
                type: HostListener,
                args: ['input', ['$event.target.value', '$event.target']]
            }], _inputBlur: [{
                type: HostListener,
                args: ['blur', ['$event.target.value']]
            }] } });

function createDateFromValue(value, timezone) {
    if (value && !isDate(value)) {
        value = new Date(value);
        if (!isValid(value)) {
            value = null;
        }
    }
    if (value && isDate(value) && !isValid(value)) {
        value = null;
    }
    if (value && timezone) {
        return utcToZonedTime(value, timezone);
    }
    return value;
}

var ScrollPickerViewType;
(function (ScrollPickerViewType) {
    ScrollPickerViewType["Date"] = "date";
    ScrollPickerViewType["Month"] = "month";
    ScrollPickerViewType["Year"] = "year";
    ScrollPickerViewType["MonthDay"] = "monthday";
    ScrollPickerViewType["MonthYear"] = "monthyear";
})(ScrollPickerViewType || (ScrollPickerViewType = {}));

function formatDateTime(value, dateFormat = PickerViewType.Date, customDateFormat = '', timezone) {
    if (isNumber(value)) {
        value = new Date(value);
    }
    else if (typeof value === 'string') {
        value = new Date(value);
        if (!isValid(value)) {
            value = Date.parse(value);
        }
    }
    if (value && isValid(value)) {
        const formats = [];
        if (customDateFormat) {
            return format$1(value, customDateFormat, { timezone });
        }
        else {
            if ([
                PickerViewType.Date,
                PickerViewType.MonthRange,
                PickerViewType.DateTime,
            ].indexOf(dateFormat) != -1) {
                formats.push('MMM d, yyyy');
            }
            if ([PickerViewType.Time, PickerViewType.DateTime].indexOf(dateFormat) != -1) {
                formats.push('h:mm aa');
            }
            if (dateFormat === ScrollPickerViewType.MonthDay) {
                formats.push('MMMM d');
            }
            else if (dateFormat === ScrollPickerViewType.MonthYear) {
                formats.push('MMMM yyyy');
            }
            else if (dateFormat === ScrollPickerViewType.Year) {
                formats.push('yyyy');
            }
            else if (dateFormat === ScrollPickerViewType.Month) {
                formats.push('MMMM');
            }
        }
        return format(value, formats.join(' '));
    }
    return '';
}

class FsDatePickerTriggerComponent {
    constructor(matFormField, el) {
        this.matFormField = matFormField;
        this.el = el;
        this.click = new EventEmitter();
    }
    get isTimeView() {
        return this.view === PickerViewType.Time;
    }
    ngAfterViewInit() {
        var _a;
        const matElementRef = this.matFormField._elementRef.nativeElement;
        const infixEl = matElementRef.querySelector('.mat-form-field-infix');
        (_a = matElementRef
            .querySelector('.mat-form-field-flex')) === null || _a === void 0 ? void 0 : _a.insertBefore(this.el.nativeElement.firstChild, infixEl);
    }
    triggerClick(event) {
        event.preventDefault();
        event.stopPropagation();
        this.click.emit();
    }
}
FsDatePickerTriggerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerTriggerComponent, deps: [{ token: i1$6.MatFormField, optional: true }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
FsDatePickerTriggerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: FsDatePickerTriggerComponent, selector: "fs-datepicker-trigger", inputs: { disabled: "disabled", view: "view" }, outputs: { click: "click" }, ngImport: i0, template: "<div class=\"mat-form-field-preffix fs-date-picker-trigger\" [ngClass]=\"{ disabled: disabled }\">\n  <mat-icon (click)=\"triggerClick($event)\">\n    <ng-container *ngIf=\"isTimeView; else calendarIcon\">\n      schedule\n    </ng-container>\n    <ng-template #calendarIcon>\n      calendar_today\n    </ng-template>\n  </mat-icon>\n</div>\n", styles: [".fs-date-picker-trigger{margin-right:5px;margin-bottom:2px;align-self:flex-end;-webkit-user-select:none;user-select:none}.fs-date-picker-trigger mat-icon{cursor:pointer}.disabled{color:#00000061;pointer-events:none}\n"], components: [{ type: i1$1.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }], directives: [{ type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerTriggerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'fs-datepicker-trigger',
                    templateUrl: 'date-picker-trigger.component.html',
                    styleUrls: ['date-picker-trigger.component.scss'],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1$6.MatFormField, decorators: [{
                    type: Optional
                }] }, { type: i0.ElementRef }]; }, propDecorators: { disabled: [{
                type: Input
            }], view: [{
                type: Input
            }], click: [{
                type: Output
            }] } });

class FsDatePickerComponent extends FsDatePickerBaseComponent {
    constructor(elementRef, renderer, injector, _cdRef, fsDatepickerFactory) {
        super(renderer, elementRef, _cdRef);
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.injector = injector;
        this._cdRef = _cdRef;
        this.fsDatepickerFactory = fsDatepickerFactory;
        this.minYear = null;
        this.maxYear = null;
        this.minDate = null;
        this.maxDate = null;
        this.startOfDay = true;
        this.view = PickerViewType.Date;
        this.minutes = true;
        this.change$ = new EventEmitter();
    }
    writeValue(value) {
        this._originValue = value;
        this._value = createDateFromValue(value, this.timezone);
        this.validateDate(this.value);
        this.updateInput(this.value);
        this._cdRef.markForCheck();
    }
    updateInput(value) {
        if (!this.minutes && value) {
            value.setMinutes(0);
        }
        this.elementRef.nativeElement.value = formatDateTime(value, this.view, this.format, this.timezone);
    }
    open() {
        if (this.disabled || this.readonly || this._dateDialogRef) {
            return;
        }
        const modelValue = isValid(this.value) ? this.value : null;
        this._dateDialogRef = this.fsDatepickerFactory.openDatePicker(this.elementRef, this.injector, {
            modelValue: modelValue,
            view: this.view,
            minutes: this.minutes,
            minYear: this.minYear,
            maxYear: this.maxYear,
            minDate: this.minDate,
            maxDate: this.maxDate,
            startOfDay: this.startOfDay,
            components: this._getDefaultComponents(),
        });
        super.open();
    }
    updateValue(value) {
        if (this.view === PickerViewType.Time && isValid(this._value) && isValid(value)) {
            this._value.setHours(value.getHours());
            this._value.setMinutes(value.getMinutes());
            this._value.setSeconds(value.getSeconds());
            value = new Date(this._value);
        }
        super.updateValue(value);
    }
    _getDefaultComponents() {
        if (this.view === 'time') {
            return { timeStart: true };
        }
        else {
            return { calendarStart: true };
        }
    }
}
FsDatePickerComponent.template = `
    <fs-clear [show]="value && !disabled && !readonly && clear" (clear)="cleared($event)"></fs-clear>
    <fs-datepicker-trigger (click)="triggerClick()" [disabled]="disabled || readonly" [view]="view"></fs-datepicker-trigger>
  `;
FsDatePickerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerComponent, deps: [{ token: ElementRef }, { token: i0.Renderer2 }, { token: i0.Injector }, { token: i0.ChangeDetectorRef }, { token: FsDatePickerDialogFactory }], target: i0.ɵɵFactoryTarget.Component });
FsDatePickerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: FsDatePickerComponent, selector: "[fsDatePicker]", inputs: { minYear: "minYear", maxYear: "maxYear", minDate: "minDate", maxDate: "maxDate", startOfDay: "startOfDay", view: "view", format: "format", minutes: "minutes" }, outputs: { change$: "change" }, providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: forwardRef(() => FsDatePickerComponent),
            multi: true,
        },
        {
            provide: NG_VALIDATORS,
            useExisting: forwardRef(() => FsDatePickerComponent),
            multi: true,
        }
    ], usesInheritance: true, ngImport: i0, template: "\n    <fs-clear [show]=\"value && !disabled && !readonly && clear\" (clear)=\"cleared($event)\"></fs-clear>\n    <fs-datepicker-trigger (click)=\"triggerClick()\" [disabled]=\"disabled || readonly\" [view]=\"view\"></fs-datepicker-trigger>\n  ", isInline: true, components: [{ type: i1$7.FsClearElementComponent, selector: "fs-clear", inputs: ["show"], outputs: ["clear"] }, { type: FsDatePickerTriggerComponent, selector: "fs-datepicker-trigger", inputs: ["disabled", "view"], outputs: ["click"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: '[fsDatePicker]',
                    template: FsDatePickerComponent.template,
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(() => FsDatePickerComponent),
                            multi: true,
                        },
                        {
                            provide: NG_VALIDATORS,
                            useExisting: forwardRef(() => FsDatePickerComponent),
                            multi: true,
                        }
                    ],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef, decorators: [{
                    type: Inject,
                    args: [ElementRef]
                }] }, { type: i0.Renderer2 }, { type: i0.Injector }, { type: i0.ChangeDetectorRef }, { type: FsDatePickerDialogFactory }]; }, propDecorators: { minYear: [{
                type: Input
            }], maxYear: [{
                type: Input
            }], minDate: [{
                type: Input
            }], maxDate: [{
                type: Input
            }], startOfDay: [{
                type: Input
            }], view: [{
                type: Input
            }], format: [{
                type: Input
            }], minutes: [{
                type: Input
            }], change$: [{
                type: Output,
                args: ['change']
            }] } });

class DateRangeSeparatorComponent {
}
DateRangeSeparatorComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DateRangeSeparatorComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
DateRangeSeparatorComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: DateRangeSeparatorComponent, selector: "fs-date-range-separator", ngImport: i0, template: 'to', isInline: true, styles: [":host{display:inline-block;padding:0 10px}\n"], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DateRangeSeparatorComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'fs-date-range-separator',
                    template: 'to',
                    styleUrls: ['./date-range-separator.component.scss'],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }] });

function isSameDate(startDate, endDate) {
    return lightFormat(startDate, 'yyyy-MM-dd') === lightFormat(endDate, 'yyyy-MM-dd');
}

class RangePickerComponent {
    constructor(_elRef, _injector, _datepickerFactory, _type, _cdRef, _ngControl) {
        this._elRef = _elRef;
        this._injector = _injector;
        this._datepickerFactory = _datepickerFactory;
        this._type = _type;
        this._cdRef = _cdRef;
        this._ngControl = _ngControl;
        this.view = PickerViewType.Date;
        this.minYear = null;
        this.maxYear = null;
        this.minDate = null;
        this.maxDate = null;
        this.clear = true;
        this.disabled = false;
        this.readonly = false;
        this.onTouch = () => { };
        this._destroy$ = new Subject();
        this._lastValueValid = false;
        /** The form control validator for whether the input parses. */
        this._parseValidator = () => {
            return this._lastValueValid
                ? null
                : { fsDatepickerParse: 'Invalid Date' };
        };
        this._ngControl.valueAccessor = this;
        this._elRef.nativeElement.setAttribute('autocomplete', 'off');
    }
    set readonlyState(isReadonly) {
        this.readonly = !!isReadonly || isReadonly === '';
    }
    set timezone(value) {
        this._timezone = value;
        this._tzChanged(this._originValue);
    }
    get name() {
        return this._name;
    }
    get timezone() {
        return this._timezone;
    }
    set value(value) {
        if (this._value !== value) {
            this._value = value;
            this.onChange(value);
            this.onTouch(value);
        }
    }
    ngOnInit() {
        const control = this._ngControl.control;
        const validators = control.validator
            ? [control.validator, this._parseValidator]
            : this._parseValidator;
        control.setValidators(validators);
        control.updateValueAndValidity();
    }
    get value() {
        return this._value;
    }
    get dateDialogRef() {
        return this._dateDialogRef;
    }
    writeValue(value) {
        value = this._processInputDate(value);
        this._originValue = value;
        this.validateDate(value);
        const [valuesAreDates] = this._checkValuesEquality(value, this.value);
        if ((valuesAreDates) || (!valuesAreDates && this.value !== value)) {
            this._value = value;
            this.updateInput(this._value);
            this._cdRef.markForCheck();
        }
    }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    open() {
        if (this._dateDialogRef || this.disabled || this.readonly) {
            return;
        }
        //this._disableInput();
        this._dateDialogRef = this._datepickerFactory.openDatePicker(this._elRef, this._injector, {
            view: this.view,
            minYear: this.minYear,
            maxYear: this.maxYear,
            minDate: this._getPickerStartDate() || this.minDate,
            maxDate: this.maxDate,
            components: this._getDefaultComponents(),
            modelValue: this.value,
            pickerRef: this._pickerRef,
            rangeType: this._type
        });
        this._elRef.nativeElement.focus();
        this._listenDialogValueChanges();
        this._dateDialogRef.close$
            .pipe(take(1), takeUntil(this._destroy$))
            .subscribe(() => {
            this._dateDialogRef = null;
            this._enableInput();
            this._cdRef.markForCheck();
        });
    }
    /**
     * Set value which was selected in dialog
     * @param value
     */
    updateValueFromDialog(value) {
        this.updateValue(value);
        // this.writeValue(value);
    }
    updateValue(value) {
        if (this.view === PickerViewType.Time && isValid(this._value) && isValid(value)) {
            this._value.setHours(value.getHours());
            this._value.setMinutes(value.getMinutes());
            this._value.setSeconds(value.getSeconds());
            value = new Date(this._value);
        }
        this._value = value;
        this.updateInput(this._value);
        if (value && this.timezone) {
            value = zonedTimeToUtc(value, this.timezone);
        }
        this.onChange(value);
        this.onTouch(value);
    }
    updateInput(value) {
        this._elRef.nativeElement.value = formatDateTime(value, this.view, this.format, this.timezone);
    }
    _inputKeyup(event, value) {
        if (event.key === 'Enter') {
            this.inputChange(value);
        }
    }
    _inputChange(value, target) {
        var _a;
        if (((_a = this.ngModelOptions) === null || _a === void 0 ? void 0 : _a.updateOn) !== 'blur') {
            this.inputChange(value);
        }
    }
    inputChange(value) {
        const lastValueWasValid = this._lastValueValid;
        const date = parseDate(value);
        this._lastValueValid = !date || isValid(date);
        if (!isEqual$1(date, this._value)) {
            this.updateValue(date);
        }
        else if (lastValueWasValid !== this._lastValueValid) {
            this._ngControl.control.updateValueAndValidity();
        }
    }
    _inputBlur(value) {
        var _a;
        if (((_a = this.ngModelOptions) === null || _a === void 0 ? void 0 : _a.updateOn) === 'blur') {
            this.inputChange(value);
        }
        this.updateInput(this.value);
    }
    registerOnChange(fn) { this.onChange = fn; }
    registerOnTouched(fn) { this.onTouch = fn; }
    triggerClick() {
        this._elRef.nativeElement.focus();
        this._elRef.nativeElement.select();
        this.open();
    }
    _processInputDate(date) {
        if (!date) {
            return null;
        }
        return createDateFromValue(date, this.timezone);
    }
    _getDefaultComponents() {
        if (this.view === 'time') {
            return { timeStart: true };
        }
        else {
            return { calendarStart: true, calendarEnd: true };
        }
    }
    _enableInput() {
        this.disabled = false;
    }
    _disableInput() {
        this.disabled = true;
    }
    _tzChanged(originDate) {
        this._value = createDateFromValue(originDate, this.timezone);
        this.updateInput(this._value);
        this._cdRef.markForCheck();
    }
    _listenDialogValueChanges() {
        this._dateDialogRef.value$
            .pipe(takeUntil(this._dateDialogRef.close$), takeUntil(this._destroy$))
            .subscribe((value) => {
            this.updateValueFromDialog(value);
        });
    }
    _checkValuesEquality(newValue, prevValue) {
        const valuesAreDates = isDate(newValue) && isDate(prevValue) && isValid(newValue) && isValid(prevValue);
        const valuesDatesEquals = valuesAreDates
            && isSameDate(newValue, prevValue);
        return [valuesAreDates, valuesDatesEquals];
    }
    /**
     * We need picker start date to be able to limit "Date To" picker
     */
    _getPickerStartDate() {
        if (this.view !== PickerViewType.MonthRange
            && isDate(this._pickerRef.startDate)
            && isValid(this._pickerRef.startDate)) {
            return subDays(this._pickerRef.startDate, 1);
        }
        return false;
    }
    validateDate(date) {
        this._lastValueValid = !date || isValid(date);
    }
    _pickerRefUpdates$(target) {
        return target
            .pipe(skip(1), pairwise(), filter((changes) => {
            var _a, _b, _c;
            const prevValue = (_a = changes[0]) === null || _a === void 0 ? void 0 : _a.getTime();
            const newValue = (_b = changes[1]) === null || _b === void 0 ? void 0 : _b.getTime();
            return prevValue !== newValue
                && ((_c = this.value) === null || _c === void 0 ? void 0 : _c.getTime()) !== newValue;
        }), map((changes) => changes[1]));
    }
}
RangePickerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: RangePickerComponent, deps: "invalid", target: i0.ɵɵFactoryTarget.Directive });
RangePickerComponent.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: RangePickerComponent, inputs: { view: "view", minYear: "minYear", maxYear: "maxYear", minDate: "minDate", maxDate: "maxDate", clear: "clear", format: "format", readonlyState: ["readonly", "readonlyState"], ngModelOptions: "ngModelOptions", timezone: "timezone" }, host: { listeners: { "focus": "open()", "keyup": "_inputKeyup($event,$event.target.value)", "input": "_inputChange($event.target.value,$event.target)", "blur": "_inputBlur($event.target.value)" }, properties: { "class.fs-input-disabled": "this.disabled", "attr.readonly": "this.readonly", "class.fs-input-readonly": "this.readonly" } }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: RangePickerComponent, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.Injector }, { type: FsDatePickerDialogFactory }, { type: undefined }, { type: i0.ChangeDetectorRef }, { type: i2.NgControl }]; }, propDecorators: { view: [{
                type: Input
            }], minYear: [{
                type: Input
            }], maxYear: [{
                type: Input
            }], minDate: [{
                type: Input
            }], maxDate: [{
                type: Input
            }], clear: [{
                type: Input
            }], format: [{
                type: Input
            }], disabled: [{
                type: HostBinding,
                args: ['class.fs-input-disabled']
            }, {
                type: HostBinding,
                args: ['attr.readonly']
            }], readonlyState: [{
                type: Input,
                args: ['readonly']
            }], ngModelOptions: [{
                type: Input
            }], timezone: [{
                type: Input
            }], readonly: [{
                type: HostBinding,
                args: ['class.fs-input-readonly']
            }, {
                type: HostBinding,
                args: ['attr.readonly']
            }], open: [{
                type: HostListener,
                args: ['focus']
            }], _inputKeyup: [{
                type: HostListener,
                args: ['keyup', ['$event', '$event.target.value']]
            }], _inputChange: [{
                type: HostListener,
                args: ['input', ['$event.target.value', '$event.target']]
            }], _inputBlur: [{
                type: HostListener,
                args: ['blur', ['$event.target.value']]
            }] } });

function cloneDate(fromDate) {
    if (!isDate(fromDate)) {
        return null;
    }
    return new Date(fromDate.getTime());
}

function isDateAfter(target, from, view) {
    let startDate, endDate;
    if (view === PickerViewType.Time) {
        if (from) {
            startDate = cloneDate(from);
        }
        if (target) {
            endDate = cloneDate(target);
        }
    }
    else {
        startDate = from;
        endDate = target;
    }
    if (!startDate || !endDate) {
        return true;
    }
    if (view === PickerViewType.Date && isValid(startDate) && isValid(endDate) && isSameDate(startDate, endDate)) {
        return true;
    }
    if ((view === PickerViewType.DateTime || view === PickerViewType.Time) && isEqual$1(startDate, endDate)) {
        return true;
    }
    return isAfter(endDate, startDate);
}

class RangePickerRef {
    constructor(view) {
        this.view = view;
        this._startDatePickerExists = false;
        this._endDatePickerExists = false;
        this._startDate$ = new BehaviorSubject(null);
        this._endDate$ = new BehaviorSubject(null);
        this._startDate = null;
        this._endDate = null;
    }
    get startDate() {
        return this._startDate;
    }
    get endDate() {
        return this._endDate;
    }
    get startDate$() {
        return this._startDate$.asObservable();
    }
    get endDate$() {
        return this._endDate$.asObservable();
    }
    get startDatePickerExists() {
        return this._startDatePickerExists;
    }
    get endDatePickerExists() {
        return this._endDatePickerExists;
    }
    get isRangeValid() {
        return isDateAfter(this._endDate, this._startDate, this.view);
    }
    /**
     * Update start date and change end date if needed
     * @param value
     */
    updateStartDate(value) {
        this._startDatePickerExists = true;
        if (!!value
            && (this.view === PickerViewType.Date || this.view === PickerViewType.MonthRange)) {
            value = startOfDay(value);
        }
        this._startDate = value && new Date(value) || null;
        this._startDate$.next(this._startDate);
    }
    /**
     * Update end date
     * @param value
     */
    updateEndDate(value) {
        if (!!value
            && (this.view === PickerViewType.Date || this.view === PickerViewType.MonthRange)) {
            value = endOfDay(value);
        }
        this._endDate = value && new Date(value) || null;
        this._endDatePickerExists = true;
        this._endDate$.next(this._endDate);
    }
    sameAsStartDate(value) {
        if (!!value
            && (this.view === PickerViewType.Date || this.view === PickerViewType.MonthRange)) {
            value = startOfDay(value);
        }
        return this._startDate === value;
    }
    sameAsEndDate(value) {
        if (!!value
            && (this.view === PickerViewType.Date || this.view === PickerViewType.MonthRange)) {
            value = endOfDay(value);
        }
        return this._endDate === value;
    }
    /**
     * Mark start date picker as destroyed
     */
    destroyStartDatePicker() {
        this._startDatePickerExists = false;
    }
    /**
     * Mark end date picker as destroyed
     */
    destroyEndDatePicker() {
        this._endDatePickerExists = false;
    }
    /**
     * destroy everything related with picker
     */
    destroy() { }
}

class FsRangePickerStoreService {
    constructor() {
        this._store = new Map();
    }
    registerPickerFrom(name, value, view) {
        this._createIfNotExistsPicker(name, view);
        const pickerRef = this._store.get(name);
        // pickerRef.updateStartDate(value);
        return pickerRef;
    }
    destroyStartDatePicker(name) {
        const pickerRef = this._store.get(name);
        if (pickerRef) {
            pickerRef.destroyStartDatePicker();
            this._destroyRefIfRelatedDestroyed(name, pickerRef);
        }
    }
    destroyEndDatePicker(name) {
        const pickerRef = this._store.get(name);
        if (pickerRef) {
            pickerRef.destroyEndDatePicker();
            this._destroyRefIfRelatedDestroyed(name, pickerRef);
        }
    }
    registerPickerTo(name, value, view) {
        this._createIfNotExistsPicker(name, view);
        const pickerRef = this._store.get(name);
        // pickerRef.updateEndDate(value);
        return pickerRef;
    }
    _createIfNotExistsPicker(name, view) {
        if (!this._store.has(name)) {
            this._store.set(name, new RangePickerRef(view));
        }
    }
    _destroyRefIfRelatedDestroyed(name, ref) {
        if (!ref.startDatePickerExists && !ref.endDatePickerExists) {
            ref.destroy();
            this._store.delete(name);
        }
    }
}
FsRangePickerStoreService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsRangePickerStoreService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
FsRangePickerStoreService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsRangePickerStoreService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsRangePickerStoreService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return []; } });

class RangePickerFromComponent extends RangePickerComponent {
    constructor(_elRef, _injector, _datepickerFactory, _cdRef, _ngControl, _rangePickerStore) {
        super(_elRef, _injector, _datepickerFactory, 'from', _cdRef, _ngControl);
        this._elRef = _elRef;
        this._injector = _injector;
        this._datepickerFactory = _datepickerFactory;
        this._cdRef = _cdRef;
        this._ngControl = _ngControl;
        this._rangePickerStore = _rangePickerStore;
    }
    ngOnInit() {
        this.registerPicker();
        super.ngOnInit();
    }
    ngOnDestroy() {
        this._rangePickerStore.destroyStartDatePicker(this.name);
        this._destroy$.next();
        this._destroy$.complete();
    }
    registerPicker() {
        this._pickerRef = this._rangePickerStore.registerPickerFrom(this.name, this.value, this.view);
    }
    writeValue(value) {
        // Hot fix while angular has ongoing issue
        // https://github.com/angular/angular/issues/29218
        if (!this.onChange) {
            return;
        }
        super.writeValue(value);
        const [valuesAreDates] = this._checkValuesEquality(this.value, this._pickerRef.startDate);
        if ((valuesAreDates && !this._pickerRef.sameAsStartDate(this.value)) || (!valuesAreDates)) {
            this._pickerRef.updateStartDate(this.value);
        }
    }
    cleared(event) {
        event.stopPropagation();
        event.preventDefault();
        this.writeValue(null);
        this.onChange(this.value);
        this.onTouch(this.value);
    }
    /**
     * Set value which was selected in dialog
     * @param value
     */
    updateValueFromDialog(value) {
        this.updateValue(value);
        super.updateValueFromDialog(value);
    }
    updateValue(value) {
        if (this.view === PickerViewType.Date) {
            value = startOfDay(value);
        }
        this._pickerRef.updateStartDate(value);
        super.updateValue(value);
    }
    _tzChanged(originDate) {
        var _a;
        super._tzChanged(originDate);
        (_a = this._pickerRef) === null || _a === void 0 ? void 0 : _a.updateStartDate(this.value);
    }
    _processInputDate(date) {
        date = super._processInputDate(date);
        if (this.view === PickerViewType.Date && date) {
            date = startOfDay(date);
        }
        return date;
    }
}
RangePickerFromComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: RangePickerFromComponent, deps: [{ token: i0.ElementRef }, { token: i0.Injector }, { token: FsDatePickerDialogFactory }, { token: i0.ChangeDetectorRef }, { token: i2.NgControl, optional: true, self: true }, { token: FsRangePickerStoreService }], target: i0.ɵɵFactoryTarget.Directive });
RangePickerFromComponent.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: RangePickerFromComponent, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: RangePickerFromComponent, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.Injector }, { type: FsDatePickerDialogFactory }, { type: i0.ChangeDetectorRef }, { type: i2.NgControl, decorators: [{
                    type: Optional
                }, {
                    type: Self
                }] }, { type: FsRangePickerStoreService }]; } });

class DateTimeRangePickerFromComponent extends RangePickerFromComponent {
    constructor() {
        super(...arguments);
        this.view = PickerViewType.DateTime;
    }
    set fsDateTimeRangeFrom(value) {
        this._name = value;
    }
    set fsDateTimeRangeFromPicker(value) {
        this._name = value;
    }
    updateValue(value) {
        this._pickerRef.updateStartDate(value);
        super.updateValue(value);
    }
}
DateTimeRangePickerFromComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DateTimeRangePickerFromComponent, deps: null, target: i0.ɵɵFactoryTarget.Component });
DateTimeRangePickerFromComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: DateTimeRangePickerFromComponent, selector: "[fsDateTimeRangeFrom],[fsDateTimeRangeFromPicker]", inputs: { fsDateTimeRangeFrom: "fsDateTimeRangeFrom", fsDateTimeRangeFromPicker: "fsDateTimeRangeFromPicker", view: "view" }, usesInheritance: true, ngImport: i0, template: "\n    <fs-clear [show]=\"value && !disabled && !readonly && clear\" (clear)=\"cleared($event)\"></fs-clear>\n    <fs-datepicker-trigger (click)=\"triggerClick()\" [disabled]=\"disabled || readonly\" [view]=\"view\"></fs-datepicker-trigger>\n  ", isInline: true, components: [{ type: i1$7.FsClearElementComponent, selector: "fs-clear", inputs: ["show"], outputs: ["clear"] }, { type: FsDatePickerTriggerComponent, selector: "fs-datepicker-trigger", inputs: ["disabled", "view"], outputs: ["click"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DateTimeRangePickerFromComponent, decorators: [{
            type: Component,
            args: [{
                    selector: '[fsDateTimeRangeFrom],[fsDateTimeRangeFromPicker]',
                    template: FsDatePickerComponent.template,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], propDecorators: { fsDateTimeRangeFrom: [{
                type: Input
            }], fsDateTimeRangeFromPicker: [{
                type: Input
            }], view: [{
                type: Input
            }] } });

class RangePickerToComponent extends RangePickerComponent {
    constructor(_elRef, _injector, _datepickerFactory, _cdRef, _ngControl, _rangePickerStore) {
        super(_elRef, _injector, _datepickerFactory, 'to', _cdRef, _ngControl);
        this._elRef = _elRef;
        this._injector = _injector;
        this._datepickerFactory = _datepickerFactory;
        this._cdRef = _cdRef;
        this._ngControl = _ngControl;
        this._rangePickerStore = _rangePickerStore;
        /** The form control validator for whether the input parses. */
        this._parseValidator = () => {
            return this._pickerRef.isRangeValid
                ? null
                : { fsDatepickerRange: 'Invalid Range' };
        };
    }
    ngOnInit() {
        this.registerPicker();
        this._subscribeToPickerRefUpdates();
        super.ngOnInit();
    }
    ngOnDestroy() {
        this._rangePickerStore.destroyEndDatePicker(this.name);
        this._destroy$.next();
        this._destroy$.complete();
    }
    registerPicker() {
        this._pickerRef = this._rangePickerStore.registerPickerTo(this.name, this.value, this.view);
    }
    writeValue(value) {
        // Hot fix while angular has ongoing issue
        // https://github.com/angular/angular/issues/29218
        if (!this.onChange) {
            return;
        }
        super.writeValue(value);
        const [valuesAreDates] = this._checkValuesEquality(this.value, this._pickerRef.endDate);
        if ((valuesAreDates && !this._pickerRef.sameAsEndDate(this.value)) || !valuesAreDates) {
            this._pickerRef.updateEndDate(this.value);
        }
    }
    cleared(event) {
        if (event) {
            event.stopPropagation();
            event.preventDefault();
        }
        this.writeValue(null);
        this.onChange(this.value);
        this.onTouch(this.value);
    }
    /**
     * Set value which was selected in dialog
     * @param value
     */
    updateValueFromDialog(value) {
        this.updateValue(value);
        super.updateValueFromDialog(this._pickerRef.endDate);
    }
    updateValue(value) {
        if (this.view === PickerViewType.Date) {
            value = endOfDay(value);
        }
        this._pickerRef.updateEndDate(value);
        super.updateValue(value);
    }
    _tzChanged(originDate) {
        var _a;
        super._tzChanged(originDate);
        (_a = this._pickerRef) === null || _a === void 0 ? void 0 : _a.updateEndDate(this.value);
    }
    _processInputDate(date) {
        date = super._processInputDate(date);
        if (this.view === PickerViewType.Date && date) {
            date = endOfDay(date);
        }
        return date;
    }
    _subscribeToPickerRefUpdates() {
        this._pickerRefUpdates$(this._pickerRef.startDate$)
            .pipe(takeUntil(this._destroy$))
            .subscribe((value) => {
            if (!this._pickerRef.isRangeValid) {
                this.cleared();
            }
            if (this.value) {
                this._ngControl.control.markAsDirty();
                this._ngControl.control.updateValueAndValidity();
            }
            this._cdRef.markForCheck();
        });
    }
}
RangePickerToComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: RangePickerToComponent, deps: [{ token: i0.ElementRef }, { token: i0.Injector }, { token: FsDatePickerDialogFactory }, { token: i0.ChangeDetectorRef }, { token: i2.NgControl, optional: true, self: true }, { token: FsRangePickerStoreService }], target: i0.ɵɵFactoryTarget.Directive });
RangePickerToComponent.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: RangePickerToComponent, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: RangePickerToComponent, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.Injector }, { type: FsDatePickerDialogFactory }, { type: i0.ChangeDetectorRef }, { type: i2.NgControl, decorators: [{
                    type: Optional
                }, {
                    type: Self
                }] }, { type: FsRangePickerStoreService }]; } });

class DateTimeRangePickerToComponent extends RangePickerToComponent {
    constructor() {
        super(...arguments);
        this.view = PickerViewType.DateTime;
    }
    set fsDateTimeRangeTo(value) {
        this._name = value;
    }
    set fsDateTimeRangeToPicker(value) {
        this._name = value;
    }
}
DateTimeRangePickerToComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DateTimeRangePickerToComponent, deps: null, target: i0.ɵɵFactoryTarget.Component });
DateTimeRangePickerToComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: DateTimeRangePickerToComponent, selector: "[fsDateTimeRangeTo],[fsDateTimeRangeToPicker]", inputs: { fsDateTimeRangeTo: "fsDateTimeRangeTo", fsDateTimeRangeToPicker: "fsDateTimeRangeToPicker", view: "view" }, usesInheritance: true, ngImport: i0, template: "\n    <fs-clear [show]=\"value && !disabled && !readonly && clear\" (clear)=\"cleared($event)\"></fs-clear>\n    <fs-datepicker-trigger (click)=\"triggerClick()\" [disabled]=\"disabled || readonly\" [view]=\"view\"></fs-datepicker-trigger>\n  ", isInline: true, components: [{ type: i1$7.FsClearElementComponent, selector: "fs-clear", inputs: ["show"], outputs: ["clear"] }, { type: FsDatePickerTriggerComponent, selector: "fs-datepicker-trigger", inputs: ["disabled", "view"], outputs: ["click"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DateTimeRangePickerToComponent, decorators: [{
            type: Component,
            args: [{
                    selector: '[fsDateTimeRangeTo],[fsDateTimeRangeToPicker]',
                    template: FsDatePickerComponent.template,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], propDecorators: { fsDateTimeRangeTo: [{
                type: Input
            }], fsDateTimeRangeToPicker: [{
                type: Input
            }], view: [{
                type: Input
            }] } });

class TimeRangePickerFromComponent extends RangePickerFromComponent {
    constructor() {
        super(...arguments);
        this.view = PickerViewType.Time;
    }
    set fsTimeRangeFrom(value) {
        this._name = value;
    }
    set fsTimeRangeFromPicker(value) {
        this._name = value;
    }
    updateValue(value) {
        this._pickerRef.updateStartDate(value);
        super.updateValue(value);
    }
}
TimeRangePickerFromComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TimeRangePickerFromComponent, deps: null, target: i0.ɵɵFactoryTarget.Component });
TimeRangePickerFromComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: TimeRangePickerFromComponent, selector: "[fsTimeRangeFrom],[fsTimeRangeFromPicker]", inputs: { fsTimeRangeFrom: "fsTimeRangeFrom", fsTimeRangeFromPicker: "fsTimeRangeFromPicker", view: "view" }, usesInheritance: true, ngImport: i0, template: "\n    <fs-clear [show]=\"value && !disabled && !readonly && clear\" (clear)=\"cleared($event)\"></fs-clear>\n    <fs-datepicker-trigger (click)=\"triggerClick()\" [disabled]=\"disabled || readonly\" [view]=\"view\"></fs-datepicker-trigger>\n  ", isInline: true, components: [{ type: i1$7.FsClearElementComponent, selector: "fs-clear", inputs: ["show"], outputs: ["clear"] }, { type: FsDatePickerTriggerComponent, selector: "fs-datepicker-trigger", inputs: ["disabled", "view"], outputs: ["click"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TimeRangePickerFromComponent, decorators: [{
            type: Component,
            args: [{
                    selector: '[fsTimeRangeFrom],[fsTimeRangeFromPicker]',
                    template: FsDatePickerComponent.template,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], propDecorators: { fsTimeRangeFrom: [{
                type: Input
            }], fsTimeRangeFromPicker: [{
                type: Input
            }], view: [{
                type: Input
            }] } });

class TimeRangePickerToComponent extends RangePickerToComponent {
    constructor() {
        super(...arguments);
        this.view = PickerViewType.Time;
    }
    set fsTimeRangeTo(value) {
        this._name = value;
    }
    set fsTimeRangeToPicker(value) {
        this._name = value;
    }
}
TimeRangePickerToComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TimeRangePickerToComponent, deps: null, target: i0.ɵɵFactoryTarget.Component });
TimeRangePickerToComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: TimeRangePickerToComponent, selector: "[fsTimeRangeTo],[fsTimeRangeToPicker]", inputs: { fsTimeRangeTo: "fsTimeRangeTo", fsTimeRangeToPicker: "fsTimeRangeToPicker", view: "view" }, usesInheritance: true, ngImport: i0, template: "\n    <fs-clear [show]=\"value && !disabled && !readonly && clear\" (clear)=\"cleared($event)\"></fs-clear>\n    <fs-datepicker-trigger (click)=\"triggerClick()\" [disabled]=\"disabled || readonly\" [view]=\"view\"></fs-datepicker-trigger>\n  ", isInline: true, components: [{ type: i1$7.FsClearElementComponent, selector: "fs-clear", inputs: ["show"], outputs: ["clear"] }, { type: FsDatePickerTriggerComponent, selector: "fs-datepicker-trigger", inputs: ["disabled", "view"], outputs: ["click"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TimeRangePickerToComponent, decorators: [{
            type: Component,
            args: [{
                    selector: '[fsTimeRangeTo],[fsTimeRangeToPicker]',
                    template: FsDatePickerComponent.template,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], propDecorators: { fsTimeRangeTo: [{
                type: Input
            }], fsTimeRangeToPicker: [{
                type: Input
            }], view: [{
                type: Input
            }] } });

class DateRangePickerFromComponent extends RangePickerFromComponent {
    set fsDateRangeFrom(value) {
        this._name = value;
    }
    set fsDateRangeFromPicker(value) {
        this._name = value;
    }
}
DateRangePickerFromComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DateRangePickerFromComponent, deps: null, target: i0.ɵɵFactoryTarget.Component });
DateRangePickerFromComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: DateRangePickerFromComponent, selector: "[fsDateRangeFrom],[fsDateRangeFromPicker]", inputs: { fsDateRangeFrom: "fsDateRangeFrom", fsDateRangeFromPicker: "fsDateRangeFromPicker" }, usesInheritance: true, ngImport: i0, template: "\n    <fs-clear [show]=\"value && !disabled && !readonly && clear\" (clear)=\"cleared($event)\"></fs-clear>\n    <fs-datepicker-trigger (click)=\"triggerClick()\" [disabled]=\"disabled || readonly\" [view]=\"view\"></fs-datepicker-trigger>\n  ", isInline: true, components: [{ type: i1$7.FsClearElementComponent, selector: "fs-clear", inputs: ["show"], outputs: ["clear"] }, { type: FsDatePickerTriggerComponent, selector: "fs-datepicker-trigger", inputs: ["disabled", "view"], outputs: ["click"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DateRangePickerFromComponent, decorators: [{
            type: Component,
            args: [{
                    selector: '[fsDateRangeFrom],[fsDateRangeFromPicker]',
                    template: FsDatePickerComponent.template,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], propDecorators: { fsDateRangeFrom: [{
                type: Input
            }], fsDateRangeFromPicker: [{
                type: Input
            }] } });

class DateRangePickerToComponent extends RangePickerToComponent {
    set fsDateRangeTo(value) {
        this._name = value;
    }
    set fsDateRangeToPicker(value) {
        this._name = value;
    }
}
DateRangePickerToComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DateRangePickerToComponent, deps: null, target: i0.ɵɵFactoryTarget.Component });
DateRangePickerToComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: DateRangePickerToComponent, selector: "[fsDateRangeTo],[fsDateRangeToPicker]", inputs: { fsDateRangeTo: "fsDateRangeTo", fsDateRangeToPicker: "fsDateRangeToPicker" }, usesInheritance: true, ngImport: i0, template: "\n    <fs-clear [show]=\"value && !disabled && !readonly && clear\" (clear)=\"cleared($event)\"></fs-clear>\n    <fs-datepicker-trigger (click)=\"triggerClick()\" [disabled]=\"disabled || readonly\" [view]=\"view\"></fs-datepicker-trigger>\n  ", isInline: true, components: [{ type: i1$7.FsClearElementComponent, selector: "fs-clear", inputs: ["show"], outputs: ["clear"] }, { type: FsDatePickerTriggerComponent, selector: "fs-datepicker-trigger", inputs: ["disabled", "view"], outputs: ["click"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DateRangePickerToComponent, decorators: [{
            type: Component,
            args: [{
                    selector: '[fsDateRangeTo],[fsDateRangeToPicker]',
                    template: FsDatePickerComponent.template,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], propDecorators: { fsDateRangeTo: [{
                type: Input
            }], fsDateRangeToPicker: [{
                type: Input
            }] } });

class FsDateScrollPickerComponent extends FsDatePickerBaseComponent {
    constructor(renderer, injector, elementRef, _datepickerFactory, _cdRef) {
        super(renderer, elementRef, _cdRef);
        this.renderer = renderer;
        this.injector = injector;
        this.elementRef = elementRef;
        this._datepickerFactory = _datepickerFactory;
        this._cdRef = _cdRef;
        this.minYear = (new Date()).getFullYear() - 50;
        this.maxYear = (new Date()).getFullYear() + 50;
        this.showMonth = true;
        this.showYear = true;
        this.showDay = true;
        this.view = ScrollPickerViewType.Date;
    }
    writeValue(value) {
        this._originValue = value;
        this._value = createDateFromValue(value, this.timezone);
        this.validateDate(this.value);
        this.updateInput(value);
        this._cdRef.markForCheck();
    }
    updateInput(value) {
        let format = ScrollPickerViewType.Date;
        if (this.showYear && this.showMonth && !this.showDay) {
            format = ScrollPickerViewType.MonthYear;
        }
        else if (!this.showYear && this.showMonth && this.showDay) {
            format = ScrollPickerViewType.MonthDay;
        }
        else if (!this.showYear && this.showMonth && !this.showDay) {
            format = ScrollPickerViewType.Month;
        }
        else if (this.showYear && !this.showMonth && !this.showDay) {
            format = ScrollPickerViewType.Year;
        }
        this.elementRef.nativeElement.value = formatDateTime(value, format);
    }
    open() {
        if (this._dateDialogRef || this.disabled || this.readonly) {
            return;
        }
        this._dateDialogRef = this._datepickerFactory.openDateScrollPicker(this.elementRef, this.injector, {
            modelValue: this.value,
            minYear: this.minYear,
            maxYear: this.maxYear,
            maxDate: this.maxDate,
            showMonth: this.showMonth,
            showDay: this.showDay,
            showYear: this.showYear,
            view: this.view,
        });
        super.open();
    }
}
FsDateScrollPickerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDateScrollPickerComponent, deps: [{ token: i0.Renderer2 }, { token: i0.Injector }, { token: ElementRef }, { token: FsDatePickerDialogFactory }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
FsDateScrollPickerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: FsDateScrollPickerComponent, selector: "[fsDateScrollPicker]", inputs: { minYear: "minYear", maxYear: "maxYear", maxDate: "maxDate", showMonth: "showMonth", showYear: "showYear", showDay: "showDay" }, providers: [{
            provide: NG_VALUE_ACCESSOR,
            useExisting: forwardRef(() => FsDateScrollPickerComponent),
            multi: true
        }], usesInheritance: true, ngImport: i0, template: "\n    <fs-clear [show]=\"value && !disabled && !readonly && clear\" (clear)=\"cleared($event)\"></fs-clear>\n    <fs-datepicker-trigger (click)=\"triggerClick()\" [disabled]=\"disabled || readonly\" [view]=\"view\"></fs-datepicker-trigger>\n  ", isInline: true, components: [{ type: i1$7.FsClearElementComponent, selector: "fs-clear", inputs: ["show"], outputs: ["clear"] }, { type: FsDatePickerTriggerComponent, selector: "fs-datepicker-trigger", inputs: ["disabled", "view"], outputs: ["click"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDateScrollPickerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: '[fsDateScrollPicker]',
                    template: FsDatePickerComponent.template,
                    providers: [{
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(() => FsDateScrollPickerComponent),
                            multi: true
                        }],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }, { type: i0.Injector }, { type: i0.ElementRef, decorators: [{
                    type: Inject,
                    args: [ElementRef]
                }] }, { type: FsDatePickerDialogFactory }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { minYear: [{
                type: Input
            }], maxYear: [{
                type: Input
            }], maxDate: [{
                type: Input
            }], showMonth: [{
                type: Input
            }], showYear: [{
                type: Input
            }], showDay: [{
                type: Input
            }] } });

class FsDatePickerBirthdayComponent extends FsDateScrollPickerComponent {
    constructor(renderer, injector, elementRef, _datepickerFactory, _cdRef) {
        super(renderer, injector, elementRef, _datepickerFactory, _cdRef);
        this.minYear = (new Date()).getFullYear() - 120;
        this.maxYear = (new Date()).getFullYear();
    }
}
FsDatePickerBirthdayComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerBirthdayComponent, deps: [{ token: i0.Renderer2 }, { token: i0.Injector }, { token: i0.ElementRef }, { token: FsDatePickerDialogFactory }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
FsDatePickerBirthdayComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: FsDatePickerBirthdayComponent, selector: "[fsDatePickerBirthday]", inputs: { minYear: "minYear", maxYear: "maxYear" }, providers: [{
            provide: NG_VALUE_ACCESSOR,
            useExisting: forwardRef(() => FsDatePickerBirthdayComponent),
            multi: true
        }], usesInheritance: true, ngImport: i0, template: "\n    <fs-clear [show]=\"value && !disabled && !readonly && clear\" (clear)=\"cleared($event)\"></fs-clear>\n    <fs-datepicker-trigger (click)=\"triggerClick()\" [disabled]=\"disabled || readonly\" [view]=\"view\"></fs-datepicker-trigger>\n  ", isInline: true, components: [{ type: i1$7.FsClearElementComponent, selector: "fs-clear", inputs: ["show"], outputs: ["clear"] }, { type: FsDatePickerTriggerComponent, selector: "fs-datepicker-trigger", inputs: ["disabled", "view"], outputs: ["click"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerBirthdayComponent, decorators: [{
            type: Component,
            args: [{
                    selector: '[fsDatePickerBirthday]',
                    template: FsDatePickerComponent.template,
                    providers: [{
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(() => FsDatePickerBirthdayComponent),
                            multi: true
                        }],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }, { type: i0.Injector }, { type: i0.ElementRef }, { type: FsDatePickerDialogFactory }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { minYear: [{
                type: Input
            }], maxYear: [{
                type: Input
            }] } });

class FsDateWeekPickerComponent extends FsDatePickerBaseComponent {
    constructor(renderer, injector, elementRef, _cdRef, fsDatepickerFactory) {
        super(renderer, elementRef, _cdRef);
        this.renderer = renderer;
        this.injector = injector;
        this.elementRef = elementRef;
        this._cdRef = _cdRef;
        this.fsDatepickerFactory = fsDatepickerFactory;
        this.minYear = null;
        this.maxYear = null;
        this.minDate = null;
        this.maxDate = null;
        this.seedDate = null;
        this.periodWeeks = 1;
        this.view = PickerViewType.Week;
        this.change$ = new EventEmitter();
    }
    inputClick() {
        if (!this.disabled && !this.readonly) {
            this.open();
        }
    }
    ngAfterViewInit() {
        this.setReadonly();
    }
    writeValue(value) {
        this._value = value;
        this.validateDate(this.value);
        this.updateInput(value);
        this._cdRef.markForCheck();
    }
    updateInput(value) {
        if (value && isDate(value.from) && isDate(value.to)) {
            if (value.from.getFullYear() == value.to.getFullYear()) {
                const from = format(value.from, 'MMM d');
                const to = format(value.to, 'MMM d yyyy');
                this.elementRef.nativeElement.value = `#${value.period}: ${from} - ${to}`;
            }
            else {
                const from = format(value.from, 'MMM d yyyy');
                const to = format(value.to, 'MMM d yyyy');
                this.elementRef.nativeElement.value = `#${value.period}: ${from} - ${to}`;
            }
        }
        else {
            this.elementRef.nativeElement.value = '';
        }
    }
    open() {
        if (this._dateDialogRef) {
            return;
        }
        this._dateDialogRef = this.fsDatepickerFactory.openDatePicker(this.elementRef, this.injector, {
            modelValue: this.value,
            view: this.view,
            minYear: this.minYear,
            maxYear: this.maxYear,
            minDate: this.minDate,
            maxDate: this.maxDate,
            components: this._getDefaultComponents(),
            seedDate: this.seedDate,
            periodWeeks: this.periodWeeks,
        });
        super.open();
    }
    _getDefaultComponents() {
        if (this.view === 'time') {
            return { timeStart: true };
        }
        else {
            return { calendarStart: true };
        }
    }
}
FsDateWeekPickerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDateWeekPickerComponent, deps: [{ token: i0.Renderer2 }, { token: i0.Injector }, { token: ElementRef }, { token: i0.ChangeDetectorRef }, { token: FsDatePickerDialogFactory }], target: i0.ɵɵFactoryTarget.Component });
FsDateWeekPickerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: FsDateWeekPickerComponent, selector: "[fsDateWeekPicker]", inputs: { minYear: "minYear", maxYear: "maxYear", minDate: "minDate", maxDate: "maxDate", seedDate: "seedDate", periodWeeks: "periodWeeks", view: "view" }, outputs: { change$: "change" }, host: { listeners: { "click": "inputClick()", "focus": "inputClick()" } }, providers: [{
            provide: NG_VALUE_ACCESSOR,
            useExisting: forwardRef(() => FsDateWeekPickerComponent),
            multi: true
        }], usesInheritance: true, ngImport: i0, template: "\n    <fs-clear [show]=\"value && !disabled && !readonly && clear\" (clear)=\"cleared($event)\"></fs-clear>\n    <fs-datepicker-trigger (click)=\"triggerClick()\" [disabled]=\"disabled || readonly\" [view]=\"view\"></fs-datepicker-trigger>\n  ", isInline: true, components: [{ type: i1$7.FsClearElementComponent, selector: "fs-clear", inputs: ["show"], outputs: ["clear"] }, { type: FsDatePickerTriggerComponent, selector: "fs-datepicker-trigger", inputs: ["disabled", "view"], outputs: ["click"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDateWeekPickerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: '[fsDateWeekPicker]',
                    template: FsDatePickerComponent.template,
                    providers: [{
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(() => FsDateWeekPickerComponent),
                            multi: true
                        }],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }, { type: i0.Injector }, { type: i0.ElementRef, decorators: [{
                    type: Inject,
                    args: [ElementRef]
                }] }, { type: i0.ChangeDetectorRef }, { type: FsDatePickerDialogFactory }]; }, propDecorators: { minYear: [{
                type: Input
            }], maxYear: [{
                type: Input
            }], minDate: [{
                type: Input
            }], maxDate: [{
                type: Input
            }], seedDate: [{
                type: Input
            }], periodWeeks: [{
                type: Input
            }], view: [{
                type: Input
            }], change$: [{
                type: Output,
                args: ['change']
            }], inputClick: [{
                type: HostListener,
                args: ['click']
            }, {
                type: HostListener,
                args: ['focus']
            }] } });

class FsDateTimePickerComponent extends FsDatePickerComponent {
    constructor() {
        super(...arguments);
        this.view = PickerViewType.DateTime;
    }
}
FsDateTimePickerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDateTimePickerComponent, deps: null, target: i0.ɵɵFactoryTarget.Component });
FsDateTimePickerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: FsDateTimePickerComponent, selector: "[fsDateTimePicker]", inputs: { view: "view" }, providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: forwardRef(() => FsDateTimePickerComponent),
            multi: true,
        },
        {
            provide: NG_VALIDATORS,
            useExisting: forwardRef(() => FsDateTimePickerComponent),
            multi: true,
        },
    ], usesInheritance: true, ngImport: i0, template: "\n    <fs-clear [show]=\"value && !disabled && !readonly && clear\" (clear)=\"cleared($event)\"></fs-clear>\n    <fs-datepicker-trigger (click)=\"triggerClick()\" [disabled]=\"disabled || readonly\" [view]=\"view\"></fs-datepicker-trigger>\n  ", isInline: true, components: [{ type: i1$7.FsClearElementComponent, selector: "fs-clear", inputs: ["show"], outputs: ["clear"] }, { type: FsDatePickerTriggerComponent, selector: "fs-datepicker-trigger", inputs: ["disabled", "view"], outputs: ["click"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDateTimePickerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: '[fsDateTimePicker]',
                    template: FsDatePickerComponent.template,
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(() => FsDateTimePickerComponent),
                            multi: true,
                        },
                        {
                            provide: NG_VALIDATORS,
                            useExisting: forwardRef(() => FsDateTimePickerComponent),
                            multi: true,
                        },
                    ],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], propDecorators: { view: [{
                type: Input
            }] } });

class FsTimePickerComponent extends FsDatePickerComponent {
    constructor() {
        super(...arguments);
        this.view = PickerViewType.Time;
    }
}
FsTimePickerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsTimePickerComponent, deps: null, target: i0.ɵɵFactoryTarget.Component });
FsTimePickerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: FsTimePickerComponent, selector: "[fsTimePicker]", inputs: { view: "view" }, providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: forwardRef(() => FsTimePickerComponent),
            multi: true
        },
        {
            provide: NG_VALIDATORS,
            useExisting: forwardRef(() => FsTimePickerComponent),
            multi: true,
        },
    ], usesInheritance: true, ngImport: i0, template: "\n    <fs-clear [show]=\"value && !disabled && !readonly && clear\" (clear)=\"cleared($event)\"></fs-clear>\n    <fs-datepicker-trigger (click)=\"triggerClick()\" [disabled]=\"disabled || readonly\" [view]=\"view\"></fs-datepicker-trigger>\n  ", isInline: true, components: [{ type: i1$7.FsClearElementComponent, selector: "fs-clear", inputs: ["show"], outputs: ["clear"] }, { type: FsDatePickerTriggerComponent, selector: "fs-datepicker-trigger", inputs: ["disabled", "view"], outputs: ["click"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsTimePickerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: '[fsTimePicker]',
                    template: FsDatePickerComponent.template,
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(() => FsTimePickerComponent),
                            multi: true
                        },
                        {
                            provide: NG_VALIDATORS,
                            useExisting: forwardRef(() => FsTimePickerComponent),
                            multi: true,
                        },
                    ],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], propDecorators: { view: [{
                type: Input
            }] } });

class MonthRangePickerFromComponent extends RangePickerFromComponent {
    constructor() {
        super(...arguments);
        this.view = PickerViewType.MonthRange;
        this._skipUpdateValue = false;
    }
    set fsMonthRangeFrom(value) {
        this._name = value;
    }
    set fsMonthRangeFromPicker(value) {
        this._name = value;
    }
    ngOnInit() {
        super.ngOnInit();
        this._subscribeToPickerRefUpdates();
    }
    cleared(event) {
        super.cleared(event);
        this._pickerRef.updateEndDate(null);
    }
    updateValue(value) {
        value = startOfDay(value);
        this._value = value;
        this.updateInput(this._value);
        if (value && this.timezone) {
            value = zonedTimeToUtc(value, this.timezone);
        }
        this.onChange(value);
        this.onTouch(value);
    }
    _tzChanged(originDate) {
        this._skipUpdateValue = true;
        super._tzChanged(originDate);
    }
    _processInputDate(date) {
        date = super._processInputDate(date);
        if (date) {
            date = startOfDay(date);
        }
        return date;
    }
    /**
     * When it's month range picker - we have to listen changes over rangePickerRef
     */
    _listenDialogValueChanges() {
        // NOOP
    }
    _subscribeToPickerRefUpdates() {
        this._pickerRefUpdates$(this._pickerRef.startDate$)
            .pipe(takeUntil(this._destroy$))
            .subscribe((newValue) => {
            if (this._skipUpdateValue) {
                this._skipUpdateValue = false;
                return;
            }
            this.updateValue(newValue);
            this._ngControl.control.markAsDirty();
            this._ngControl.control.updateValueAndValidity();
            this._cdRef.markForCheck();
        });
    }
}
MonthRangePickerFromComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: MonthRangePickerFromComponent, deps: null, target: i0.ɵɵFactoryTarget.Component });
MonthRangePickerFromComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: MonthRangePickerFromComponent, selector: "[fsMonthRangeFrom],[fsMonthRangeFromPicker]", inputs: { fsMonthRangeFrom: "fsMonthRangeFrom", fsMonthRangeFromPicker: "fsMonthRangeFromPicker" }, usesInheritance: true, ngImport: i0, template: "\n    <fs-clear [show]=\"value && !disabled && !readonly && clear\" (clear)=\"cleared($event)\"></fs-clear>\n    <fs-datepicker-trigger (click)=\"triggerClick()\" [disabled]=\"disabled || readonly\" [view]=\"view\"></fs-datepicker-trigger>\n  ", isInline: true, components: [{ type: i1$7.FsClearElementComponent, selector: "fs-clear", inputs: ["show"], outputs: ["clear"] }, { type: FsDatePickerTriggerComponent, selector: "fs-datepicker-trigger", inputs: ["disabled", "view"], outputs: ["click"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: MonthRangePickerFromComponent, decorators: [{
            type: Component,
            args: [{
                    selector: '[fsMonthRangeFrom],[fsMonthRangeFromPicker]',
                    template: FsDatePickerComponent.template,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], propDecorators: { fsMonthRangeFrom: [{
                type: Input
            }], fsMonthRangeFromPicker: [{
                type: Input
            }] } });

class MonthRangePickerToComponent extends RangePickerToComponent {
    constructor() {
        super(...arguments);
        this.view = PickerViewType.MonthRange;
        this._skipUpdateValue = false;
    }
    set fsMonthRangeTo(value) {
        this._name = value;
    }
    set fsMonthRangeToPicker(value) {
        this._name = value;
    }
    updateValue(value) {
        if (value) {
            value = endOfDay(value);
        }
        this._value = value;
        this.updateInput(this._value);
        if (value && this.timezone) {
            value = zonedTimeToUtc(value, this.timezone);
        }
        this.onChange(value);
        this.onTouch(value);
    }
    _tzChanged(originDate) {
        this._skipUpdateValue = true;
        super._tzChanged(originDate);
    }
    _processInputDate(date) {
        date = super._processInputDate(date);
        if (date) {
            date = endOfDay(date);
        }
        return date;
    }
    /**
     * When it's month range picker - we have to listen changes over rangePickerRef
     */
    _listenDialogValueChanges() {
        // NOOP
    }
    _subscribeToPickerRefUpdates() {
        this._pickerRefUpdates$(this._pickerRef.endDate$)
            .pipe(takeUntil(this._destroy$))
            .subscribe((newValue) => {
            if (this._skipUpdateValue) {
                this._skipUpdateValue = false;
                return;
            }
            this.updateValue(newValue);
            this._ngControl.control.markAsDirty();
            this._ngControl.control.updateValueAndValidity();
            this._cdRef.markForCheck();
        });
    }
}
MonthRangePickerToComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: MonthRangePickerToComponent, deps: null, target: i0.ɵɵFactoryTarget.Component });
MonthRangePickerToComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: MonthRangePickerToComponent, selector: "[fsMonthRangeTo],[fsMonthRangeToPicker]", inputs: { fsMonthRangeTo: "fsMonthRangeTo", fsMonthRangeToPicker: "fsMonthRangeToPicker" }, usesInheritance: true, ngImport: i0, template: "\n    <fs-clear [show]=\"value && !disabled && !readonly && clear\" (clear)=\"cleared($event)\"></fs-clear>\n    <fs-datepicker-trigger (click)=\"triggerClick()\" [disabled]=\"disabled || readonly\" [view]=\"view\"></fs-datepicker-trigger>\n  ", isInline: true, components: [{ type: i1$7.FsClearElementComponent, selector: "fs-clear", inputs: ["show"], outputs: ["clear"] }, { type: FsDatePickerTriggerComponent, selector: "fs-datepicker-trigger", inputs: ["disabled", "view"], outputs: ["click"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: MonthRangePickerToComponent, decorators: [{
            type: Component,
            args: [{
                    selector: '[fsMonthRangeTo],[fsMonthRangeToPicker]',
                    template: FsDatePickerComponent.template,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], propDecorators: { fsMonthRangeTo: [{
                type: Input
            }], fsMonthRangeToPicker: [{
                type: Input
            }] } });

class FsDatePickerModule {
    static forRoot() {
        return {
            ngModule: FsDatePickerModule,
            providers: [
                [...FsDatePickerDialogModule.forRoot().providers],
                FsRangePickerStoreService,
            ]
        };
    }
}
FsDatePickerModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
FsDatePickerModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerModule, declarations: [FsDatePickerComponent,
        DateRangeSeparatorComponent,
        DateRangePickerFromComponent,
        DateRangePickerToComponent,
        FsDateScrollPickerComponent,
        FsDatePickerBirthdayComponent,
        FsDatePickerTriggerComponent,
        FsDateWeekPickerComponent,
        FsTimePickerComponent,
        DateTimeRangePickerFromComponent,
        DateTimeRangePickerToComponent,
        FsDateTimePickerComponent,
        TimeRangePickerFromComponent,
        TimeRangePickerToComponent,
        MonthRangePickerFromComponent,
        MonthRangePickerToComponent], imports: [CommonModule,
        FormsModule,
        MatButtonModule,
        MatTabsModule,
        MatIconModule,
        MatMenuModule,
        MatSelectModule,
        LayoutModule,
        FsClearModule,
        FsScrollPickerModule,
        FsDatePickerCalendarModule], exports: [FsDatePickerComponent,
        DateRangeSeparatorComponent,
        DateRangePickerFromComponent,
        DateRangePickerToComponent,
        FsDateScrollPickerComponent,
        FsDatePickerBirthdayComponent,
        FsDateWeekPickerComponent,
        FsTimePickerComponent,
        DateTimeRangePickerFromComponent,
        DateTimeRangePickerToComponent,
        FsDateTimePickerComponent,
        TimeRangePickerFromComponent,
        TimeRangePickerToComponent,
        MonthRangePickerFromComponent,
        MonthRangePickerToComponent] });
FsDatePickerModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerModule, imports: [[
            CommonModule,
            FormsModule,
            MatButtonModule,
            MatTabsModule,
            MatIconModule,
            MatMenuModule,
            MatSelectModule,
            LayoutModule,
            FsClearModule,
            FsScrollPickerModule,
            FsDatePickerCalendarModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePickerModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        FormsModule,
                        MatButtonModule,
                        MatTabsModule,
                        MatIconModule,
                        MatMenuModule,
                        MatSelectModule,
                        LayoutModule,
                        FsClearModule,
                        FsScrollPickerModule,
                        FsDatePickerCalendarModule,
                    ],
                    declarations: [
                        FsDatePickerComponent,
                        DateRangeSeparatorComponent,
                        DateRangePickerFromComponent,
                        DateRangePickerToComponent,
                        FsDateScrollPickerComponent,
                        FsDatePickerBirthdayComponent,
                        FsDatePickerTriggerComponent,
                        FsDateWeekPickerComponent,
                        FsTimePickerComponent,
                        DateTimeRangePickerFromComponent,
                        DateTimeRangePickerToComponent,
                        FsDateTimePickerComponent,
                        TimeRangePickerFromComponent,
                        TimeRangePickerToComponent,
                        MonthRangePickerFromComponent,
                        MonthRangePickerToComponent,
                    ],
                    exports: [
                        FsDatePickerComponent,
                        DateRangeSeparatorComponent,
                        DateRangePickerFromComponent,
                        DateRangePickerToComponent,
                        FsDateScrollPickerComponent,
                        FsDatePickerBirthdayComponent,
                        FsDateWeekPickerComponent,
                        FsTimePickerComponent,
                        DateTimeRangePickerFromComponent,
                        DateTimeRangePickerToComponent,
                        FsDateTimePickerComponent,
                        TimeRangePickerFromComponent,
                        TimeRangePickerToComponent,
                        MonthRangePickerFromComponent,
                        MonthRangePickerToComponent,
                    ],
                }]
        }] });

/*
 * Public API Surface of fs-menu
 */

/**
 * Generated bundle index. Do not edit.
 */

export { DateRangePickerFromComponent, DateRangePickerToComponent, DateRangeSeparatorComponent, DateTimeRangePickerFromComponent, DateTimeRangePickerToComponent, FsDatePickerBirthdayComponent, FsDatePickerComponent, FsDatePickerModule, FsDateScrollPickerComponent, FsDateTimePickerComponent, FsDateWeekPickerComponent, FsTimePickerComponent, MonthRangePickerFromComponent, MonthRangePickerToComponent, TimeRangePickerFromComponent, TimeRangePickerToComponent };
//# sourceMappingURL=firestitch-datepicker.js.map
