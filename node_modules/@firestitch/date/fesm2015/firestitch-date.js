import * as i0 from '@angular/core';
import { Pipe, Component, ChangeDetectionStrategy, Input, ComponentFactoryResolver, Injectable, Inject, ViewContainerRef, Directive, NgModule } from '@angular/core';
import * as i1 from '@angular/material/tooltip';
import { MatTooltipModule } from '@angular/material/tooltip';
import { CommonModule } from '@angular/common';
import { FsCommonModule } from '@firestitch/common';
import { isNumber, round } from 'lodash-es';
import { isSameYear, parseISO, isValid, differenceInSeconds, differenceInMinutes, format as format$2, differenceInMilliseconds } from 'date-fns';
import { format as format$1, utcToZonedTime } from 'date-fns-tz';
import { of, Subject, interval } from 'rxjs';
import { takeWhile, takeUntil } from 'rxjs/operators';

function getFormatString(formatTo = 'date', date = null) {
    const formatParts = formatTo.split('-');
    const hasTime = formatParts.indexOf('time') != -1;
    const hasDate = formatParts.indexOf('date') != -1;
    const parts = [];
    if (hasDate || hasTime) {
        if (hasDate) {
            const hasYear = formatParts.indexOf('yearless') === -1;
            const hasYearDiff = formatParts.indexOf('yeardiff') !== -1;
            const sameYear = date && isSameYear(date, new Date());
            const showYear = hasYear &&
                !(hasYearDiff && sameYear);
            // day of week
            if (formatParts.indexOf('day') != -1) {
                parts.push(formatParts.indexOf('full') != -1 ? 'EEEE' : 'EEE');
            }
            // month
            parts.push(formatParts.indexOf('full') != -1 ? 'MMMM' : 'MMM');
            // day
            if (formatParts.indexOf('dayless') === -1) {
                let day = formatParts.indexOf('ordinal') != -1 ? 'do' : 'd';
                if (showYear) {
                    day += ',';
                }
                parts.push(day);
            }
            // year
            if (showYear) {
                parts.push('yyyy');
            }
        }
        if (hasTime) {
            parts.push(formatParts.indexOf('24') != -1 ? 'HH:mm' : 'h:mm aaa');
            // if (formatParts.indexOf('tz') != -1) {
            //   timeFormat += ' [' + moment.tz(date, moment.tz.guess()).format('z') + ']';
            // }
            if (formatParts.indexOf('tz') != -1 || formatParts.indexOf('gmt') != -1) {
                parts.push("'('OOOO')'");
            }
        }
    }
    else {
        parts.push(formatTo);
    }
    return parts.join(' ').trim();
}

function sanitizeDate(date) {
    const matches = date.match(/^(\d{2}:\d{2}:\d{2})(.*)/);
    if (matches) {
        date = `1970-01-01T${matches[1]}${matches[2] || '+00:00'}`;
    }
    return date;
}

function parse(date) {
    if (typeof date === 'string') {
        date = parseISO(sanitizeDate(date));
    }
    return isValid(date) ? date : null;
}

function format(date, formatTo, options = {}) {
    date = parse(date);
    const outputFormat = getFormatString(formatTo, date);
    return date ? format$1(date, outputFormat, { timeZone: options.timezone }) : null;
}

const SECONDS = {
    YEAR: 3600 * 24 * 365,
    MONTH: 3600 * 24 * 30.417,
    DAY: 3600 * 24,
    HOUR: 3600,
    MINUTE: 60
};

function parseDuration(value) {
    let time = 0;
    if (!value && typeof value !== 'string') {
        return of({ error: 'Invalid duration format' });
    }
    value = value
        .trim()
        .replace(/(\d+)\s+/g, '$1')
        .replace(/\s+/, ' ')
        .replace(/^\./, '0.');
    value.split(' ').forEach((chunk) => {
        const matches = chunk.match(/^(\d+\.?\d*)([YMdhms]?)$/);
        if (!matches) {
            return;
        }
        const factor = {
            Y: SECONDS.YEAR,
            M: SECONDS.MONTH,
            d: SECONDS.DAY,
            h: SECONDS.HOUR,
            m: SECONDS.MINUTE,
            s: 1
        }[matches[2]];
        time += Math.round(+matches[1]) * (factor || 1);
    });
    return of({ time: time });
}

function duration(time, options) {
    options = options || {};
    if (typeof options === 'string') {
        options = {
            seconds: !!options.match(/second/),
            minutes: !!options.match(/minute/),
            hours: !!options.match(/hour/),
            days: !!options.match(/day/),
            months: !!options.match(/month/),
            years: !!options.match(/year/),
        };
    }
    if (!isNumber(time)) {
        let parsedResult;
        parseDuration(time).subscribe((result) => {
            parsedResult = result;
        });
        if (parsedResult && parsedResult.error || !parsedResult.time) {
            return 'error';
        }
        else {
            time = parsedResult.time;
        }
        options.unit = 'seconds';
    }
    options = Object.assign({}, options);
    options.unit = options.unit === undefined ? 'seconds' : options.unit;
    options.abr = options.abr === undefined ? true : options.abr;
    options.suffix = options.suffix === true ? (time > 0 ? ' ago' : ' from now') : '';
    options.pad = options.pad === undefined ? false : options.pad;
    options.thousandsSeperator = options.thousandsSeperator === undefined ? true : options.thousandsSeperator;
    if (!options.seconds && !options.minutes && !options.hours && !options.days && !options.months && !options.years) {
        options.seconds = true;
        options.minutes = false;
        options.hours = false;
        options.days = false;
        options.months = false;
        options.years = false;
    }
    else {
        options.seconds = options.seconds === undefined ? false : options.seconds;
        options.minutes = options.minutes === undefined ? false : options.minutes;
        options.hours = options.hours === undefined ? false : options.hours;
        options.days = options.days === undefined ? false : options.days;
        options.months = options.months === undefined ? false : options.months;
        options.years = options.years === undefined ? false : options.years;
    }
    if (options.unit === 'minutes') {
        time = time * 60;
    }
    else if (options.unit === 'hours') {
        time = Math.round(time * 60 * 60);
    }
    time = Math.abs(parseInt(time));
    const units = {
        years: { abr: 'Y', single: 'year', plural: 'years', seconds: SECONDS.YEAR, next: 'months' },
        months: { abr: 'M', single: 'month', plural: 'months', seconds: SECONDS.MONTH, next: 'days' },
        days: { abr: 'd', single: 'day', plural: 'days', seconds: SECONDS.DAY, next: 'hours' },
        hours: { abr: 'h', single: 'hour', plural: 'hours', seconds: SECONDS.HOUR, next: 'months' },
        minutes: { abr: 'm', single: 'minute', plural: 'minutes', seconds: SECONDS.MINUTE, next: 'seconds' },
        seconds: { abr: 's', single: 'second', plural: 'seconds', seconds: 1, next: null },
    };
    const pieces = {
        years: 0,
        months: 0,
        days: 0,
        hours: 0,
        minutes: 0,
        seconds: 0
    };
    let remainder = time;
    if (options.years) {
        const years = remainder / SECONDS.YEAR;
        if (years >= 1) {
            if (!options.months && !options.days && !options.hours && !options.minutes && !options.seconds) {
                pieces.years = Math.round(years);
            }
            else {
                pieces.years = Math.floor(years);
            }
            remainder = remainder - (pieces.years * SECONDS.YEAR);
        }
    }
    if (options.months) {
        const months = remainder / SECONDS.MONTH;
        if (months >= 1) {
            if (!options.days && !options.hours && !options.minutes && !options.seconds) {
                pieces.months = Math.round(months);
            }
            else {
                pieces.months = Math.floor(months);
            }
            remainder = remainder - (pieces.months * SECONDS.MONTH);
        }
    }
    if (options.days) {
        const days = remainder / SECONDS.DAY;
        if (days >= 1) {
            if (!options.hours && !options.minutes && !options.seconds) {
                pieces.days = Math.round(days);
            }
            else {
                pieces.days = Math.floor(days);
            }
            remainder = remainder - (pieces.days * SECONDS.DAY);
        }
    }
    if (options.hours) {
        const hours = remainder / SECONDS.HOUR;
        if (hours >= 1) {
            if (!options.minutes && !options.seconds) {
                pieces.hours = Math.round(hours);
            }
            else {
                pieces.hours = Math.floor(hours);
            }
            remainder = remainder - (pieces.hours * SECONDS.HOUR);
        }
    }
    if (options.minutes) {
        const minutes = remainder / 60;
        if (minutes >= 1) {
            if (!options.seconds) {
                pieces.minutes = Math.round(minutes);
            }
            else {
                pieces.minutes = Math.floor(minutes);
            }
            remainder = remainder - (pieces.minutes * SECONDS.MINUTE);
        }
    }
    pieces.seconds = Math.round(remainder);
    const enabled = [];
    let totalSeconds = 0;
    for (const name in units) {
        if (units.hasOwnProperty(name)) {
            if (options[name]) {
                enabled.push(name);
            }
            totalSeconds += pieces[name] * units[name].seconds;
        }
    }
    let output = [];
    if (enabled.length === 1) {
        options.precision = options.precision === undefined ? 1 : options.precision;
        const name = enabled.join('');
        const value = numberFormat(totalSeconds / units[name]['seconds'], options);
        output.push(value + (options.abr ? units[name].abr : ' ' + (value == 1 ? units[name].single : units[name].plural)));
    }
    else {
        options.precision = options.precision === undefined ? enabled.length : options.precision;
        for (const name in units) {
            if (units.hasOwnProperty(name)) {
                if (options.precision && output.length >= options.precision) {
                    continue;
                }
                if (options[name]) {
                    let value = pieces[name];
                    if (value) {
                        output.push(numberFormat(value, options) + (options.abr ? units[name].abr : ' ' + (value == 1 ? units[name].single : units[name].plural)));
                    }
                }
            }
        }
    }
    // there are no values so show zero of the smallest unit (i.e. "0s")
    if (output.length === 0) {
        for (const name in units) {
            if (units.hasOwnProperty(name)) {
                if (options[name]) {
                    output = [numberFormat(0, options) + (options.abr ? units[name].abr : ' ' + (units[name] == 1 ? units[name].single : units[name].plural))];
                }
            }
        }
    }
    // to cut off output depends on maxOutput value
    if (options.maxOutputs && options.maxOutputs < output.length) {
        output = output.splice(0, options.maxOutputs);
    }
    // add suffix if required
    if (options.suffix) {
        output.push(options.suffix);
    }
    return output.join(' ');
}
function numberFormat(number, options = {}) {
    const precision = options.precision === undefined ? -1 : options.precision;
    const pad = options.pad === undefined ? false : options.pad;
    const thousandsSeperator = options.thousandsSeperator === undefined ? true : options.thousandsSeperator;
    if (thousandsSeperator) {
        if (precision >= 0) {
            number = round(number, precision);
        }
        return number.toLocaleString('en-US', { minimumFractionDigits: pad ? precision : 0 });
    }
    if (precision >= 0 && pad) {
        return number.toFixed(precision);
    }
    if (precision >= 0) {
        return round(number, precision);
    }
    return number;
}

function ago(date, frmt = 'date') {
    date = parse(date);
    if (!date) {
        return '';
    }
    const minDiff = round(differenceInSeconds(new Date(), date) / 60, 0);
    const hourDiff = round(differenceInMinutes(new Date(), date) / 60, 0);
    if (Math.abs(hourDiff) >= 24) {
        if (date.getFullYear() == new Date().getFullYear()) {
            return format(date, 'date-yearless');
        }
        else {
            return format(date, frmt);
        }
    }
    else if (hourDiff == 0 && minDiff == 0) {
        return 'now';
    }
    else {
        return duration(minDiff, {
            unit: 'minutes',
            suffix: true,
            minutes: true,
            hours: true
        });
    }
}

function iso8601(date) {
    date = parse(date);
    if (!date) {
        return '';
    }
    return format$2(date, `yyyy-MM-dd'T'HH:mm:ssxxx`);
}

function range(from, to, format = 'date') {
    from = parse(from);
    to = parse(to);
    if (!to && !from) {
        return '';
    }
    if (from && !to) {
        to = from;
    }
    if (to && !from) {
        from = to;
    }
    const formatParts = format.split('-');
    let fromFormat = getFormatString(format);
    let toFormat = getFormatString(format);
    if (formatParts.indexOf('yearless') !== -1) {
        fromFormat = fromFormat.replace(' yyyy', '');
        toFormat = toFormat.replace(' yyyy', '');
    }
    if (differenceInMilliseconds(from, to) == 0) {
        return format$2(from, fromFormat);
    }
    if (formatParts.indexOf('time') !== -1) {
        // date and time
        if (!from.getMinutes()) {
            fromFormat = fromFormat.replace(':mm', '');
        }
        if (!to.getMinutes()) {
            toFormat = toFormat.replace(':mm', '');
        }
        if (from.getFullYear() === to.getFullYear()) {
            if ((new Date()).getFullYear() === from.getFullYear()) {
                fromFormat = fromFormat.replace(', yyyy', '');
            }
            toFormat = toFormat.replace(', yyyy', '');
            if (from.getMonth() == to.getMonth()) {
                if (from.getDate() == to.getDate()) {
                    if ((from.getHours() < 12 && to.getHours() < 12) ||
                        (from.getHours() > 12 && to.getHours() > 12)) {
                        fromFormat = fromFormat.replace(' aaa', '');
                    }
                    toFormat = toFormat
                        .replace('MMMM', '')
                        .replace('MMM', '')
                        .replace('EEEE', '')
                        .replace('EEE', '')
                        .replace(' do', '')
                        .replace(' d', '')
                        .trim();
                }
                else {
                    // add comma after day
                    toFormat = toFormat
                        .replace(' do', ' do,')
                        .replace(' d', ' d,');
                }
            }
            else {
                // add comma after day
                toFormat = toFormat
                    .replace(' do', ' do,')
                    .replace(' d', ' d,');
            }
        }
        fromFormat = fromFormat.replace('MM d h', 'MM d · h');
    }
    else {
        // date only
        if (from.getFullYear() == to.getFullYear()) {
            fromFormat = fromFormat
                .replace(' yyyy', '')
                .replace(',', '')
                .trim();
            if (from.getMonth() == to.getMonth()) {
                if (formatParts.indexOf('day') == -1) {
                    toFormat = toFormat
                        .replace('MMMM', '')
                        .replace('MMM', '')
                        .trim();
                }
                if (from.getDate() == to.getDate()) {
                    if (formatParts.indexOf('time') === -1) {
                        fromFormat = getFormatString(format);
                        toFormat = '';
                    }
                }
            }
        }
    }
    let output = format$2(from, fromFormat);
    if (toFormat) {
        output += ' – ' + format$2(to, toFormat);
    }
    return output;
}

function granularDuration(time, options = {}) {
    options['seconds'] = options['seconds'] === undefined ? false : options['seconds'];
    options['months'] = options['months'] === undefined ? false : options['months'];
    options['years'] = options['years'] === undefined ? false : options['years'];
    options['precision'] = options['precision'] === undefined ? 3 : options['precision'];
    return duration(time, options);
}

function simpleFormat(date) {
    return format$2(date, 'yyyy-MM-dd\'T\'HH:mm:ssxxxxx');
}

function toUTC(date) {
    const UTC = Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds());
    return new Date(UTC);
}

function date(value) {
    let dateObject = typeof value === 'string' ? parseISO(value) : value;
    if (!isValid(dateObject)) {
        dateObject = null;
    }
    return dateObject;
}

function parseLocal(date) {
    if (typeof date === 'string') {
        date = utcToZonedTime(sanitizeDate(date), null);
    }
    return isValid(date) ? date : null;
}

class FsDateFormatPipe {
    transform(value, fmt) {
        return format(value, fmt);
    }
}
FsDateFormatPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDateFormatPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
FsDateFormatPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDateFormatPipe, name: "fsDateFormat" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDateFormatPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'fsDateFormat'
                }]
        }] });

class FsDatePipe extends FsDateFormatPipe {
}
FsDatePipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePipe, deps: null, target: i0.ɵɵFactoryTarget.Pipe });
FsDatePipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePipe, name: "fsDate" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDatePipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'fsDate'
                }]
        }] });

class FsDateRangePipe {
    transform(value, format) {
        return range(value[0], value[1], format);
    }
}
FsDateRangePipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDateRangePipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
FsDateRangePipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDateRangePipe, name: "fsDateRange" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDateRangePipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'fsDateRange'
                }]
        }] });

class FsDateDurationPipe {
    transform(value, fmt) {
        return duration(value, fmt);
    }
}
FsDateDurationPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDateDurationPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
FsDateDurationPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDateDurationPipe, name: "fsDateDuration" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDateDurationPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'fsDateDuration'
                }]
        }] });

class FsDateAgoPipe {
    transform(value, format) {
        return ago(value, format);
    }
}
FsDateAgoPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDateAgoPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
FsDateAgoPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDateAgoPipe, name: "fsDateAgo" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDateAgoPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'fsDateAgo'
                }]
        }] });

class FsDateAgoComponent {
    constructor(elementRef, _cd) {
        this.elementRef = elementRef;
        this._cd = _cd;
        this.showTime = false;
        this.format = 'date';
        this.showTooltip = true;
        this.tooltipDateFormat = null;
        this.formattedDate = null;
        this.tooltip = null;
        this._period = 60;
        this._destroy$ = new Subject();
        this._date = null;
    }
    set date(value) {
        this._date = parse(value);
    }
    get date() {
        return this._date;
    }
    ngOnInit() {
        this._init();
    }
    ngOnChanges() {
        this._init();
    }
    ngOnDestroy() {
        this._destroy$.next();
        this._destroy$.complete();
    }
    updateFormatted() {
        this.formattedDate = ago(this.date, this.format);
        if (this.showTooltip) {
            const tooltipFormat = this.getTooltipFormat();
            const tooltipAgo = this.getTooltipAgo();
            this.tooltip = format(this.date, tooltipFormat) + ' · ' + tooltipAgo;
        }
        this._cd.markForCheck();
    }
    /**
     * Setting format w/o year if year is the same
     */
    getTooltipFormat() {
        if (this.tooltipDateFormat) {
            return this.tooltipDateFormat;
        }
        let format = 'date-time';
        const todayYear = new Date().getFullYear();
        const dateYear = new Date(this.date).getFullYear();
        if (todayYear === dateYear) {
            format = 'date-time-yearless';
        }
        return format;
    }
    /**
     * Forming second part of the tooltip
     */
    getTooltipAgo() {
        let tooltip = 'now';
        if (!this.date) {
            return '';
        }
        const dateDifference = this._difference(this.date);
        const options = {
            maxOutputs: 1,
            suffix: true,
            years: true,
            months: true,
            days: true,
            hours: true,
            minutes: true
        };
        // if difference more than 1 minute
        if (dateDifference > 59 || dateDifference < 0) {
            tooltip = duration(dateDifference, options);
        }
        return tooltip;
    }
    _init() {
        this.updateFormatted();
        if (this._updateWhile(this.date) && !this._timer$) {
            this._timerInit();
        }
    }
    _timerInit() {
        this._timer$ = interval(this._period * 1000)
            .pipe(takeWhile((v, index) => this._updateWhile(this.date)), takeUntil(this._destroy$));
        this._timer$
            .subscribe({
            next: () => {
                this.updateFormatted();
            },
            complete: () => {
                this._timer$ = null;
            },
        });
    }
    _difference(date) {
        return differenceInSeconds(new Date(), date);
    }
    _updateWhile(date) {
        return Math.abs(this._difference(date)) <= (86400 + this._period);
    }
}
FsDateAgoComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDateAgoComponent, deps: [{ token: i0.ElementRef }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
FsDateAgoComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: FsDateAgoComponent, selector: "fs-date-ago", inputs: { date: "date", showTime: "showTime", format: "format", showTooltip: "showTooltip", tooltipDateFormat: "tooltipDateFormat" }, usesOnChanges: true, ngImport: i0, template: "<span [matTooltip]=\"tooltip\">{{ formattedDate }}</span>\n", directives: [{ type: i1.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDateAgoComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'fs-date-ago',
                    templateUrl: './date-ago.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { date: [{
                type: Input
            }], showTime: [{
                type: Input
            }], format: [{
                type: Input
            }], showTooltip: [{
                type: Input
            }], tooltipDateFormat: [{
                type: Input
            }] } });

class FsDateAgoFactory {
    constructor(factoryResolver) {
        this.factoryResolver = null;
        this.rootViewContainer = null;
        this.factoryResolver = factoryResolver;
    }
    setRootViewContainerRef(viewContainerRef) {
        this.rootViewContainer = viewContainerRef;
    }
    addDynamicComponent() {
        const factory = this.factoryResolver
            .resolveComponentFactory(FsDateAgoComponent);
        const component = factory
            .create(this.rootViewContainer.injector);
        this.rootViewContainer.insert(component.hostView);
        return component;
    }
}
FsDateAgoFactory.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDateAgoFactory, deps: [{ token: ComponentFactoryResolver }], target: i0.ɵɵFactoryTarget.Injectable });
FsDateAgoFactory.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDateAgoFactory });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDateAgoFactory, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [ComponentFactoryResolver]
                }] }]; } });

class FsDateAgoDirective {
    constructor(fsDateAgoFactory, renderer, elementRef, viewContainerRef) {
        this.fsDateAgoFactory = fsDateAgoFactory;
        this.renderer = renderer;
        this.elementRef = elementRef;
        this.viewContainerRef = viewContainerRef;
        this.date = null;
        this.showTime = false;
        this.format = 'date';
        this.dateAgoRef = null;
    }
    ngOnInit() {
    }
    ngOnChanges() {
        this.renderDateAgo();
    }
    renderDateAgo() {
        this.removeDateAgo();
        this.fsDateAgoFactory.setRootViewContainerRef(this.viewContainerRef);
        this.dateAgoRef = this.fsDateAgoFactory.addDynamicComponent();
        Object.assign(this.dateAgoRef.instance, {
            date: this.date,
            showTime: this.showTime,
            format: this.format
        });
    }
    removeDateAgo() {
        if (this.dateAgoRef) {
            this.renderer.removeChild(this.elementRef.nativeElement, this.dateAgoRef.instance.elementRef.nativeElement);
        }
    }
}
FsDateAgoDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDateAgoDirective, deps: [{ token: FsDateAgoFactory }, { token: i0.Renderer2 }, { token: i0.ElementRef }, { token: ViewContainerRef }], target: i0.ɵɵFactoryTarget.Directive });
FsDateAgoDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: FsDateAgoDirective, selector: "[fsDateAgo]", inputs: { date: "date", showTime: "showTime", format: "format" }, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDateAgoDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[fsDateAgo]'
                }]
        }], ctorParameters: function () { return [{ type: FsDateAgoFactory }, { type: i0.Renderer2 }, { type: i0.ElementRef }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [ViewContainerRef]
                }] }]; }, propDecorators: { date: [{
                type: Input
            }], showTime: [{
                type: Input
            }], format: [{
                type: Input
            }] } });

class FsDateModule {
    static forRoot() {
        return {
            ngModule: FsDateModule,
            providers: [
                FsDateAgoFactory
            ]
        };
    }
}
FsDateModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDateModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
FsDateModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDateModule, declarations: [FsDatePipe,
        FsDateAgoPipe,
        FsDateDurationPipe,
        FsDateFormatPipe,
        FsDateRangePipe,
        FsDateAgoDirective,
        FsDateAgoComponent], imports: [CommonModule,
        MatTooltipModule,
        FsCommonModule], exports: [FsDatePipe,
        FsDateAgoPipe,
        FsDateDurationPipe,
        FsDateFormatPipe,
        FsDateRangePipe,
        FsDateAgoDirective,
        FsDateAgoComponent] });
FsDateModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDateModule, providers: [], imports: [[
            CommonModule,
            MatTooltipModule,
            FsCommonModule
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDateModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        MatTooltipModule,
                        FsCommonModule
                    ],
                    exports: [
                        FsDatePipe,
                        FsDateAgoPipe,
                        FsDateDurationPipe,
                        FsDateFormatPipe,
                        FsDateRangePipe,
                        FsDateAgoDirective,
                        FsDateAgoComponent
                    ],
                    entryComponents: [
                        FsDateAgoComponent
                    ],
                    declarations: [
                        FsDatePipe,
                        FsDateAgoPipe,
                        FsDateDurationPipe,
                        FsDateFormatPipe,
                        FsDateRangePipe,
                        FsDateAgoDirective,
                        FsDateAgoComponent
                    ],
                    providers: [],
                }]
        }] });

const TIMEZONES = [
    { name: 'A', value: '1' },
    { name: 'ACDT', value: '10:30' },
    { name: 'ACST', value: '9:30' },
    { name: 'ADT', value: '-3' },
    { name: 'ADT', value: '-3' },
    { name: 'AEDT', value: '11' },
    { name: 'AEST', value: '10' },
    { name: 'AFT', value: '4:30' },
    { name: 'AKDT', value: '-8' },
    { name: 'AKST', value: '-9' },
    { name: 'ALMT', value: '6' },
    { name: 'AMST', value: '5' },
    { name: 'AMST', value: '-3' },
    { name: 'AMT', value: '4' },
    { name: 'AMT', value: '-4' },
    { name: 'ANAST', value: '12' },
    { name: 'ANAT', value: '12' },
    { name: 'AQTT', value: '5' },
    { name: 'ART', value: '-3' },
    { name: 'AST', value: '3' },
    { name: 'AST', value: '-4' },
    { name: 'AWDT', value: '9' },
    { name: 'AWST', value: '8' },
    { name: 'AZOST', value: '0' },
    { name: 'AZOT', value: '-1' },
    { name: 'AZST', value: '5' },
    { name: 'AZT', value: '4' },
    { name: 'B', value: '2' },
    { name: 'BNT', value: '8' },
    { name: 'BOT', value: '-4' },
    { name: 'BRST', value: '-2' },
    { name: 'BRT', value: '-3' },
    { name: 'BST', value: '6' },
    { name: 'BST', value: '1' },
    { name: 'BTT', value: '6' },
    { name: 'C', value: '3' },
    { name: 'CAST', value: '8' },
    { name: 'CAT', value: '2' },
    { name: 'CCT', value: '6:30' },
    { name: 'CDT', value: '-4' },
    { name: 'CDT', value: '-5' },
    { name: 'CEST', value: '2' },
    { name: 'CET', value: '1' },
    { name: 'CHADT', value: '13:45' },
    { name: 'CHAST', value: '12:45' },
    { name: 'CKT', value: '-10' },
    { name: 'CLST', value: '-3' },
    { name: 'CLT', value: '-4' },
    { name: 'COT', value: '-5' },
    { name: 'CST', value: '8' },
    { name: 'CST', value: '-6' },
    { name: 'CST', value: '-5' },
    { name: 'CVT', value: '-1' },
    { name: 'CXT', value: '7' },
    { name: 'ChST', value: '10' },
    { name: 'D', value: '4' },
    { name: 'DAVT', value: '7' },
    { name: 'E', value: '5' },
    { name: 'EASST', value: '-5' },
    { name: 'EAST', value: '-6' },
    { name: 'EAT', value: '3' },
    { name: 'EAT', value: '3' },
    { name: 'ECT', value: '-5' },
    { name: 'EDT', value: '-4' },
    { name: 'EEST', value: '3' },
    { name: 'EET', value: '2' },
    { name: 'EGST', value: '0' },
    { name: 'EGT', value: '-1' },
    { name: 'EST', value: '-5' },
    { name: 'ET', value: '-5' },
    { name: 'F', value: '6' },
    { name: 'FJST', value: '13' },
    { name: 'FJT', value: '12' },
    { name: 'FKST', value: '-3' },
    { name: 'FKT', value: '-4' },
    { name: 'FNT', value: '-2' },
    { name: 'G', value: '7' },
    { name: 'GALT', value: '-6' },
    { name: 'GAMT', value: '-9' },
    { name: 'GET', value: '4' },
    { name: 'GFT', value: '-3' },
    { name: 'GILT', value: '12' },
    { name: 'GMT', value: '0' },
    { name: 'GST', value: '4' },
    { name: 'GYT', value: '-4' },
    { name: 'H', value: '8' },
    { name: 'HAA', value: '-3' },
    { name: 'HAC', value: '-5' },
    { name: 'HADT', value: '-9' },
    { name: 'HAE', value: '-4' },
    { name: 'HAP', value: '-7' },
    { name: 'HAR', value: '-6' },
    { name: 'HAST', value: '-10' },
    { name: 'HAT', value: '-2:30' },
    { name: 'HAY', value: '-8' },
    { name: 'HKT', value: '8' },
    { name: 'HLV', value: '-4:30' },
    { name: 'HNA', value: '-4' },
    { name: 'HNC', value: '-6' },
    { name: 'HNE', value: '-5' },
    { name: 'HNP', value: '-8' },
    { name: 'HNR', value: '-7' },
    { name: 'HNT', value: '-3:30' },
    { name: 'HNY', value: '-9' },
    { name: 'HOVT', value: '7' },
    { name: 'I', value: '9' },
    { name: 'ICT', value: '7' },
    { name: 'IDT', value: '3' },
    { name: 'IOT', value: '6' },
    { name: 'IRDT', value: '4:30' },
    { name: 'IRKST', value: '9' },
    { name: 'IRKT', value: '9' },
    { name: 'IRST', value: '3:30' },
    { name: 'IST', value: '2' },
    { name: 'IST', value: '5:30' },
    { name: 'IST', value: '1' },
    { name: 'JST', value: '9' },
    { name: 'K', value: '10' },
    { name: 'KGT', value: '6' },
    { name: 'KRAST', value: '8' },
    { name: 'KRAT', value: '8' },
    { name: 'KST', value: '9' },
    { name: 'KUYT', value: '4' },
    { name: 'L', value: '11' },
    { name: 'LHDT', value: '11' },
    { name: 'LHST', value: '10:30' },
    { name: 'LINT', value: '14' },
    { name: 'M', value: '12' },
    { name: 'MAGST', value: '12' },
    { name: 'MAGT', value: '12' },
    { name: 'MART', value: '-9:30' },
    { name: 'MAWT', value: '5' },
    { name: 'MDT', value: '-6' },
    { name: 'MESZ', value: '2' },
    { name: 'MEZ', value: '1' },
    { name: 'MHT', value: '12' },
    { name: 'MMT', value: '6:30' },
    { name: 'MSD', value: '4' },
    { name: 'MSK', value: '4' },
    { name: 'MST', value: '-7' },
    { name: 'MUT', value: '4' },
    { name: 'MVT', value: '5' },
    { name: 'MYT', value: '8' },
    { name: 'N', value: '-1' },
    { name: 'NCT', value: '11' },
    { name: 'NDT', value: '-2:30' },
    { name: 'NFT', value: '11:30' },
    { name: 'NOVST', value: '7' },
    { name: 'NOVT', value: '6' },
    { name: 'NPT', value: '5:45' },
    { name: 'NST', value: '-3:30' },
    { name: 'NUT', value: '-11' },
    { name: 'NZDT', value: '13' },
    { name: 'NZST', value: '12' },
    { name: 'O', value: '-2' },
    { name: 'OMSST', value: '7' },
    { name: 'OMST', value: '7' },
    { name: 'P', value: '-3' },
    { name: 'PDT', value: '-7' },
    { name: 'PET', value: '-5' },
    { name: 'PETST', value: '12' },
    { name: 'PETT', value: '12' },
    { name: 'PGT', value: '10' },
    { name: 'PHOT', value: '13' },
    { name: 'PHT', value: '8' },
    { name: 'PKT', value: '5' },
    { name: 'PMDT', value: '-2' },
    { name: 'PMST', value: '-3' },
    { name: 'PONT', value: '11' },
    { name: 'PST', value: '-8' },
    { name: 'PST', value: '-8' },
    { name: 'PT', value: '-8' },
    { name: 'PWT', value: '9' },
    { name: 'PYST', value: '-3' },
    { name: 'PYT', value: '-4' },
    { name: 'Q', value: '-4' },
    { name: 'R', value: '-5' },
    { name: 'RET', value: '4' },
    { name: 'S', value: '-6' },
    { name: 'SAMT', value: '4' },
    { name: 'SAST', value: '2' },
    { name: 'SBT', value: '11' },
    { name: 'SCT', value: '4' },
    { name: 'SGT', value: '8' },
    { name: 'SRT', value: '-3' },
    { name: 'SST', value: '-11' },
    { name: 'T', value: '-7' },
    { name: 'TAHT', value: '-10' },
    { name: 'TFT', value: '5' },
    { name: 'TJT', value: '5' },
    { name: 'TKT', value: '13' },
    { name: 'TLT', value: '9' },
    { name: 'TMT', value: '5' },
    { name: 'TVT', value: '12' },
    { name: 'U', value: '-8' },
    { name: 'ULAT', value: '8' },
    { name: 'UTC', value: '0' },
    { name: 'UYST', value: '-2' },
    { name: 'UYT', value: '-3' },
    { name: 'UZT', value: '5' },
    { name: 'V', value: '-9' },
    { name: 'VET', value: '-4:30' },
    { name: 'VLAST', value: '11' },
    { name: 'VLAT', value: '11' },
    { name: 'VUT', value: '11' },
    { name: 'W', value: '-10' },
    { name: 'WAST', value: '2' },
    { name: 'WAT', value: '1' },
    { name: 'WEST', value: '1' },
    { name: 'WESZ', value: '1' },
    { name: 'WET', value: '0' },
    { name: 'WEZ', value: '0' },
    { name: 'WFT', value: '12' },
    { name: 'WGST', value: '-2' },
    { name: 'WGT', value: '-3' },
    { name: 'WIB', value: '7' },
    { name: 'WIT', value: '9' },
    { name: 'WITA', value: '8' },
    { name: 'WST', value: '1' },
    { name: 'WST', value: '13' },
    { name: 'WT', value: '0' },
    { name: 'X', value: '-11' },
    { name: 'Y', value: '-12' },
    { name: 'YAKST', value: '10' },
    { name: 'YAKT', value: '10' },
    { name: 'YAPT', value: '10' },
    { name: 'YEKST', value: '6' },
    { name: 'YEKT', value: '6' },
    { name: 'Z', value: '0' },
];

/*
 * Public API Surface of fs-menu
 */

/**
 * Generated bundle index. Do not edit.
 */

export { FsDateAgoComponent, FsDateAgoDirective, FsDateAgoFactory, FsDateAgoPipe, FsDateDurationPipe, FsDateFormatPipe, FsDateModule, FsDatePipe, FsDateRangePipe, SECONDS, TIMEZONES, ago, date, duration, format, getFormatString, granularDuration, iso8601, parse, parseDuration, parseLocal, range, simpleFormat, toUTC };
//# sourceMappingURL=firestitch-date.js.map
