(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('@angular/forms'), require('@angular/material/autocomplete'), require('@angular/material/chips'), require('@angular/material/icon'), require('@angular/material/input'), require('@angular/material/radio'), require('@angular/cdk/drag-drop'), require('@firestitch/label'), require('@angular/material/form-field'), require('@angular/cdk/keycodes'), require('lodash-es'), require('rxjs'), require('rxjs/operators'), require('@angular/material/core')) :
    typeof define === 'function' && define.amd ? define('@firestitch/autocomplete-chips', ['exports', '@angular/core', '@angular/common', '@angular/forms', '@angular/material/autocomplete', '@angular/material/chips', '@angular/material/icon', '@angular/material/input', '@angular/material/radio', '@angular/cdk/drag-drop', '@firestitch/label', '@angular/material/form-field', '@angular/cdk/keycodes', 'lodash-es', 'rxjs', 'rxjs/operators', '@angular/material/core'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.firestitch = global.firestitch || {}, global.firestitch["autocomplete-chips"] = {}), global.ng.core, global.ng.common, global.ng.forms, global.ng.material.autocomplete, global.ng.material.chips, global.ng.material.icon, global.ng.material.input, global.ng.material.radio, global.ng.cdk.dragDrop, global.i7, global.ng.material.formField, global.ng.cdk.keycodes, global.lodashEs, global.rxjs, global.rxjs.operators, global.ng.material.core));
})(this, (function (exports, i0, i8, forms, i4, i2, i3, input, i6, i9, i7, i1, keycodes, lodashEs, rxjs, operators, i5) { 'use strict';

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () { return e[k]; }
                    });
                }
            });
        }
        n["default"] = e;
        return Object.freeze(n);
    }

    var i0__namespace = /*#__PURE__*/_interopNamespace(i0);
    var i8__namespace = /*#__PURE__*/_interopNamespace(i8);
    var i4__namespace = /*#__PURE__*/_interopNamespace(i4);
    var i2__namespace = /*#__PURE__*/_interopNamespace(i2);
    var i3__namespace = /*#__PURE__*/_interopNamespace(i3);
    var i6__namespace = /*#__PURE__*/_interopNamespace(i6);
    var i9__namespace = /*#__PURE__*/_interopNamespace(i9);
    var i7__namespace = /*#__PURE__*/_interopNamespace(i7);
    var i1__namespace = /*#__PURE__*/_interopNamespace(i1);
    var i5__namespace = /*#__PURE__*/_interopNamespace(i5);

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    /** @deprecated */
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    /** @deprecated */
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
                if (ar || !(i in from)) {
                    if (!ar)
                        ar = Array.prototype.slice.call(from, 0, i);
                    ar[i] = from[i];
                }
            }
        return to.concat(ar || Array.prototype.slice.call(from));
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, state, kind, f) {
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }
    function __classPrivateFieldSet(receiver, state, value, kind, f) {
        if (kind === "m")
            throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    }

    function getObjectValue(attribute, mapping) {
        if (!mapping) {
            return null;
        }
        return _getObjectValue(attribute, mapping.split('.'));
    }
    function _getObjectValue(value, indexes) {
        var index = indexes.shift(indexes);
        if (!index) {
            return value;
        }
        if (!value) {
            return value;
        }
        value = value[index];
        return _getObjectValue(value, indexes);
    }

    var DataType;
    (function (DataType) {
        DataType["Object"] = "object";
        DataType["Text"] = "text";
    })(DataType || (DataType = {}));

    var FsAutocompleteObjectDirective = /** @class */ (function () {
        function FsAutocompleteObjectDirective() {
        }
        return FsAutocompleteObjectDirective;
    }());
    FsAutocompleteObjectDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsAutocompleteObjectDirective, deps: [], target: i0__namespace.ɵɵFactoryTarget.Directive });
    FsAutocompleteObjectDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: FsAutocompleteObjectDirective, selector: "[fsAutocompleteObject],[fsAutocompleteChipsTemplate]", ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsAutocompleteObjectDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: '[fsAutocompleteObject],[fsAutocompleteChipsTemplate]'
                    }]
            }] });

    var FsAutocompleteChipsNoResultsDirective = /** @class */ (function () {
        function FsAutocompleteChipsNoResultsDirective() {
        }
        return FsAutocompleteChipsNoResultsDirective;
    }());
    FsAutocompleteChipsNoResultsDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsAutocompleteChipsNoResultsDirective, deps: [], target: i0__namespace.ɵɵFactoryTarget.Directive });
    FsAutocompleteChipsNoResultsDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: FsAutocompleteChipsNoResultsDirective, selector: "[fsAutocompleteChipsNoResults]", ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsAutocompleteChipsNoResultsDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: '[fsAutocompleteChipsNoResults]'
                    }]
            }] });

    var FsAutocompleteChipsStaticDirective = /** @class */ (function () {
        function FsAutocompleteChipsStaticDirective() {
            this.click = new i0.EventEmitter();
        }
        return FsAutocompleteChipsStaticDirective;
    }());
    FsAutocompleteChipsStaticDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsAutocompleteChipsStaticDirective, deps: [], target: i0__namespace.ɵɵFactoryTarget.Directive });
    FsAutocompleteChipsStaticDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: FsAutocompleteChipsStaticDirective, selector: "[fsAutocompleteChipsStatic]", outputs: { click: "click" }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsAutocompleteChipsStaticDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: '[fsAutocompleteChipsStatic]'
                    }]
            }], propDecorators: { click: [{
                    type: i0.Output
                }] } });

    var FsAutocompleteChipSuffixDirective = /** @class */ (function () {
        function FsAutocompleteChipSuffixDirective() {
        }
        return FsAutocompleteChipSuffixDirective;
    }());
    FsAutocompleteChipSuffixDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsAutocompleteChipSuffixDirective, deps: [], target: i0__namespace.ɵɵFactoryTarget.Directive });
    FsAutocompleteChipSuffixDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: FsAutocompleteChipSuffixDirective, selector: "[fsAutocompleteChipSuffix]", ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsAutocompleteChipSuffixDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: '[fsAutocompleteChipSuffix]'
                    }]
            }] });

    var FsAutocompleteChipsSuffixDirective = /** @class */ (function () {
        function FsAutocompleteChipsSuffixDirective() {
        }
        return FsAutocompleteChipsSuffixDirective;
    }());
    FsAutocompleteChipsSuffixDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsAutocompleteChipsSuffixDirective, deps: [], target: i0__namespace.ɵɵFactoryTarget.Directive });
    FsAutocompleteChipsSuffixDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: FsAutocompleteChipsSuffixDirective, selector: "[fsAutocompleteChipsSuffix]", ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsAutocompleteChipsSuffixDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: '[fsAutocompleteChipsSuffix]'
                    }]
            }] });

    var FsAutocompleteChipsComponent = /** @class */ (function () {
        function FsAutocompleteChipsComponent(_cdRef) {
            this._cdRef = _cdRef;
            this.fetch = null;
            this.readonly = false;
            this.size = 'large';
            this.placeholder = '';
            this.chipImage = 'image';
            this.allowObject = true;
            this.delay = 200;
            this.invalidTextMessage = '';
            this.removable = true;
            this.allowClear = true;
            this.color = '';
            this.background = '';
            this.orderable = false;
            this.limit = 0;
            this.initOnClick = false;
            this.fetchOnFocus = true;
            this.multiple = true;
            this.compareWith = function (o1, o2) {
                return lodashEs.isEqual(o1, o2);
            };
            this.panelWidth = null;
            this.selected = new i0.EventEmitter();
            this.removed = new i0.EventEmitter();
            this.reordered = new i0.EventEmitter();
            this.clearEvent = new i0.EventEmitter();
            this.formWrapper = true;
            this.input = null;
            this.dummyInput = null;
            this.autocompleteTrigger = null;
            this.formField = null;
            this.objectTemplate = null;
            this.chipSuffixTemplate = null;
            this.chipsSuffixTemplate = null;
            this.noResultsTemplate = null;
            this.staticTemplates = null;
            this.textData = {};
            this.disabled = false;
            this.dataType = DataType;
            this.keyword = null;
            this.noResults = false;
            this.name = 'autocomplete_'.concat(lodashEs.random(1, 9999999));
            this._model = [];
            this.inited = false;
            this._keyword$ = new rxjs.Subject();
            this._fetch$ = new rxjs.Subject();
            this._destroy$ = new rxjs.Subject();
            this._onTouched = function () { };
            this._onChange = function (value) { };
            this.panelClass = '';
        }
        Object.defineProperty(FsAutocompleteChipsComponent.prototype, "panelClass", {
            set: function (value) {
                this.panelClasses = __spreadArray(__spreadArray([], ['fs-account-picker-autocomplete', 'fs-autocomplete-chips-panel']), [
                    value,
                ]).join(' ');
            },
            enumerable: false,
            configurable: true
        });
        ;
        Object.defineProperty(FsAutocompleteChipsComponent.prototype, "setDisabled", {
            set: function (value) {
                this.disabled = value;
            },
            enumerable: false,
            configurable: true
        });
        FsAutocompleteChipsComponent.prototype.dragStart = function (e) {
            e.preventDefault();
        };
        ;
        Object.defineProperty(FsAutocompleteChipsComponent.prototype, "model", {
            get: function () {
                return this._model;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(FsAutocompleteChipsComponent.prototype, "inputEl", {
            get: function () {
                return this.input ? this.input.nativeElement : null;
            },
            enumerable: false,
            configurable: true
        });
        FsAutocompleteChipsComponent.prototype.registerOnChange = function (fn) { this._onChange = fn; };
        FsAutocompleteChipsComponent.prototype.registerOnTouched = function (fn) { this._onTouched = fn; };
        FsAutocompleteChipsComponent.prototype.ngOnInit = function () {
            this.inited = !this.initOnClick;
            this._listenFetch();
            this._listenKeywordChange();
        };
        FsAutocompleteChipsComponent.prototype.init = function (options) {
            if (options === void 0) { options = { focus: true }; }
            if (!this.disabled) {
                this.inited = true;
                this._cdRef.markForCheck();
                if (options.focus) {
                    this.focus({ delay: 200 });
                }
            }
        };
        FsAutocompleteChipsComponent.prototype.drop = function (event) {
            var previousIndex = event.previousContainer.data.index;
            var index = event.container.data.index;
            i9.moveItemInArray(this._model, previousIndex, index);
            this.reordered.emit({
                item: this._model[index],
                from: previousIndex,
                to: index,
                items: this._model,
            });
            this._updateModel(this._model);
        };
        FsAutocompleteChipsComponent.prototype.selectAll = function () {
            var _this = this;
            this.data.forEach(function (selected) {
                if (selected.type === DataType.Object) {
                    _this._addObject(selected);
                }
                if (selected.type === DataType.Text) {
                    _this._addText(selected.data);
                }
            });
        };
        FsAutocompleteChipsComponent.prototype.inputed = function (event) {
            if (this.readonly || this.disabled) {
                return;
            }
            this._keyword$.next(event);
        };
        FsAutocompleteChipsComponent.prototype.keyDown = function (event) {
            if (this.readonly || this.disabled || ['Enter', 'ArrowDown', 'ArrowUp'].indexOf(event.code) !== -1) {
                return;
            }
            if (event.code === 'Tab') {
                var activeOption = this.autocompleteTrigger.activeOption;
                if (activeOption) {
                    if (activeOption.value.type === DataType.Object) {
                        this._addObject(activeOption.value);
                        this.selected.emit(activeOption.value);
                    }
                    else if (activeOption.value.type === DataType.Text) {
                        this._addText(this.keyword);
                        this.selected.emit(this.keyword);
                    }
                }
            }
            this._clearData();
        };
        FsAutocompleteChipsComponent.prototype.chipClick = function (event) {
            this.focus();
        };
        FsAutocompleteChipsComponent.prototype.chipKeyDown = function (event, index) {
            if (event.keyCode === keycodes.BACKSPACE || event.keyCode === keycodes.DELETE) {
                if (this.multiple) {
                    this.model.splice(index, 1);
                    this._updateModel(this.model);
                }
                else {
                    this._updateModel([]);
                }
            }
        };
        FsAutocompleteChipsComponent.prototype.chipRemoved = function (event, item) {
            event.stopPropagation();
            event.stopImmediatePropagation();
            this._model = this.model
                .filter(function (modelItem) { return modelItem !== item; });
            this._updateModel(this._model);
            this.removed.emit(item);
            this.unfocus();
        };
        FsAutocompleteChipsComponent.prototype.focus = function (options) {
            var _this = this;
            if (options === void 0) { options = { delay: 0 }; }
            setTimeout(function () {
                _this.inputEl.focus();
            }, options.delay); // Hack: Delay to wait for animation to finish
        };
        FsAutocompleteChipsComponent.prototype.unfocus = function () {
            var _this = this;
            setTimeout(function () {
                if (_this.dummyInput) {
                    _this.dummyInput.nativeElement.focus();
                }
            });
        };
        FsAutocompleteChipsComponent.prototype.clearClick = function (event) {
            event.stopPropagation();
            this.clear(true);
            this.clearEvent.emit();
        };
        FsAutocompleteChipsComponent.prototype.clear = function (closePanel) {
            if (closePanel === void 0) { closePanel = true; }
            if (closePanel) {
                this.closePanel();
            }
            this._clearInput();
            this.noResults = false;
            this._updateModel([]);
        };
        FsAutocompleteChipsComponent.prototype.closePanel = function () {
            if (this.autocompleteTrigger) {
                this.autocompleteTrigger.closePanel();
            }
        };
        FsAutocompleteChipsComponent.prototype.closed = function () {
            var _this = this;
            setTimeout(function () {
                _this._close();
                if (_this.initOnClick) {
                    // Wait for keyDown() to fire to process
                    _this.inited = false;
                    _this._cdRef.markForCheck();
                }
                _this._clearData();
            });
        };
        FsAutocompleteChipsComponent.prototype.focused = function (e) {
            this._clearInput();
            if (this.fetchOnFocus) {
                this._fetch();
                this.autocompleteTrigger.openPanel();
            }
        };
        FsAutocompleteChipsComponent.prototype.optionClick = function (event, value, refocus) {
            if (refocus === void 0) { refocus = false; }
            event.stopPropagation();
            event.preventDefault();
            // Clear input before close to prevent adding text item which was not selected
            if (!refocus) {
                this._clearInput();
            }
            if (this.multiple) {
                this._select(value, { fetch: !this.fetchOnFocus });
                if (!refocus) {
                    this.closePanel();
                }
            }
            else {
                this._select(value, { fetch: false });
                this._close();
                this.closePanel();
            }
        };
        FsAutocompleteChipsComponent.prototype.optionSelected = function (event) {
            if (!event.option.value) {
                return;
            }
            this._select(event.option.value);
            this._clearData();
            this._clearInput();
        };
        FsAutocompleteChipsComponent.prototype.writeValue = function (value) {
            var _this = this;
            if (value) {
                value = Array.isArray(value) ? value : [value];
                value = value.map(function (item) {
                    return typeof item === 'object' ?
                        _this._createObjectItem(item) :
                        _this._createTextItem(item, true);
                });
            }
            else {
                value = [];
            }
            this._model = value;
            this._cdRef.markForCheck();
        };
        FsAutocompleteChipsComponent.prototype.staticClick = function (event, index) {
            event.stopPropagation();
            event.preventDefault();
            var staticDirective = this.staticDirectives.toArray()[index];
            staticDirective.click.emit(event);
            if (this.inputEl) {
                this.inputEl.blur();
            }
        };
        FsAutocompleteChipsComponent.prototype.ngOnDestroy = function () {
            this._destroy$.next();
            this._destroy$.complete();
        };
        FsAutocompleteChipsComponent.prototype._clearData = function () {
            this.data = null;
        };
        FsAutocompleteChipsComponent.prototype._clearInput = function () {
            if (this.inputEl) {
                this.inputEl.value = '';
            }
            this.textData = {};
            this.keyword = '';
        };
        FsAutocompleteChipsComponent.prototype._select = function (selected, options) {
            var _this = this;
            if (options === void 0) { options = {}; }
            if (!this.multiple) {
                this._model = [];
            }
            if (this.data) {
                var index = this.data.indexOf(selected);
                if (index !== -1) {
                    this.data.splice(index, 1);
                }
            }
            var value = this.allowObject && this.allowText ? selected : selected.data;
            if (selected.type === DataType.Object) {
                if (!this._model.includes(value)) {
                    this._addObject(selected);
                    this.selected.emit(selected);
                }
            }
            if (selected.type === DataType.Text) {
                if (!this._model.includes(value)) {
                    this._addText(selected.data);
                    this.selected.emit(selected.data);
                }
            }
            if (options.fetch !== false) {
                this._fetch();
                setTimeout(function () {
                    if (_this.autocompleteTrigger) {
                        _this.autocompleteTrigger.updatePosition();
                    }
                });
            }
        };
        FsAutocompleteChipsComponent.prototype._createTextItem = function (data, valid) {
            return {
                data: data,
                type: DataType.Text,
                valid: valid,
            };
        };
        FsAutocompleteChipsComponent.prototype._createObjectItem = function (data) {
            return {
                data: data,
                type: DataType.Object,
                image: getObjectValue(data, this.chipImage),
                icon: getObjectValue(data, this.chipIcon),
                iconColor: getObjectValue(data, this.chipIconColor) || this.chipIconColor,
                class: getObjectValue(data, this.chipClass) || this.chipClass,
                background: getObjectValue(data, this.chipBackground) || this.chipBackground,
                color: getObjectValue(data, this.chipColor) || this.chipColor
            };
        };
        FsAutocompleteChipsComponent.prototype._validateText = function (text) {
            return String(text).trim().length && (!this.validateText || this.validateText(text));
        };
        FsAutocompleteChipsComponent.prototype._updateModel = function (value) {
            var _this = this;
            this._model = value;
            var model = this._model.map(function (item) {
                if (!_this.allowText || !_this.allowObject) {
                    return item.data;
                }
                return item;
            });
            this._onChange(this.multiple ? model : model[0]);
            this._onTouched();
        };
        FsAutocompleteChipsComponent.prototype._addObject = function (object) {
            this._updateModel(__spreadArray(__spreadArray([], __read(this._model)), [object]));
        };
        FsAutocompleteChipsComponent.prototype._addText = function (text) {
            if (this._validateText(text)) {
                var textObject = this._createTextItem(text, true);
                this._updateModel(__spreadArray(__spreadArray([], __read(this._model)), [textObject]));
            }
        };
        FsAutocompleteChipsComponent.prototype._close = function () {
            this._clearInput();
        };
        FsAutocompleteChipsComponent.prototype._fetch = function () {
            this._fetch$.next(null);
        };
        FsAutocompleteChipsComponent.prototype._listenKeywordChange = function () {
            var _this = this;
            this._keyword$
                .pipe(operators.filter(function () { return _this.inited; }), operators.tap(function (e) {
                if (e.data === ',') {
                    _this._select({
                        type: DataType.Text,
                        data: _this.keyword,
                    });
                    _this._clearInput();
                }
                else {
                    _this.keyword = _this.inputEl ? _this.inputEl.value.trim() : '';
                }
                _this.data = null;
            }), operators.debounce(function () {
                var delay = 0;
                if (_this.keyword.length && _this.allowObject) {
                    delay = _this.delay;
                }
                return rxjs.timer(delay);
            }), operators.takeUntil(this._destroy$))
                .subscribe(function () {
                _this._fetch$.next(_this.keyword);
            });
        };
        FsAutocompleteChipsComponent.prototype._listenFetch = function () {
            var _this = this;
            this._fetch$
                .pipe(operators.filter(function () { return _this.inited; }), operators.switchMap(function (keyword) {
                if (_this.allowText) {
                    _this.textData = _this._createTextItem(keyword, _this._validateText(keyword));
                }
                if (_this.allowObject) {
                    _this.noResults = false;
                    return _this._doFetchByKeyword(keyword);
                }
                return rxjs.of([]);
            }), operators.takeUntil(this._destroy$))
                .subscribe(function () {
                _this._cdRef.markForCheck();
            });
        };
        FsAutocompleteChipsComponent.prototype._doFetchByKeyword = function (keyword) {
            var _this = this;
            return this.fetch(keyword)
                .pipe(operators.tap(function (response) {
                if (!Array.isArray(response)) {
                    return;
                }
                _this.data = response.map(function (data) {
                    return _this._createObjectItem(data);
                });
                if (_this.multiple) {
                    _this.data = _this.data.filter(function (item) {
                        return !_this.model.some(function (model) {
                            return _this.compareWith(model.data, item.data);
                        });
                    });
                }
                else {
                    var selected = _this.data.find(function (item) {
                        return _this.model.some(function (model) {
                            return _this.compareWith(model.data, item.data);
                        });
                    });
                    if (selected) {
                        selected.selected = true;
                    }
                }
                _this.noResults = !_this.data.length;
            }));
        };
        return FsAutocompleteChipsComponent;
    }());
    FsAutocompleteChipsComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsAutocompleteChipsComponent, deps: [{ token: i0__namespace.ChangeDetectorRef }], target: i0__namespace.ɵɵFactoryTarget.Component });
    FsAutocompleteChipsComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: FsAutocompleteChipsComponent, selector: "fs-autocomplete-chips", inputs: { fetch: "fetch", readonly: "readonly", size: "size", placeholder: "placeholder", chipImage: "chipImage", chipBackground: "chipBackground", chipColor: "chipColor", chipIcon: "chipIcon", chipIconColor: "chipIconColor", chipClass: "chipClass", hint: "hint", allowText: "allowText", allowObject: "allowObject", delay: "delay", validateText: "validateText", invalidTextMessage: "invalidTextMessage", removable: "removable", allowClear: "allowClear", color: "color", background: "background", orderable: "orderable", limit: "limit", initOnClick: "initOnClick", fetchOnFocus: "fetchOnFocus", multiple: "multiple", panelClass: "panelClass", compareWith: "compareWith", setDisabled: ["disabled", "setDisabled"], panelWidth: "panelWidth" }, outputs: { selected: "selected", removed: "removed", reordered: "reordered", clearEvent: "clear" }, host: { listeners: { "dragstart": "dragStart($event)" }, properties: { "class.fs-form-wrapper": "this.formWrapper" } }, providers: [{
                provide: forms.NG_VALUE_ACCESSOR,
                useExisting: i0.forwardRef(function () { return FsAutocompleteChipsComponent; }),
                multi: true
            }], queries: [{ propertyName: "objectTemplate", first: true, predicate: FsAutocompleteObjectDirective, descendants: true, read: i0.TemplateRef }, { propertyName: "chipSuffixTemplate", first: true, predicate: FsAutocompleteChipSuffixDirective, descendants: true, read: i0.TemplateRef }, { propertyName: "chipsSuffixTemplate", first: true, predicate: FsAutocompleteChipsSuffixDirective, descendants: true, read: i0.TemplateRef }, { propertyName: "noResultsTemplate", first: true, predicate: FsAutocompleteChipsNoResultsDirective, descendants: true, read: i0.TemplateRef, static: true }, { propertyName: "staticTemplates", predicate: FsAutocompleteChipsStaticDirective, read: i0.TemplateRef }, { propertyName: "staticDirectives", predicate: FsAutocompleteChipsStaticDirective }], viewQueries: [{ propertyName: "input", first: true, predicate: ["input"], descendants: true }, { propertyName: "dummyInput", first: true, predicate: ["dummyInput"], descendants: true }, { propertyName: "autocompleteTrigger", first: true, predicate: i4.MatAutocompleteTrigger, descendants: true }, { propertyName: "formField", first: true, predicate: i1.MatFormField, descendants: true, read: i0.ElementRef }, { propertyName: "autocompleteTriggers", predicate: i4.MatAutocompleteTrigger, descendants: true }], ngImport: i0__namespace, template: "<ng-container *ngIf=\"inited; else elseInited\">\n  <mat-form-field\n      [ngClass]=\"{ 'mat-form-field-disabled': disabled }\"\n      [floatLabel]=\"initOnClick ? 'always' : 'auto'\"\n      (click)=\"focus()\">\n    <mat-chip-list\n        [tabIndex]=\"-1\"\n        cdkDropListGroup\n        #searchList>\n      <div\n          *ngFor=\"let item of model; let index = index\"\n          cdkDropList\n          [cdkDropListData]=\"{ index: index }\"\n          cdkDropListOrientation=\"horizontal\"\n          (cdkDropListDropped)=\"drop($event)\">\n        <mat-chip\n            [disableRipple]=\"true\"\n            [selectable]=\"!disabled\"\n            [removable]=\"!disabled\"\n            [disabled]=\"disabled\"\n            [class]=\"'fs-autocomplete-chip ' + item.class\"\n            [ngClass]=\"{ \n              imaged: item.image, \n              'size-small': size === 'small', \n              'size-large': size === 'large',\n              'last-chip': model.length - 1 === index\n            }\"\n            [style.backgroundColor]=\"item.background || background\"\n            [style.color]=\"item.color || color\"\n            (keydown)=\"chipKeyDown($event, index)\"\n            (click)=\"chipClick($event)\"\n            [cdkDragDisabled]=\"!orderable || disabled\"\n            [cdkDragData]=\"item\"\n            tabindex=\"-1\"\n            cdkDrag\n            cdkDragHandle>\n          <ng-container\n            [ngTemplateOutlet]=\"itemTemplate\"\n            [ngTemplateOutletContext]=\"{ item: item, selecting: false }\">\n          </ng-container>\n          <ng-container\n            [ngTemplateOutlet]=\"itemSuffixTemplate\"\n            [ngTemplateOutletContext]=\"{ item: item, selecting: false, disabled: disabled }\">\n          </ng-container>\n        </mat-chip>\n      </div>\n\n      <input\n        #input\n        autocomplete=\"off\"\n        [placeholder]=\"placeholder\"\n        [disabled]=\"disabled\"\n        [readonly]=\"readonly\"\n        (input)=\"inputed($event)\"\n        (keydown)=\"keyDown($event)\"\n        (focus)=\"focused($event)\"\n        [name]=\"name\"\n        [matAutocomplete]=\"autocompleteSearch\"\n        [matChipInputFor]=\"searchList\">\n    </mat-chip-list>\n\n    <span *ngIf=\"chipsSuffixTemplate\" matSuffix>\n      <ng-container [ngTemplateOutlet]=\"chipsSuffixTemplate\"></ng-container>\n    </span>\n\n    <span *ngIf=\"!disabled && allowClear\" matSuffix>\n      <mat-icon\n          *ngIf=\"model.length\"\n          class=\"clear\"\n          (click)=\"clearClick($event)\">\n        clear\n      </mat-icon>\n    </span>\n\n    <mat-autocomplete\n        #autocompleteSearch=\"matAutocomplete\"\n        [class]=\"panelClasses\"\n        (optionSelected)=\"optionSelected($event)\"\n        (closed)=\"closed()\"\n        [panelWidth]=\"panelWidth\"\n        [autoActiveFirstOption]=\"true\">\n\n      <ng-container *ngIf=\"keyword && allowText\">\n        <mat-option *ngIf=\"textData.type===dataType.Text\" [value]=\"textData\" [disabled]=\"!textData.valid\">\n          <ng-container\n            [ngTemplateOutlet]=\"itemTemplate\"\n            [ngTemplateOutletContext]=\"{ item: textData }\">\n          </ng-container>\n        </mat-option>\n      </ng-container>        \n      \n      <mat-option\n        [ngClass]=\"{ multiple: multiple }\"\n        class=\"option\"\n        *ngFor=\"let item of data\" [value]=\"item\">\n        <a\n            *ngIf=\"multiple\"\n            class=\"add-icon\"\n            (click)=\"optionClick($event, item, true)\">\n          <mat-icon>add</mat-icon>\n        </a>\n        <div class=\"option-chip\" (click)=\"optionClick($event, item)\">\n          <mat-radio-button *ngIf=\"!multiple\" [checked]=\"item.selected\"></mat-radio-button>\n          <mat-chip\n              (click)=\"optionClick($event, item)\"\n              [disableRipple]=\"true\"\n              [class]=\"'fs-autocomplete-chip ' + item.class\"\n              [ngClass]=\"{ imaged: item.image, 'size-small': size === 'small', 'size-large': size === 'large' }\"\n              [style.backgroundColor]=\"item.background || background\"\n            [style.color]=\"item.color || color\">\n            <ng-container\n              [ngTemplateOutlet]=\"itemTemplate\"\n              [ngTemplateOutletContext]=\"{ item: item, selecting: true }\">\n            </ng-container>\n            <ng-container\n              [ngTemplateOutlet]=\"itemSuffixTemplate\"\n              [ngTemplateOutletContext]=\"{ item: item, selecting: true, disabled: disabled }\">\n            </ng-container>\n          </mat-chip>\n        </div>\n      </mat-option>\n\n      <ng-container *ngIf=\"noResults !== false\">\n        <ng-template\n          *ngIf=\"noResultsTemplate; else noResultsOption\"\n          [ngTemplateOutlet]=\"noResultsTemplate\"\n          [ngTemplateOutletContext]=\"{ keyword: keyword }\">\n        </ng-template>\n        <ng-template #noResultsOption>\n          <mat-option disabled class=\"no-results\">\n            No results <ng-container *ngIf=\"keyword\">for \"{{keyword}}\"</ng-container>\n          </mat-option>\n        </ng-template>\n      </ng-container>\n\n      <ng-container *ngIf=\"staticTemplates.length\">\n        <div class=\"static-templates\">\n          <mat-option\n            *ngFor=\"let staticTemplate of staticTemplates; let i = index\"\n            class=\"static-option\"\n            (click)=\"staticClick($event, i)\">\n            <ng-template *ngTemplateOutlet=\"staticTemplate;context: { test: true }\"></ng-template>\n          </mat-option>\n        </div>\n      </ng-container>\n\n      <mat-option disabled class=\"blank-placeholder\"></mat-option>\n    </mat-autocomplete>\n    <mat-hint *ngIf=\"hint\">{{ hint }}</mat-hint>\n    <input class=\"dummy-input\" #dummyInput tabindex=\"-1\">\n  </mat-form-field>\n</ng-container>\n\n<ng-template #elseInited>\n  <fs-label-field [ngClass]=\"{ 'init-on-click': initOnClick, inited: inited }\">\n    <fs-label>{{placeholder}}</fs-label>\n    <div (click)=\"init()\">\n      <mat-chip-list\n        *ngIf=\"model.length; else none\">\n        <mat-chip\n          class=\"fs-autocomplete-chips-trigger\"\n          *ngFor=\"let item of model\"\n          [disableRipple]=\"true\"\n          [class]=\"'fs-autocomplete-chip ' + item.class\"\n          [disabled]=\"true\"\n          [ngClass]=\"{ imaged: item.image, 'size-small': size === 'small', 'size-large': size === 'large' }\"\n          [style.backgroundColor]=\"item.background || background\"\n          [style.color]=\"item.color || color\">\n          <ng-container\n            [ngTemplateOutlet]=\"itemTemplate\"\n            [ngTemplateOutletContext]=\"{ item: item, selecting: false }\">\n          </ng-container>\n          <ng-container\n            [ngTemplateOutlet]=\"itemSuffixTemplate\"\n            [ngTemplateOutletContext]=\"{ item: item, selecting: false, disabled: disabled }\">\n          </ng-container>\n        </mat-chip>\n      </mat-chip-list>\n    </div>\n    <fs-label-message *ngIf=\"hint\">\n      {{ hint }}\n    </fs-label-message>\n  </fs-label-field>\n\n  <ng-template #none>\n    <span class=\"none-placeholder\" (click)=\"init()\">None</span>\n  </ng-template>\n</ng-template>\n\n<ng-template #itemTemplate let-item=\"item\" let-selecting=\"selecting\">\n  <ng-container *ngIf=\"item.type===dataType.Object\" class=\"item\">\n    <div class=\"item-image\" *ngIf=\"item.image\" [style.backgroundImage]=\"'url(' + item.image + ')'\"></div>\n    <mat-icon class=\"item-icon\" *ngIf=\"item.icon\" [style.color]=\"item.iconColor || item.color\">{{item.icon}}</mat-icon>\n    <span class=\"item-content\">\n      <ng-template\n        [ngTemplateOutlet]=\"objectTemplate\"\n        [ngTemplateOutletContext]=\"{ object: item.data, selecting: selecting }\">\n      </ng-template>\n    </span>\n  </ng-container>\n\n  <ng-container *ngIf=\"item.type===dataType.Text\">\n    {{item.data}}\n  </ng-container>\n</ng-template>\n\n<ng-template #itemSuffixTemplate let-item=\"item\" let-selecting=\"selecting\">\n  <div class=\"item-suffix\">\n    <ng-container\n      *ngIf=\"chipSuffixTemplate\"\n      [ngTemplateOutlet]=\"chipSuffixTemplate\"\n      [ngTemplateOutletContext]=\"{ object: item.data, selecting: selecting, disabled: disabled }\">\n    </ng-container>\n    <a\n        class=\"remove\"\n        *ngIf=\"!selecting && removable && !disabled\"\n        (click)=\"chipRemoved($event, item)\">\n      <mat-icon\n      [style.color]=\"item.color || color\">clear</mat-icon>\n    </a>\n  </div>\n</ng-template>", styles: [".mat-chip-list{outline:transparent}.blank-placeholder{display:none}.none-placeholder{cursor:pointer;color:#0000008a;border-bottom:1px solid transparent}.none-placeholder:hover{border-bottom-style:dashed}.no-results{background-color:inherit}.dummy-input{width:0;height:0;padding:0;border:0;display:table}:host ::ng-deep .fs-autocomplete-chips-trigger{opacity:1!important}:host ::ng-deep .mat-form-field{min-width:225px;width:100%;letter-spacing:inherit}:host ::ng-deep .mat-form-field .mat-form-field-prefix,:host ::ng-deep .mat-form-field .mat-form-field-suffix{align-self:flex-end}:host ::ng-deep .mat-form-field .mat-form-field-prefix .clear,:host ::ng-deep .mat-form-field .mat-form-field-suffix .clear{cursor:pointer}:host ::ng-deep .mat-form-field.mat-form-field-appearance-legacy.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label{transform:translateY(-1.34375em) scale(.75)}:host ::ng-deep .mat-form-field .mat-chip-list-wrapper{cursor:pointer;line-height:0}:host ::ng-deep .mat-form-field .mat-chip-list-wrapper .mat-chip{line-height:normal}:host ::ng-deep .mat-form-field .mat-chip-list-wrapper .mat-chip:not(.cdk-drag-disabled){cursor:move}:host ::ng-deep .mat-form-field .mat-chip-list-wrapper input.mat-chip-input{width:40px;flex:1 0 40px;margin-right:0;margin-bottom:2px}:host ::ng-deep .mat-chip-list-wrapper .mat-chip{margin:4px 4px 0 0}:host ::ng-deep fs-label-field .field-content{min-height:31px}:host ::ng-deep fs-label-field.init-on-click:not(.inited) .mat-chip,:host ::ng-deep fs-label-field.init-on-click:not(.inited) .mat-chip-list{cursor:pointer}:host ::ng-deep fs-label-field ::ng-deep .field-message{padding-top:7px}:host ::ng-deep .mat-chip-list-wrapper{margin:-4px 0}::ng-deep .fs-autocomplete-chips-panel:not(:hover) .mat-active .option-chip{background-color:#2a2a2a1a}::ng-deep .fs-autocomplete-chips-panel .mat-option-text{align-items:center;display:inline-flex;height:inherit}::ng-deep .fs-autocomplete-chips-panel .static-templates{position:sticky;bottom:0;width:100%;background:#fff}::ng-deep .fs-autocomplete-chips-panel .static-templates mat-option:first-child{border-top:1px solid #e0e0e0}::ng-deep .fs-autocomplete-chips-panel .invalid-message .mat-option-text{line-height:normal;flex-direction:column;align-items:start;font-size:80%}::ng-deep .fs-autocomplete-chips-panel .mat-option{line-height:45px;height:45px}::ng-deep .fs-autocomplete-chips-panel .mat-option.option{padding:0}::ng-deep .fs-autocomplete-chips-panel .mat-option.multiple .option-chip{padding-left:8px}::ng-deep .fs-autocomplete-chips-panel .mat-option .option-chip{-webkit-user-select:none;user-select:none;display:flex;text-overflow:ellipsis;overflow:inherit;cursor:pointer;padding:0 16px;align-items:center;height:inherit;width:100%}::ng-deep .fs-autocomplete-chips-panel .mat-option .option-chip .mat-chip{cursor:pointer;pointer-events:all}::ng-deep .fs-autocomplete-chips-panel .mat-option .option-chip .mat-chip .mat-icon{margin-right:5px}::ng-deep .fs-autocomplete-chips-panel .mat-option .option-chip:hover,::ng-deep .fs-autocomplete-chips-panel .mat-option .add-icon:hover{background-color:#0000001a}::ng-deep .fs-autocomplete-chips-panel .mat-option.mat-active,::ng-deep .fs-autocomplete-chips-panel .mat-option:hover:not(.mat-option-disabled),::ng-deep .fs-autocomplete-chips-panel .mat-option:focus:not(.mat-option-disabled){background:none}::ng-deep .fs-autocomplete-chips-panel .mat-option .add-icon{display:flex;font-size:24px;height:100%;align-items:center;width:45px;display:block;text-align:center;-webkit-user-select:none;user-select:none}::ng-deep .fs-autocomplete-chips-panel .mat-option .add-icon mat-icon{margin:0}::ng-deep .mat-chip.fs-autocomplete-chip{background-color:#f3f3f3;white-space:nowrap;min-height:30px;box-shadow:none!important;-webkit-user-select:none;user-select:none;max-width:100%}::ng-deep .mat-chip.fs-autocomplete-chip:hover:after{opacity:0}::ng-deep .mat-chip.fs-autocomplete-chip.cdk-drag-placeholder{opacity:.5}::ng-deep .mat-chip.fs-autocomplete-chip .item-image{width:30px;height:30px;object-fit:cover;background-repeat:no-repeat;background-size:cover;background-position:50% 50%;margin-right:5px;display:flex;border-radius:50%;flex-shrink:0}::ng-deep .mat-chip.fs-autocomplete-chip .item-content{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}::ng-deep .mat-chip.fs-autocomplete-chip .item-template{display:flex;flex-direction:row;align-items:center}::ng-deep .mat-chip.fs-autocomplete-chip .item-icon{margin:0 5px 0 -5px}::ng-deep .mat-chip.fs-autocomplete-chip .item-suffix{display:flex;align-items:center}::ng-deep .mat-chip.fs-autocomplete-chip .item-suffix a{display:flex}::ng-deep .mat-chip.fs-autocomplete-chip .item-suffix .mat-icon{color:#8f8f8f;opacity:1;margin-left:3px;margin-right:-5px;cursor:pointer;transform:scale(.77)}::ng-deep .mat-chip.fs-autocomplete-chip .item-suffix .mat-icon:hover{color:#202020}::ng-deep .mat-chip.fs-autocomplete-chip.size-small{height:25px;font-size:85%;padding:0 8px;min-height:auto}::ng-deep .mat-chip.fs-autocomplete-chip.size-small .item-image{width:25px;height:25px}::ng-deep .mat-chip.fs-autocomplete-chip.size-small .item-icon{transform:scale(.8);margin-right:0}::ng-deep .mat-chip.fs-autocomplete-chip.imaged{padding-left:0}::ng-deep .mat-chip.fs-autocomplete-chip.imaged .item-image{margin-left:-1px}\n"], components: [{ type: i1__namespace.MatFormField, selector: "mat-form-field", inputs: ["color", "floatLabel", "appearance", "hideRequiredMarker", "hintLabel"], exportAs: ["matFormField"] }, { type: i2__namespace.MatChipList, selector: "mat-chip-list", inputs: ["aria-orientation", "multiple", "compareWith", "value", "required", "placeholder", "disabled", "selectable", "tabIndex", "errorStateMatcher"], outputs: ["change", "valueChange"], exportAs: ["matChipList"] }, { type: i3__namespace.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { type: i4__namespace.MatAutocomplete, selector: "mat-autocomplete", inputs: ["disableRipple"], exportAs: ["matAutocomplete"] }, { type: i5__namespace.MatOption, selector: "mat-option", exportAs: ["matOption"] }, { type: i6__namespace.MatRadioButton, selector: "mat-radio-button", inputs: ["disableRipple", "tabIndex"], exportAs: ["matRadioButton"] }, { type: i7__namespace.FsLabelFieldComponent, selector: "fs-label-field", inputs: ["bottomMargin", "topMargin", "labelMargin"] }, { type: i7__namespace.FsLabelComponent, selector: "fs-label" }, { type: i7__namespace.FsLabelMessageComponent, selector: "fs-label-message" }], directives: [{ type: i8__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i8__namespace.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i9__namespace.CdkDropListGroup, selector: "[cdkDropListGroup]", inputs: ["cdkDropListGroupDisabled"], exportAs: ["cdkDropListGroup"] }, { type: i8__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i9__namespace.CdkDropList, selector: "[cdkDropList], cdk-drop-list", inputs: ["cdkDropListConnectedTo", "id", "cdkDropListEnterPredicate", "cdkDropListSortPredicate", "cdkDropListDisabled", "cdkDropListSortingDisabled", "cdkDropListAutoScrollDisabled", "cdkDropListOrientation", "cdkDropListLockAxis", "cdkDropListData", "cdkDropListAutoScrollStep"], outputs: ["cdkDropListDropped", "cdkDropListEntered", "cdkDropListExited", "cdkDropListSorted"], exportAs: ["cdkDropList"] }, { type: i2__namespace.MatChip, selector: "mat-basic-chip, [mat-basic-chip], mat-chip, [mat-chip]", inputs: ["color", "disableRipple", "tabIndex", "selected", "value", "selectable", "disabled", "removable"], outputs: ["selectionChange", "destroyed", "removed"], exportAs: ["matChip"] }, { type: i9__namespace.CdkDrag, selector: "[cdkDrag]", inputs: ["cdkDragDisabled", "cdkDragStartDelay", "cdkDragLockAxis", "cdkDragConstrainPosition", "cdkDragPreviewClass", "cdkDragBoundary", "cdkDragRootElement", "cdkDragPreviewContainer", "cdkDragData", "cdkDragFreeDragPosition"], outputs: ["cdkDragStarted", "cdkDragReleased", "cdkDragEnded", "cdkDragEntered", "cdkDragExited", "cdkDragDropped", "cdkDragMoved"], exportAs: ["cdkDrag"] }, { type: i9__namespace.CdkDragHandle, selector: "[cdkDragHandle]", inputs: ["cdkDragHandleDisabled"] }, { type: i8__namespace.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }, { type: i4__namespace.MatAutocompleteTrigger, selector: "input[matAutocomplete], textarea[matAutocomplete]", exportAs: ["matAutocompleteTrigger"] }, { type: i2__namespace.MatChipInput, selector: "input[matChipInputFor]", inputs: ["matChipInputSeparatorKeyCodes", "placeholder", "id", "matChipInputFor", "matChipInputAddOnBlur", "disabled"], outputs: ["matChipInputTokenEnd"], exportAs: ["matChipInput", "matChipInputFor"] }, { type: i1__namespace.MatSuffix, selector: "[matSuffix]" }, { type: i1__namespace.MatHint, selector: "mat-hint", inputs: ["align", "id"] }], changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsAutocompleteChipsComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'fs-autocomplete-chips',
                        templateUrl: './autocomplete-chips.component.html',
                        styleUrls: ['./autocomplete-chips.component.scss'],
                        providers: [{
                                provide: forms.NG_VALUE_ACCESSOR,
                                useExisting: i0.forwardRef(function () { return FsAutocompleteChipsComponent; }),
                                multi: true
                            }],
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }]; }, propDecorators: { fetch: [{
                    type: i0.Input
                }], readonly: [{
                    type: i0.Input
                }], size: [{
                    type: i0.Input
                }], placeholder: [{
                    type: i0.Input
                }], chipImage: [{
                    type: i0.Input
                }], chipBackground: [{
                    type: i0.Input
                }], chipColor: [{
                    type: i0.Input
                }], chipIcon: [{
                    type: i0.Input
                }], chipIconColor: [{
                    type: i0.Input
                }], chipClass: [{
                    type: i0.Input
                }], hint: [{
                    type: i0.Input
                }], allowText: [{
                    type: i0.Input
                }], allowObject: [{
                    type: i0.Input
                }], delay: [{
                    type: i0.Input
                }], validateText: [{
                    type: i0.Input
                }], invalidTextMessage: [{
                    type: i0.Input
                }], removable: [{
                    type: i0.Input
                }], allowClear: [{
                    type: i0.Input
                }], color: [{
                    type: i0.Input
                }], background: [{
                    type: i0.Input
                }], orderable: [{
                    type: i0.Input
                }], limit: [{
                    type: i0.Input
                }], initOnClick: [{
                    type: i0.Input
                }], fetchOnFocus: [{
                    type: i0.Input
                }], multiple: [{
                    type: i0.Input
                }], panelClass: [{
                    type: i0.Input
                }], compareWith: [{
                    type: i0.Input
                }], setDisabled: [{
                    type: i0.Input,
                    args: ['disabled']
                }], panelWidth: [{
                    type: i0.Input
                }], selected: [{
                    type: i0.Output
                }], removed: [{
                    type: i0.Output
                }], reordered: [{
                    type: i0.Output
                }], clearEvent: [{
                    type: i0.Output,
                    args: ['clear']
                }], formWrapper: [{
                    type: i0.HostBinding,
                    args: ['class.fs-form-wrapper']
                }], dragStart: [{
                    type: i0.HostListener,
                    args: ['dragstart', ['$event']]
                }], input: [{
                    type: i0.ViewChild,
                    args: ['input']
                }], dummyInput: [{
                    type: i0.ViewChild,
                    args: ['dummyInput']
                }], autocompleteTriggers: [{
                    type: i0.ViewChildren,
                    args: [i4.MatAutocompleteTrigger]
                }], autocompleteTrigger: [{
                    type: i0.ViewChild,
                    args: [i4.MatAutocompleteTrigger]
                }], formField: [{
                    type: i0.ViewChild,
                    args: [i1.MatFormField, { read: i0.ElementRef }]
                }], objectTemplate: [{
                    type: i0.ContentChild,
                    args: [FsAutocompleteObjectDirective, { read: i0.TemplateRef }]
                }], chipSuffixTemplate: [{
                    type: i0.ContentChild,
                    args: [FsAutocompleteChipSuffixDirective, { read: i0.TemplateRef }]
                }], chipsSuffixTemplate: [{
                    type: i0.ContentChild,
                    args: [FsAutocompleteChipsSuffixDirective, { read: i0.TemplateRef }]
                }], noResultsTemplate: [{
                    type: i0.ContentChild,
                    args: [FsAutocompleteChipsNoResultsDirective, { read: i0.TemplateRef, static: true }]
                }], staticTemplates: [{
                    type: i0.ContentChildren,
                    args: [FsAutocompleteChipsStaticDirective, { read: i0.TemplateRef }]
                }], staticDirectives: [{
                    type: i0.ContentChildren,
                    args: [FsAutocompleteChipsStaticDirective]
                }] } });

    var FsAutocompleteChipsModule = /** @class */ (function () {
        function FsAutocompleteChipsModule() {
        }
        FsAutocompleteChipsModule.forRoot = function () {
            return {
                ngModule: FsAutocompleteChipsModule,
            };
        };
        return FsAutocompleteChipsModule;
    }());
    FsAutocompleteChipsModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsAutocompleteChipsModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    FsAutocompleteChipsModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsAutocompleteChipsModule, declarations: [FsAutocompleteObjectDirective,
            FsAutocompleteChipsComponent,
            FsAutocompleteChipsStaticDirective,
            FsAutocompleteChipsNoResultsDirective,
            FsAutocompleteChipSuffixDirective,
            FsAutocompleteChipsSuffixDirective], imports: [i8.CommonModule,
            forms.FormsModule,
            i9.DragDropModule,
            i4.MatAutocompleteModule,
            i2.MatChipsModule,
            input.MatInputModule,
            i3.MatIconModule,
            i6.MatRadioModule,
            i7.FsLabelModule], exports: [FsAutocompleteChipsComponent,
            FsAutocompleteObjectDirective,
            FsAutocompleteChipsStaticDirective,
            FsAutocompleteChipsNoResultsDirective,
            FsAutocompleteChipSuffixDirective,
            FsAutocompleteChipsSuffixDirective] });
    FsAutocompleteChipsModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsAutocompleteChipsModule, imports: [[
                i8.CommonModule,
                forms.FormsModule,
                i9.DragDropModule,
                i4.MatAutocompleteModule,
                i2.MatChipsModule,
                input.MatInputModule,
                i3.MatIconModule,
                i6.MatRadioModule,
                i7.FsLabelModule,
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsAutocompleteChipsModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i8.CommonModule,
                            forms.FormsModule,
                            i9.DragDropModule,
                            i4.MatAutocompleteModule,
                            i2.MatChipsModule,
                            input.MatInputModule,
                            i3.MatIconModule,
                            i6.MatRadioModule,
                            i7.FsLabelModule,
                        ],
                        exports: [
                            FsAutocompleteChipsComponent,
                            FsAutocompleteObjectDirective,
                            FsAutocompleteChipsStaticDirective,
                            FsAutocompleteChipsNoResultsDirective,
                            FsAutocompleteChipSuffixDirective,
                            FsAutocompleteChipsSuffixDirective,
                        ],
                        declarations: [
                            FsAutocompleteObjectDirective,
                            FsAutocompleteChipsComponent,
                            FsAutocompleteChipsStaticDirective,
                            FsAutocompleteChipsNoResultsDirective,
                            FsAutocompleteChipSuffixDirective,
                            FsAutocompleteChipsSuffixDirective,
                        ],
                    }]
            }] });

    /*
     * Public API Surface of fs-menu
     */

    /**
     * Generated bundle index. Do not edit.
     */

    exports.FsAutocompleteChipSuffixDirective = FsAutocompleteChipSuffixDirective;
    exports.FsAutocompleteChipsComponent = FsAutocompleteChipsComponent;
    exports.FsAutocompleteChipsModule = FsAutocompleteChipsModule;
    exports.FsAutocompleteChipsNoResultsDirective = FsAutocompleteChipsNoResultsDirective;
    exports.FsAutocompleteChipsStaticDirective = FsAutocompleteChipsStaticDirective;
    exports.FsAutocompleteChipsSuffixDirective = FsAutocompleteChipsSuffixDirective;
    exports.FsAutocompleteObjectDirective = FsAutocompleteObjectDirective;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=firestitch-autocomplete-chips.umd.js.map
