import * as i0 from '@angular/core';
import { Directive, EventEmitter, Output, forwardRef, TemplateRef, ElementRef, Component, ChangeDetectionStrategy, Input, HostBinding, HostListener, ViewChild, ViewChildren, ContentChild, ContentChildren, NgModule } from '@angular/core';
import * as i8 from '@angular/common';
import { CommonModule } from '@angular/common';
import { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';
import * as i4 from '@angular/material/autocomplete';
import { MatAutocompleteTrigger, MatAutocompleteModule } from '@angular/material/autocomplete';
import * as i2 from '@angular/material/chips';
import { MatChipsModule } from '@angular/material/chips';
import * as i3 from '@angular/material/icon';
import { MatIconModule } from '@angular/material/icon';
import { MatInputModule } from '@angular/material/input';
import * as i6 from '@angular/material/radio';
import { MatRadioModule } from '@angular/material/radio';
import * as i9 from '@angular/cdk/drag-drop';
import { moveItemInArray, DragDropModule } from '@angular/cdk/drag-drop';
import * as i7 from '@firestitch/label';
import { FsLabelModule } from '@firestitch/label';
import * as i1 from '@angular/material/form-field';
import { MatFormField } from '@angular/material/form-field';
import { BACKSPACE, DELETE } from '@angular/cdk/keycodes';
import { isEqual, random } from 'lodash-es';
import { Subject, timer, of } from 'rxjs';
import { filter, tap, debounce, takeUntil, switchMap } from 'rxjs/operators';
import * as i5 from '@angular/material/core';

function getObjectValue(attribute, mapping) {
    if (!mapping) {
        return null;
    }
    return _getObjectValue(attribute, mapping.split('.'));
}
function _getObjectValue(value, indexes) {
    const index = indexes.shift(indexes);
    if (!index) {
        return value;
    }
    if (!value) {
        return value;
    }
    value = value[index];
    return _getObjectValue(value, indexes);
}

var DataType;
(function (DataType) {
    DataType["Object"] = "object";
    DataType["Text"] = "text";
})(DataType || (DataType = {}));

class FsAutocompleteObjectDirective {
}
FsAutocompleteObjectDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsAutocompleteObjectDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
FsAutocompleteObjectDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: FsAutocompleteObjectDirective, selector: "[fsAutocompleteObject],[fsAutocompleteChipsTemplate]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsAutocompleteObjectDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[fsAutocompleteObject],[fsAutocompleteChipsTemplate]'
                }]
        }] });

class FsAutocompleteChipsNoResultsDirective {
}
FsAutocompleteChipsNoResultsDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsAutocompleteChipsNoResultsDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
FsAutocompleteChipsNoResultsDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: FsAutocompleteChipsNoResultsDirective, selector: "[fsAutocompleteChipsNoResults]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsAutocompleteChipsNoResultsDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[fsAutocompleteChipsNoResults]'
                }]
        }] });

class FsAutocompleteChipsStaticDirective {
    constructor() {
        this.click = new EventEmitter();
    }
}
FsAutocompleteChipsStaticDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsAutocompleteChipsStaticDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
FsAutocompleteChipsStaticDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: FsAutocompleteChipsStaticDirective, selector: "[fsAutocompleteChipsStatic]", outputs: { click: "click" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsAutocompleteChipsStaticDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[fsAutocompleteChipsStatic]'
                }]
        }], propDecorators: { click: [{
                type: Output
            }] } });

class FsAutocompleteChipSuffixDirective {
}
FsAutocompleteChipSuffixDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsAutocompleteChipSuffixDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
FsAutocompleteChipSuffixDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: FsAutocompleteChipSuffixDirective, selector: "[fsAutocompleteChipSuffix]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsAutocompleteChipSuffixDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[fsAutocompleteChipSuffix]'
                }]
        }] });

class FsAutocompleteChipsSuffixDirective {
}
FsAutocompleteChipsSuffixDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsAutocompleteChipsSuffixDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
FsAutocompleteChipsSuffixDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: FsAutocompleteChipsSuffixDirective, selector: "[fsAutocompleteChipsSuffix]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsAutocompleteChipsSuffixDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[fsAutocompleteChipsSuffix]'
                }]
        }] });

class FsAutocompleteChipsComponent {
    constructor(_cdRef) {
        this._cdRef = _cdRef;
        this.fetch = null;
        this.readonly = false;
        this.size = 'large';
        this.placeholder = '';
        this.chipImage = 'image';
        this.allowObject = true;
        this.delay = 200;
        this.invalidTextMessage = '';
        this.removable = true;
        this.allowClear = true;
        this.color = '';
        this.background = '';
        this.orderable = false;
        this.limit = 0;
        this.initOnClick = false;
        this.fetchOnFocus = true;
        this.multiple = true;
        this.compareWith = (o1, o2) => {
            return isEqual(o1, o2);
        };
        this.panelWidth = null;
        this.selected = new EventEmitter();
        this.removed = new EventEmitter();
        this.reordered = new EventEmitter();
        this.clearEvent = new EventEmitter();
        this.formWrapper = true;
        this.input = null;
        this.dummyInput = null;
        this.autocompleteTrigger = null;
        this.formField = null;
        this.objectTemplate = null;
        this.chipSuffixTemplate = null;
        this.chipsSuffixTemplate = null;
        this.noResultsTemplate = null;
        this.staticTemplates = null;
        this.textData = {};
        this.disabled = false;
        this.dataType = DataType;
        this.keyword = null;
        this.noResults = false;
        this.name = 'autocomplete_'.concat(random(1, 9999999));
        this._model = [];
        this.inited = false;
        this._keyword$ = new Subject();
        this._fetch$ = new Subject();
        this._destroy$ = new Subject();
        this._onTouched = () => { };
        this._onChange = (value) => { };
        this.panelClass = '';
    }
    set panelClass(value) {
        this.panelClasses = [
            ...['fs-account-picker-autocomplete', 'fs-autocomplete-chips-panel'],
            value,
        ].join(' ');
    }
    ;
    set setDisabled(value) {
        this.disabled = value;
    }
    dragStart(e) {
        e.preventDefault();
    }
    ;
    get model() {
        return this._model;
    }
    get inputEl() {
        return this.input ? this.input.nativeElement : null;
    }
    registerOnChange(fn) { this._onChange = fn; }
    registerOnTouched(fn) { this._onTouched = fn; }
    ngOnInit() {
        this.inited = !this.initOnClick;
        this._listenFetch();
        this._listenKeywordChange();
    }
    init(options = { focus: true }) {
        if (!this.disabled) {
            this.inited = true;
            this._cdRef.markForCheck();
            if (options.focus) {
                this.focus({ delay: 200 });
            }
        }
    }
    drop(event) {
        const previousIndex = event.previousContainer.data.index;
        const index = event.container.data.index;
        moveItemInArray(this._model, previousIndex, index);
        this.reordered.emit({
            item: this._model[index],
            from: previousIndex,
            to: index,
            items: this._model,
        });
        this._updateModel(this._model);
    }
    selectAll() {
        this.data.forEach((selected) => {
            if (selected.type === DataType.Object) {
                this._addObject(selected);
            }
            if (selected.type === DataType.Text) {
                this._addText(selected.data);
            }
        });
    }
    inputed(event) {
        if (this.readonly || this.disabled) {
            return;
        }
        this._keyword$.next(event);
    }
    keyDown(event) {
        if (this.readonly || this.disabled || ['Enter', 'ArrowDown', 'ArrowUp'].indexOf(event.code) !== -1) {
            return;
        }
        if (event.code === 'Tab') {
            const activeOption = this.autocompleteTrigger.activeOption;
            if (activeOption) {
                if (activeOption.value.type === DataType.Object) {
                    this._addObject(activeOption.value);
                    this.selected.emit(activeOption.value);
                }
                else if (activeOption.value.type === DataType.Text) {
                    this._addText(this.keyword);
                    this.selected.emit(this.keyword);
                }
            }
        }
        this._clearData();
    }
    chipClick(event) {
        this.focus();
    }
    chipKeyDown(event, index) {
        if (event.keyCode === BACKSPACE || event.keyCode === DELETE) {
            if (this.multiple) {
                this.model.splice(index, 1);
                this._updateModel(this.model);
            }
            else {
                this._updateModel([]);
            }
        }
    }
    chipRemoved(event, item) {
        event.stopPropagation();
        event.stopImmediatePropagation();
        this._model = this.model
            .filter((modelItem) => modelItem !== item);
        this._updateModel(this._model);
        this.removed.emit(item);
        this.unfocus();
    }
    focus(options = { delay: 0 }) {
        setTimeout(() => {
            this.inputEl.focus();
        }, options.delay); // Hack: Delay to wait for animation to finish
    }
    unfocus() {
        setTimeout(() => {
            if (this.dummyInput) {
                this.dummyInput.nativeElement.focus();
            }
        });
    }
    clearClick(event) {
        event.stopPropagation();
        this.clear(true);
        this.clearEvent.emit();
    }
    clear(closePanel = true) {
        if (closePanel) {
            this.closePanel();
        }
        this._clearInput();
        this.noResults = false;
        this._updateModel([]);
    }
    closePanel() {
        if (this.autocompleteTrigger) {
            this.autocompleteTrigger.closePanel();
        }
    }
    closed() {
        setTimeout(() => {
            this._close();
            if (this.initOnClick) {
                // Wait for keyDown() to fire to process
                this.inited = false;
                this._cdRef.markForCheck();
            }
            this._clearData();
        });
    }
    focused(e) {
        this._clearInput();
        if (this.fetchOnFocus) {
            this._fetch();
            this.autocompleteTrigger.openPanel();
        }
    }
    optionClick(event, value, refocus = false) {
        event.stopPropagation();
        event.preventDefault();
        // Clear input before close to prevent adding text item which was not selected
        if (!refocus) {
            this._clearInput();
        }
        if (this.multiple) {
            this._select(value, { fetch: !this.fetchOnFocus });
            if (!refocus) {
                this.closePanel();
            }
        }
        else {
            this._select(value, { fetch: false });
            this._close();
            this.closePanel();
        }
    }
    optionSelected(event) {
        if (!event.option.value) {
            return;
        }
        this._select(event.option.value);
        this._clearData();
        this._clearInput();
    }
    writeValue(value) {
        if (value) {
            value = Array.isArray(value) ? value : [value];
            value = value.map((item) => {
                return typeof item === 'object' ?
                    this._createObjectItem(item) :
                    this._createTextItem(item, true);
            });
        }
        else {
            value = [];
        }
        this._model = value;
        this._cdRef.markForCheck();
    }
    staticClick(event, index) {
        event.stopPropagation();
        event.preventDefault();
        const staticDirective = this.staticDirectives.toArray()[index];
        staticDirective.click.emit(event);
        if (this.inputEl) {
            this.inputEl.blur();
        }
    }
    ngOnDestroy() {
        this._destroy$.next();
        this._destroy$.complete();
    }
    _clearData() {
        this.data = null;
    }
    _clearInput() {
        if (this.inputEl) {
            this.inputEl.value = '';
        }
        this.textData = {};
        this.keyword = '';
    }
    _select(selected, options = {}) {
        if (!this.multiple) {
            this._model = [];
        }
        if (this.data) {
            const index = this.data.indexOf(selected);
            if (index !== -1) {
                this.data.splice(index, 1);
            }
        }
        const value = this.allowObject && this.allowText ? selected : selected.data;
        if (selected.type === DataType.Object) {
            if (!this._model.includes(value)) {
                this._addObject(selected);
                this.selected.emit(selected);
            }
        }
        if (selected.type === DataType.Text) {
            if (!this._model.includes(value)) {
                this._addText(selected.data);
                this.selected.emit(selected.data);
            }
        }
        if (options.fetch !== false) {
            this._fetch();
            setTimeout(() => {
                if (this.autocompleteTrigger) {
                    this.autocompleteTrigger.updatePosition();
                }
            });
        }
    }
    _createTextItem(data, valid) {
        return {
            data,
            type: DataType.Text,
            valid,
        };
    }
    _createObjectItem(data) {
        return {
            data,
            type: DataType.Object,
            image: getObjectValue(data, this.chipImage),
            icon: getObjectValue(data, this.chipIcon),
            iconColor: getObjectValue(data, this.chipIconColor) || this.chipIconColor,
            class: getObjectValue(data, this.chipClass) || this.chipClass,
            background: getObjectValue(data, this.chipBackground) || this.chipBackground,
            color: getObjectValue(data, this.chipColor) || this.chipColor
        };
    }
    _validateText(text) {
        return String(text).trim().length && (!this.validateText || this.validateText(text));
    }
    _updateModel(value) {
        this._model = value;
        const model = this._model.map((item) => {
            if (!this.allowText || !this.allowObject) {
                return item.data;
            }
            return item;
        });
        this._onChange(this.multiple ? model : model[0]);
        this._onTouched();
    }
    _addObject(object) {
        this._updateModel([...this._model, object]);
    }
    _addText(text) {
        if (this._validateText(text)) {
            const textObject = this._createTextItem(text, true);
            this._updateModel([...this._model, textObject]);
        }
    }
    _close() {
        this._clearInput();
    }
    _fetch() {
        this._fetch$.next(null);
    }
    _listenKeywordChange() {
        this._keyword$
            .pipe(filter(() => this.inited), tap((e) => {
            if (e.data === ',') {
                this._select({
                    type: DataType.Text,
                    data: this.keyword,
                });
                this._clearInput();
            }
            else {
                this.keyword = this.inputEl ? this.inputEl.value.trim() : '';
            }
            this.data = null;
        }), debounce(() => {
            let delay = 0;
            if (this.keyword.length && this.allowObject) {
                delay = this.delay;
            }
            return timer(delay);
        }), takeUntil(this._destroy$))
            .subscribe(() => {
            this._fetch$.next(this.keyword);
        });
    }
    _listenFetch() {
        this._fetch$
            .pipe(filter(() => this.inited), switchMap((keyword) => {
            if (this.allowText) {
                this.textData = this._createTextItem(keyword, this._validateText(keyword));
            }
            if (this.allowObject) {
                this.noResults = false;
                return this._doFetchByKeyword(keyword);
            }
            return of([]);
        }), takeUntil(this._destroy$))
            .subscribe(() => {
            this._cdRef.markForCheck();
        });
    }
    _doFetchByKeyword(keyword) {
        return this.fetch(keyword)
            .pipe(tap((response) => {
            if (!Array.isArray(response)) {
                return;
            }
            this.data = response.map(data => {
                return this._createObjectItem(data);
            });
            if (this.multiple) {
                this.data = this.data.filter((item) => {
                    return !this.model.some((model) => {
                        return this.compareWith(model.data, item.data);
                    });
                });
            }
            else {
                const selected = this.data.find((item) => {
                    return this.model.some((model) => {
                        return this.compareWith(model.data, item.data);
                    });
                });
                if (selected) {
                    selected.selected = true;
                }
            }
            this.noResults = !this.data.length;
        }));
    }
}
FsAutocompleteChipsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsAutocompleteChipsComponent, deps: [{ token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
FsAutocompleteChipsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: FsAutocompleteChipsComponent, selector: "fs-autocomplete-chips", inputs: { fetch: "fetch", readonly: "readonly", size: "size", placeholder: "placeholder", chipImage: "chipImage", chipBackground: "chipBackground", chipColor: "chipColor", chipIcon: "chipIcon", chipIconColor: "chipIconColor", chipClass: "chipClass", hint: "hint", allowText: "allowText", allowObject: "allowObject", delay: "delay", validateText: "validateText", invalidTextMessage: "invalidTextMessage", removable: "removable", allowClear: "allowClear", color: "color", background: "background", orderable: "orderable", limit: "limit", initOnClick: "initOnClick", fetchOnFocus: "fetchOnFocus", multiple: "multiple", panelClass: "panelClass", compareWith: "compareWith", setDisabled: ["disabled", "setDisabled"], panelWidth: "panelWidth" }, outputs: { selected: "selected", removed: "removed", reordered: "reordered", clearEvent: "clear" }, host: { listeners: { "dragstart": "dragStart($event)" }, properties: { "class.fs-form-wrapper": "this.formWrapper" } }, providers: [{
            provide: NG_VALUE_ACCESSOR,
            useExisting: forwardRef(() => FsAutocompleteChipsComponent),
            multi: true
        }], queries: [{ propertyName: "objectTemplate", first: true, predicate: FsAutocompleteObjectDirective, descendants: true, read: TemplateRef }, { propertyName: "chipSuffixTemplate", first: true, predicate: FsAutocompleteChipSuffixDirective, descendants: true, read: TemplateRef }, { propertyName: "chipsSuffixTemplate", first: true, predicate: FsAutocompleteChipsSuffixDirective, descendants: true, read: TemplateRef }, { propertyName: "noResultsTemplate", first: true, predicate: FsAutocompleteChipsNoResultsDirective, descendants: true, read: TemplateRef, static: true }, { propertyName: "staticTemplates", predicate: FsAutocompleteChipsStaticDirective, read: TemplateRef }, { propertyName: "staticDirectives", predicate: FsAutocompleteChipsStaticDirective }], viewQueries: [{ propertyName: "input", first: true, predicate: ["input"], descendants: true }, { propertyName: "dummyInput", first: true, predicate: ["dummyInput"], descendants: true }, { propertyName: "autocompleteTrigger", first: true, predicate: MatAutocompleteTrigger, descendants: true }, { propertyName: "formField", first: true, predicate: MatFormField, descendants: true, read: ElementRef }, { propertyName: "autocompleteTriggers", predicate: MatAutocompleteTrigger, descendants: true }], ngImport: i0, template: "<ng-container *ngIf=\"inited; else elseInited\">\n  <mat-form-field\n      [ngClass]=\"{ 'mat-form-field-disabled': disabled }\"\n      [floatLabel]=\"initOnClick ? 'always' : 'auto'\"\n      (click)=\"focus()\">\n    <mat-chip-list\n        [tabIndex]=\"-1\"\n        cdkDropListGroup\n        #searchList>\n      <div\n          *ngFor=\"let item of model; let index = index\"\n          cdkDropList\n          [cdkDropListData]=\"{ index: index }\"\n          cdkDropListOrientation=\"horizontal\"\n          (cdkDropListDropped)=\"drop($event)\">\n        <mat-chip\n            [disableRipple]=\"true\"\n            [selectable]=\"!disabled\"\n            [removable]=\"!disabled\"\n            [disabled]=\"disabled\"\n            [class]=\"'fs-autocomplete-chip ' + item.class\"\n            [ngClass]=\"{ \n              imaged: item.image, \n              'size-small': size === 'small', \n              'size-large': size === 'large',\n              'last-chip': model.length - 1 === index\n            }\"\n            [style.backgroundColor]=\"item.background || background\"\n            [style.color]=\"item.color || color\"\n            (keydown)=\"chipKeyDown($event, index)\"\n            (click)=\"chipClick($event)\"\n            [cdkDragDisabled]=\"!orderable || disabled\"\n            [cdkDragData]=\"item\"\n            tabindex=\"-1\"\n            cdkDrag\n            cdkDragHandle>\n          <ng-container\n            [ngTemplateOutlet]=\"itemTemplate\"\n            [ngTemplateOutletContext]=\"{ item: item, selecting: false }\">\n          </ng-container>\n          <ng-container\n            [ngTemplateOutlet]=\"itemSuffixTemplate\"\n            [ngTemplateOutletContext]=\"{ item: item, selecting: false, disabled: disabled }\">\n          </ng-container>\n        </mat-chip>\n      </div>\n\n      <input\n        #input\n        autocomplete=\"off\"\n        [placeholder]=\"placeholder\"\n        [disabled]=\"disabled\"\n        [readonly]=\"readonly\"\n        (input)=\"inputed($event)\"\n        (keydown)=\"keyDown($event)\"\n        (focus)=\"focused($event)\"\n        [name]=\"name\"\n        [matAutocomplete]=\"autocompleteSearch\"\n        [matChipInputFor]=\"searchList\">\n    </mat-chip-list>\n\n    <span *ngIf=\"chipsSuffixTemplate\" matSuffix>\n      <ng-container [ngTemplateOutlet]=\"chipsSuffixTemplate\"></ng-container>\n    </span>\n\n    <span *ngIf=\"!disabled && allowClear\" matSuffix>\n      <mat-icon\n          *ngIf=\"model.length\"\n          class=\"clear\"\n          (click)=\"clearClick($event)\">\n        clear\n      </mat-icon>\n    </span>\n\n    <mat-autocomplete\n        #autocompleteSearch=\"matAutocomplete\"\n        [class]=\"panelClasses\"\n        (optionSelected)=\"optionSelected($event)\"\n        (closed)=\"closed()\"\n        [panelWidth]=\"panelWidth\"\n        [autoActiveFirstOption]=\"true\">\n\n      <ng-container *ngIf=\"keyword && allowText\">\n        <mat-option *ngIf=\"textData.type===dataType.Text\" [value]=\"textData\" [disabled]=\"!textData.valid\">\n          <ng-container\n            [ngTemplateOutlet]=\"itemTemplate\"\n            [ngTemplateOutletContext]=\"{ item: textData }\">\n          </ng-container>\n        </mat-option>\n      </ng-container>        \n      \n      <mat-option\n        [ngClass]=\"{ multiple: multiple }\"\n        class=\"option\"\n        *ngFor=\"let item of data\" [value]=\"item\">\n        <a\n            *ngIf=\"multiple\"\n            class=\"add-icon\"\n            (click)=\"optionClick($event, item, true)\">\n          <mat-icon>add</mat-icon>\n        </a>\n        <div class=\"option-chip\" (click)=\"optionClick($event, item)\">\n          <mat-radio-button *ngIf=\"!multiple\" [checked]=\"item.selected\"></mat-radio-button>\n          <mat-chip\n              (click)=\"optionClick($event, item)\"\n              [disableRipple]=\"true\"\n              [class]=\"'fs-autocomplete-chip ' + item.class\"\n              [ngClass]=\"{ imaged: item.image, 'size-small': size === 'small', 'size-large': size === 'large' }\"\n              [style.backgroundColor]=\"item.background || background\"\n            [style.color]=\"item.color || color\">\n            <ng-container\n              [ngTemplateOutlet]=\"itemTemplate\"\n              [ngTemplateOutletContext]=\"{ item: item, selecting: true }\">\n            </ng-container>\n            <ng-container\n              [ngTemplateOutlet]=\"itemSuffixTemplate\"\n              [ngTemplateOutletContext]=\"{ item: item, selecting: true, disabled: disabled }\">\n            </ng-container>\n          </mat-chip>\n        </div>\n      </mat-option>\n\n      <ng-container *ngIf=\"noResults !== false\">\n        <ng-template\n          *ngIf=\"noResultsTemplate; else noResultsOption\"\n          [ngTemplateOutlet]=\"noResultsTemplate\"\n          [ngTemplateOutletContext]=\"{ keyword: keyword }\">\n        </ng-template>\n        <ng-template #noResultsOption>\n          <mat-option disabled class=\"no-results\">\n            No results <ng-container *ngIf=\"keyword\">for \"{{keyword}}\"</ng-container>\n          </mat-option>\n        </ng-template>\n      </ng-container>\n\n      <ng-container *ngIf=\"staticTemplates.length\">\n        <div class=\"static-templates\">\n          <mat-option\n            *ngFor=\"let staticTemplate of staticTemplates; let i = index\"\n            class=\"static-option\"\n            (click)=\"staticClick($event, i)\">\n            <ng-template *ngTemplateOutlet=\"staticTemplate;context: { test: true }\"></ng-template>\n          </mat-option>\n        </div>\n      </ng-container>\n\n      <mat-option disabled class=\"blank-placeholder\"></mat-option>\n    </mat-autocomplete>\n    <mat-hint *ngIf=\"hint\">{{ hint }}</mat-hint>\n    <input class=\"dummy-input\" #dummyInput tabindex=\"-1\">\n  </mat-form-field>\n</ng-container>\n\n<ng-template #elseInited>\n  <fs-label-field [ngClass]=\"{ 'init-on-click': initOnClick, inited: inited }\">\n    <fs-label>{{placeholder}}</fs-label>\n    <div (click)=\"init()\">\n      <mat-chip-list\n        *ngIf=\"model.length; else none\">\n        <mat-chip\n          class=\"fs-autocomplete-chips-trigger\"\n          *ngFor=\"let item of model\"\n          [disableRipple]=\"true\"\n          [class]=\"'fs-autocomplete-chip ' + item.class\"\n          [disabled]=\"true\"\n          [ngClass]=\"{ imaged: item.image, 'size-small': size === 'small', 'size-large': size === 'large' }\"\n          [style.backgroundColor]=\"item.background || background\"\n          [style.color]=\"item.color || color\">\n          <ng-container\n            [ngTemplateOutlet]=\"itemTemplate\"\n            [ngTemplateOutletContext]=\"{ item: item, selecting: false }\">\n          </ng-container>\n          <ng-container\n            [ngTemplateOutlet]=\"itemSuffixTemplate\"\n            [ngTemplateOutletContext]=\"{ item: item, selecting: false, disabled: disabled }\">\n          </ng-container>\n        </mat-chip>\n      </mat-chip-list>\n    </div>\n    <fs-label-message *ngIf=\"hint\">\n      {{ hint }}\n    </fs-label-message>\n  </fs-label-field>\n\n  <ng-template #none>\n    <span class=\"none-placeholder\" (click)=\"init()\">None</span>\n  </ng-template>\n</ng-template>\n\n<ng-template #itemTemplate let-item=\"item\" let-selecting=\"selecting\">\n  <ng-container *ngIf=\"item.type===dataType.Object\" class=\"item\">\n    <div class=\"item-image\" *ngIf=\"item.image\" [style.backgroundImage]=\"'url(' + item.image + ')'\"></div>\n    <mat-icon class=\"item-icon\" *ngIf=\"item.icon\" [style.color]=\"item.iconColor || item.color\">{{item.icon}}</mat-icon>\n    <span class=\"item-content\">\n      <ng-template\n        [ngTemplateOutlet]=\"objectTemplate\"\n        [ngTemplateOutletContext]=\"{ object: item.data, selecting: selecting }\">\n      </ng-template>\n    </span>\n  </ng-container>\n\n  <ng-container *ngIf=\"item.type===dataType.Text\">\n    {{item.data}}\n  </ng-container>\n</ng-template>\n\n<ng-template #itemSuffixTemplate let-item=\"item\" let-selecting=\"selecting\">\n  <div class=\"item-suffix\">\n    <ng-container\n      *ngIf=\"chipSuffixTemplate\"\n      [ngTemplateOutlet]=\"chipSuffixTemplate\"\n      [ngTemplateOutletContext]=\"{ object: item.data, selecting: selecting, disabled: disabled }\">\n    </ng-container>\n    <a\n        class=\"remove\"\n        *ngIf=\"!selecting && removable && !disabled\"\n        (click)=\"chipRemoved($event, item)\">\n      <mat-icon\n      [style.color]=\"item.color || color\">clear</mat-icon>\n    </a>\n  </div>\n</ng-template>", styles: [".mat-chip-list{outline:transparent}.blank-placeholder{display:none}.none-placeholder{cursor:pointer;color:#0000008a;border-bottom:1px solid transparent}.none-placeholder:hover{border-bottom-style:dashed}.no-results{background-color:inherit}.dummy-input{width:0;height:0;padding:0;border:0;display:table}:host ::ng-deep .fs-autocomplete-chips-trigger{opacity:1!important}:host ::ng-deep .mat-form-field{min-width:225px;width:100%;letter-spacing:inherit}:host ::ng-deep .mat-form-field .mat-form-field-prefix,:host ::ng-deep .mat-form-field .mat-form-field-suffix{align-self:flex-end}:host ::ng-deep .mat-form-field .mat-form-field-prefix .clear,:host ::ng-deep .mat-form-field .mat-form-field-suffix .clear{cursor:pointer}:host ::ng-deep .mat-form-field.mat-form-field-appearance-legacy.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label{transform:translateY(-1.34375em) scale(.75)}:host ::ng-deep .mat-form-field .mat-chip-list-wrapper{cursor:pointer;line-height:0}:host ::ng-deep .mat-form-field .mat-chip-list-wrapper .mat-chip{line-height:normal}:host ::ng-deep .mat-form-field .mat-chip-list-wrapper .mat-chip:not(.cdk-drag-disabled){cursor:move}:host ::ng-deep .mat-form-field .mat-chip-list-wrapper input.mat-chip-input{width:40px;flex:1 0 40px;margin-right:0;margin-bottom:2px}:host ::ng-deep .mat-chip-list-wrapper .mat-chip{margin:4px 4px 0 0}:host ::ng-deep fs-label-field .field-content{min-height:31px}:host ::ng-deep fs-label-field.init-on-click:not(.inited) .mat-chip,:host ::ng-deep fs-label-field.init-on-click:not(.inited) .mat-chip-list{cursor:pointer}:host ::ng-deep fs-label-field ::ng-deep .field-message{padding-top:7px}:host ::ng-deep .mat-chip-list-wrapper{margin:-4px 0}::ng-deep .fs-autocomplete-chips-panel:not(:hover) .mat-active .option-chip{background-color:#2a2a2a1a}::ng-deep .fs-autocomplete-chips-panel .mat-option-text{align-items:center;display:inline-flex;height:inherit}::ng-deep .fs-autocomplete-chips-panel .static-templates{position:sticky;bottom:0;width:100%;background:#fff}::ng-deep .fs-autocomplete-chips-panel .static-templates mat-option:first-child{border-top:1px solid #e0e0e0}::ng-deep .fs-autocomplete-chips-panel .invalid-message .mat-option-text{line-height:normal;flex-direction:column;align-items:start;font-size:80%}::ng-deep .fs-autocomplete-chips-panel .mat-option{line-height:45px;height:45px}::ng-deep .fs-autocomplete-chips-panel .mat-option.option{padding:0}::ng-deep .fs-autocomplete-chips-panel .mat-option.multiple .option-chip{padding-left:8px}::ng-deep .fs-autocomplete-chips-panel .mat-option .option-chip{-webkit-user-select:none;user-select:none;display:flex;text-overflow:ellipsis;overflow:inherit;cursor:pointer;padding:0 16px;align-items:center;height:inherit;width:100%}::ng-deep .fs-autocomplete-chips-panel .mat-option .option-chip .mat-chip{cursor:pointer;pointer-events:all}::ng-deep .fs-autocomplete-chips-panel .mat-option .option-chip .mat-chip .mat-icon{margin-right:5px}::ng-deep .fs-autocomplete-chips-panel .mat-option .option-chip:hover,::ng-deep .fs-autocomplete-chips-panel .mat-option .add-icon:hover{background-color:#0000001a}::ng-deep .fs-autocomplete-chips-panel .mat-option.mat-active,::ng-deep .fs-autocomplete-chips-panel .mat-option:hover:not(.mat-option-disabled),::ng-deep .fs-autocomplete-chips-panel .mat-option:focus:not(.mat-option-disabled){background:none}::ng-deep .fs-autocomplete-chips-panel .mat-option .add-icon{display:flex;font-size:24px;height:100%;align-items:center;width:45px;display:block;text-align:center;-webkit-user-select:none;user-select:none}::ng-deep .fs-autocomplete-chips-panel .mat-option .add-icon mat-icon{margin:0}::ng-deep .mat-chip.fs-autocomplete-chip{background-color:#f3f3f3;white-space:nowrap;min-height:30px;box-shadow:none!important;-webkit-user-select:none;user-select:none;max-width:100%}::ng-deep .mat-chip.fs-autocomplete-chip:hover:after{opacity:0}::ng-deep .mat-chip.fs-autocomplete-chip.cdk-drag-placeholder{opacity:.5}::ng-deep .mat-chip.fs-autocomplete-chip .item-image{width:30px;height:30px;object-fit:cover;background-repeat:no-repeat;background-size:cover;background-position:50% 50%;margin-right:5px;display:flex;border-radius:50%;flex-shrink:0}::ng-deep .mat-chip.fs-autocomplete-chip .item-content{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}::ng-deep .mat-chip.fs-autocomplete-chip .item-template{display:flex;flex-direction:row;align-items:center}::ng-deep .mat-chip.fs-autocomplete-chip .item-icon{margin:0 5px 0 -5px}::ng-deep .mat-chip.fs-autocomplete-chip .item-suffix{display:flex;align-items:center}::ng-deep .mat-chip.fs-autocomplete-chip .item-suffix a{display:flex}::ng-deep .mat-chip.fs-autocomplete-chip .item-suffix .mat-icon{color:#8f8f8f;opacity:1;margin-left:3px;margin-right:-5px;cursor:pointer;transform:scale(.77)}::ng-deep .mat-chip.fs-autocomplete-chip .item-suffix .mat-icon:hover{color:#202020}::ng-deep .mat-chip.fs-autocomplete-chip.size-small{height:25px;font-size:85%;padding:0 8px;min-height:auto}::ng-deep .mat-chip.fs-autocomplete-chip.size-small .item-image{width:25px;height:25px}::ng-deep .mat-chip.fs-autocomplete-chip.size-small .item-icon{transform:scale(.8);margin-right:0}::ng-deep .mat-chip.fs-autocomplete-chip.imaged{padding-left:0}::ng-deep .mat-chip.fs-autocomplete-chip.imaged .item-image{margin-left:-1px}\n"], components: [{ type: i1.MatFormField, selector: "mat-form-field", inputs: ["color", "floatLabel", "appearance", "hideRequiredMarker", "hintLabel"], exportAs: ["matFormField"] }, { type: i2.MatChipList, selector: "mat-chip-list", inputs: ["aria-orientation", "multiple", "compareWith", "value", "required", "placeholder", "disabled", "selectable", "tabIndex", "errorStateMatcher"], outputs: ["change", "valueChange"], exportAs: ["matChipList"] }, { type: i3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { type: i4.MatAutocomplete, selector: "mat-autocomplete", inputs: ["disableRipple"], exportAs: ["matAutocomplete"] }, { type: i5.MatOption, selector: "mat-option", exportAs: ["matOption"] }, { type: i6.MatRadioButton, selector: "mat-radio-button", inputs: ["disableRipple", "tabIndex"], exportAs: ["matRadioButton"] }, { type: i7.FsLabelFieldComponent, selector: "fs-label-field", inputs: ["bottomMargin", "topMargin", "labelMargin"] }, { type: i7.FsLabelComponent, selector: "fs-label" }, { type: i7.FsLabelMessageComponent, selector: "fs-label-message" }], directives: [{ type: i8.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i8.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i9.CdkDropListGroup, selector: "[cdkDropListGroup]", inputs: ["cdkDropListGroupDisabled"], exportAs: ["cdkDropListGroup"] }, { type: i8.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i9.CdkDropList, selector: "[cdkDropList], cdk-drop-list", inputs: ["cdkDropListConnectedTo", "id", "cdkDropListEnterPredicate", "cdkDropListSortPredicate", "cdkDropListDisabled", "cdkDropListSortingDisabled", "cdkDropListAutoScrollDisabled", "cdkDropListOrientation", "cdkDropListLockAxis", "cdkDropListData", "cdkDropListAutoScrollStep"], outputs: ["cdkDropListDropped", "cdkDropListEntered", "cdkDropListExited", "cdkDropListSorted"], exportAs: ["cdkDropList"] }, { type: i2.MatChip, selector: "mat-basic-chip, [mat-basic-chip], mat-chip, [mat-chip]", inputs: ["color", "disableRipple", "tabIndex", "selected", "value", "selectable", "disabled", "removable"], outputs: ["selectionChange", "destroyed", "removed"], exportAs: ["matChip"] }, { type: i9.CdkDrag, selector: "[cdkDrag]", inputs: ["cdkDragDisabled", "cdkDragStartDelay", "cdkDragLockAxis", "cdkDragConstrainPosition", "cdkDragPreviewClass", "cdkDragBoundary", "cdkDragRootElement", "cdkDragPreviewContainer", "cdkDragData", "cdkDragFreeDragPosition"], outputs: ["cdkDragStarted", "cdkDragReleased", "cdkDragEnded", "cdkDragEntered", "cdkDragExited", "cdkDragDropped", "cdkDragMoved"], exportAs: ["cdkDrag"] }, { type: i9.CdkDragHandle, selector: "[cdkDragHandle]", inputs: ["cdkDragHandleDisabled"] }, { type: i8.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }, { type: i4.MatAutocompleteTrigger, selector: "input[matAutocomplete], textarea[matAutocomplete]", exportAs: ["matAutocompleteTrigger"] }, { type: i2.MatChipInput, selector: "input[matChipInputFor]", inputs: ["matChipInputSeparatorKeyCodes", "placeholder", "id", "matChipInputFor", "matChipInputAddOnBlur", "disabled"], outputs: ["matChipInputTokenEnd"], exportAs: ["matChipInput", "matChipInputFor"] }, { type: i1.MatSuffix, selector: "[matSuffix]" }, { type: i1.MatHint, selector: "mat-hint", inputs: ["align", "id"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsAutocompleteChipsComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'fs-autocomplete-chips',
                    templateUrl: './autocomplete-chips.component.html',
                    styleUrls: ['./autocomplete-chips.component.scss'],
                    providers: [{
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(() => FsAutocompleteChipsComponent),
                            multi: true
                        }],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }]; }, propDecorators: { fetch: [{
                type: Input
            }], readonly: [{
                type: Input
            }], size: [{
                type: Input
            }], placeholder: [{
                type: Input
            }], chipImage: [{
                type: Input
            }], chipBackground: [{
                type: Input
            }], chipColor: [{
                type: Input
            }], chipIcon: [{
                type: Input
            }], chipIconColor: [{
                type: Input
            }], chipClass: [{
                type: Input
            }], hint: [{
                type: Input
            }], allowText: [{
                type: Input
            }], allowObject: [{
                type: Input
            }], delay: [{
                type: Input
            }], validateText: [{
                type: Input
            }], invalidTextMessage: [{
                type: Input
            }], removable: [{
                type: Input
            }], allowClear: [{
                type: Input
            }], color: [{
                type: Input
            }], background: [{
                type: Input
            }], orderable: [{
                type: Input
            }], limit: [{
                type: Input
            }], initOnClick: [{
                type: Input
            }], fetchOnFocus: [{
                type: Input
            }], multiple: [{
                type: Input
            }], panelClass: [{
                type: Input
            }], compareWith: [{
                type: Input
            }], setDisabled: [{
                type: Input,
                args: ['disabled']
            }], panelWidth: [{
                type: Input
            }], selected: [{
                type: Output
            }], removed: [{
                type: Output
            }], reordered: [{
                type: Output
            }], clearEvent: [{
                type: Output,
                args: ['clear']
            }], formWrapper: [{
                type: HostBinding,
                args: ['class.fs-form-wrapper']
            }], dragStart: [{
                type: HostListener,
                args: ['dragstart', ['$event']]
            }], input: [{
                type: ViewChild,
                args: ['input']
            }], dummyInput: [{
                type: ViewChild,
                args: ['dummyInput']
            }], autocompleteTriggers: [{
                type: ViewChildren,
                args: [MatAutocompleteTrigger]
            }], autocompleteTrigger: [{
                type: ViewChild,
                args: [MatAutocompleteTrigger]
            }], formField: [{
                type: ViewChild,
                args: [MatFormField, { read: ElementRef }]
            }], objectTemplate: [{
                type: ContentChild,
                args: [FsAutocompleteObjectDirective, { read: TemplateRef }]
            }], chipSuffixTemplate: [{
                type: ContentChild,
                args: [FsAutocompleteChipSuffixDirective, { read: TemplateRef }]
            }], chipsSuffixTemplate: [{
                type: ContentChild,
                args: [FsAutocompleteChipsSuffixDirective, { read: TemplateRef }]
            }], noResultsTemplate: [{
                type: ContentChild,
                args: [FsAutocompleteChipsNoResultsDirective, { read: TemplateRef, static: true }]
            }], staticTemplates: [{
                type: ContentChildren,
                args: [FsAutocompleteChipsStaticDirective, { read: TemplateRef }]
            }], staticDirectives: [{
                type: ContentChildren,
                args: [FsAutocompleteChipsStaticDirective]
            }] } });

class FsAutocompleteChipsModule {
    static forRoot() {
        return {
            ngModule: FsAutocompleteChipsModule,
        };
    }
}
FsAutocompleteChipsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsAutocompleteChipsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
FsAutocompleteChipsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsAutocompleteChipsModule, declarations: [FsAutocompleteObjectDirective,
        FsAutocompleteChipsComponent,
        FsAutocompleteChipsStaticDirective,
        FsAutocompleteChipsNoResultsDirective,
        FsAutocompleteChipSuffixDirective,
        FsAutocompleteChipsSuffixDirective], imports: [CommonModule,
        FormsModule,
        DragDropModule,
        MatAutocompleteModule,
        MatChipsModule,
        MatInputModule,
        MatIconModule,
        MatRadioModule,
        FsLabelModule], exports: [FsAutocompleteChipsComponent,
        FsAutocompleteObjectDirective,
        FsAutocompleteChipsStaticDirective,
        FsAutocompleteChipsNoResultsDirective,
        FsAutocompleteChipSuffixDirective,
        FsAutocompleteChipsSuffixDirective] });
FsAutocompleteChipsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsAutocompleteChipsModule, imports: [[
            CommonModule,
            FormsModule,
            DragDropModule,
            MatAutocompleteModule,
            MatChipsModule,
            MatInputModule,
            MatIconModule,
            MatRadioModule,
            FsLabelModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsAutocompleteChipsModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        FormsModule,
                        DragDropModule,
                        MatAutocompleteModule,
                        MatChipsModule,
                        MatInputModule,
                        MatIconModule,
                        MatRadioModule,
                        FsLabelModule,
                    ],
                    exports: [
                        FsAutocompleteChipsComponent,
                        FsAutocompleteObjectDirective,
                        FsAutocompleteChipsStaticDirective,
                        FsAutocompleteChipsNoResultsDirective,
                        FsAutocompleteChipSuffixDirective,
                        FsAutocompleteChipsSuffixDirective,
                    ],
                    declarations: [
                        FsAutocompleteObjectDirective,
                        FsAutocompleteChipsComponent,
                        FsAutocompleteChipsStaticDirective,
                        FsAutocompleteChipsNoResultsDirective,
                        FsAutocompleteChipSuffixDirective,
                        FsAutocompleteChipsSuffixDirective,
                    ],
                }]
        }] });

/*
 * Public API Surface of fs-menu
 */

/**
 * Generated bundle index. Do not edit.
 */

export { FsAutocompleteChipSuffixDirective, FsAutocompleteChipsComponent, FsAutocompleteChipsModule, FsAutocompleteChipsNoResultsDirective, FsAutocompleteChipsStaticDirective, FsAutocompleteChipsSuffixDirective, FsAutocompleteObjectDirective };
//# sourceMappingURL=firestitch-autocomplete-chips.js.map
