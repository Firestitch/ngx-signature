import * as i0 from '@angular/core';
import { Directive, EventEmitter, Input, Output, forwardRef, TemplateRef, Component, ChangeDetectionStrategy, ViewChild, ContentChild, ContentChildren, HostBinding, NgModule } from '@angular/core';
import * as i7 from '@angular/common';
import { CommonModule } from '@angular/common';
import * as i6 from '@angular/forms';
import { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';
import * as i3 from '@angular/material/autocomplete';
import { MatAutocompleteTrigger, MatAutocompleteModule } from '@angular/material/autocomplete';
import { MatChipsModule } from '@angular/material/chips';
import * as i2 from '@angular/material/icon';
import { MatIconModule } from '@angular/material/icon';
import * as i5 from '@angular/material/input';
import { MatInputModule } from '@angular/material/input';
import { debounceTime, filter, switchMap, tap, takeUntil } from 'rxjs/operators';
import { Subject } from 'rxjs';
import { random, trim, isObject } from 'lodash-es';
import * as i1 from '@angular/material/form-field';
import * as i4 from '@angular/material/core';

class FsAutocompleteTemplateDirective {
}
FsAutocompleteTemplateDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsAutocompleteTemplateDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
FsAutocompleteTemplateDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: FsAutocompleteTemplateDirective, selector: "[fsAutocompleteTemplate]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsAutocompleteTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[fsAutocompleteTemplate]'
                }]
        }] });

class FsAutocompleteSuffixDirective {
}
FsAutocompleteSuffixDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsAutocompleteSuffixDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
FsAutocompleteSuffixDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: FsAutocompleteSuffixDirective, selector: "[fsAutocompleteSuffix]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsAutocompleteSuffixDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[fsAutocompleteSuffix]'
                }]
        }] });

class FsAutocompleteStaticDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
        this.showWhenKeyword = false;
        this.selected = new EventEmitter();
    }
}
FsAutocompleteStaticDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsAutocompleteStaticDirective, deps: [{ token: i0.TemplateRef }], target: i0.ɵɵFactoryTarget.Directive });
FsAutocompleteStaticDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: FsAutocompleteStaticDirective, selector: "[fsAutocompleteStatic],[fsAutocompleteStaticTemplate]", inputs: { showWhenKeyword: "showWhenKeyword" }, outputs: { selected: "selected" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsAutocompleteStaticDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[fsAutocompleteStatic],[fsAutocompleteStaticTemplate]'
                }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef }]; }, propDecorators: { showWhenKeyword: [{
                type: Input
            }], selected: [{
                type: Output
            }] } });

class FsAutocompleteNoResultsDirective {
}
FsAutocompleteNoResultsDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsAutocompleteNoResultsDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
FsAutocompleteNoResultsDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: FsAutocompleteNoResultsDirective, selector: "[fsAutocompleteNoResults]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsAutocompleteNoResultsDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[fsAutocompleteNoResults]'
                }]
        }] });

class FsAutocompleteHintDirective {
}
FsAutocompleteHintDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsAutocompleteHintDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
FsAutocompleteHintDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: FsAutocompleteHintDirective, selector: "[fsAutocompleteHint]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsAutocompleteHintDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[fsAutocompleteHint]'
                }]
        }] });

class FsAutocompleteComponent {
    constructor(_cdRef) {
        this._cdRef = _cdRef;
        this.template = null;
        this.staticTemplates = null;
        this.noResultsTemplate = null;
        this.suffix = null;
        this.hintTemplate = null;
        this.formWrapper = true;
        this.fetch = null;
        this.placeholder = '';
        this.displayWith = null;
        this.fetchOnFocus = false;
        this.readonly = false;
        this.required = false;
        this.disabled = false;
        this.hint = null;
        this.panelWidth = null;
        this.cleared = new EventEmitter();
        this.data = [];
        this.keyword = '';
        this.panelClasses = ['fs-autocomplete-panel'];
        this.noResults = false;
        this.name = 'autocomplete_'.concat(random(1, 9999999));
        this.model = null;
        this.searching = false;
        this._showClear = true;
        this._destroy$ = new Subject();
        this._keyword$ = new Subject();
        this._ignoreKeys = [
            'Enter', 'Escape', 'ArrowUp', 'ArrowLeft', 'ArrowRight',
            'ArrowDown', 'Alt', 'Control', 'Shift',
        ];
        this._onTouched = () => { };
        this._onChange = (value) => { };
        this.display = (data) => {
            if (data && this.displayWith) {
                return this.displayWith(data);
            }
            return '';
        };
    }
    set setPanelClass(value) {
        this.panelClasses.push(value);
    }
    set showClear(value) {
        this._showClear = value;
        this._cdRef.detectChanges();
    }
    get showClear() {
        return this._showClear;
    }
    registerOnChange(fn) { this._onChange = fn; }
    registerOnTouched(fn) { this._onTouched = fn; }
    ngOnInit() {
        // Because the input display is set natively the delay
        // ensure its set after this.keyword
        setTimeout(() => {
            this._updateKeywordDisplay();
        });
        // _setValueAndClose() override to change the order of focus() and _onChange()
        const autocompleteTrigger = this.autocomplete;
        autocompleteTrigger._setValueAndClose = (event) => {
            if (event && event.source) {
                if (event.source.value.staticOptionIndex === undefined) {
                    autocompleteTrigger._clearPreviousSelectedOption(event.source);
                    autocompleteTrigger._setTriggerValue(event.source.value);
                    autocompleteTrigger._onChange(event.source.value);
                }
                autocompleteTrigger.autocomplete._emitSelectEvent(event.source);
            }
            autocompleteTrigger.closePanel();
        };
        this._keyword$
            .pipe(debounceTime(150), filter((event) => {
            return !event || this._ignoreKeys.indexOf(event.key) === -1;
        }), switchMap((event) => {
            this.data = [];
            this.searching = true;
            this._cdRef.markForCheck();
            return this.fetch(trim(event.target.value))
                .pipe(tap((response) => {
                this.data = response;
                this.noResults = !response.length;
                this._cdRef.markForCheck();
                this.autocomplete.openPanel();
                this.searching = false;
            }), takeUntil(this._destroy$));
        }), takeUntil(this._destroy$))
            .subscribe(() => {
            this._onTouched();
        });
    }
    load() {
        this.searching = true;
        this._keyword$.next({ target: { value: this._getKeyword() } });
    }
    focus() {
        this.keywordInput.nativeElement.focus();
    }
    inputFocus(e) {
        if (this.readonly || this.disabled) {
            return;
        }
        if (this.fetchOnFocus) {
            if (!this.model) {
                this.load();
            }
        }
    }
    inputBlur() {
        if (this.readonly || this.disabled) {
            return;
        }
        setTimeout(() => {
            if (!this.model) {
                this.clearKeyword();
            }
            this._updateKeywordDisplay();
            this.clearResults();
        }, 200);
    }
    select(value) {
        if (isObject(value) && value.staticOptionIndex !== undefined) {
            this.staticSelect(value.staticOptionIndex);
        }
        else {
            this.model = value;
            this.data = [];
            this._updateKeywordDisplay();
            this._onChange(value);
        }
        this.clearResults();
    }
    optionSelected(event) {
        this.select(event.option.value);
        this.autocomplete.closePanel();
    }
    close() {
        this.autocomplete.closePanel();
    }
    writeValue(value) {
        this.model = value;
        this._updateKeywordDisplay();
    }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    input(event) {
        if (this.readonly || this.disabled) {
            return;
        }
        if (!event.target.value.length) {
            return this.clear();
        }
        this._keyword$.next(event);
    }
    keyDown(event) {
        if (this.readonly || this.disabled) {
            return;
        }
        if (event.code === 'Tab') {
            if (!this.model && this.autocomplete.activeOption) {
                this.keyword = 'dummy';
                this.select(this.autocomplete.activeOption.value);
            }
        }
        else if (event.code === 'Backspace') {
            if (this.model) {
                this.model = null;
                this.clearKeyword();
            }
        }
        else if (!this._isWindows() && !this._isMacOS()) {
            if (this._ignoreKeys.indexOf(event.key) === -1) {
                this.searching = true;
                this.data = [];
                if (this.model) {
                    this.clear();
                }
            }
        }
    }
    keyUp(event) {
        if (this.readonly || this.disabled) {
            return;
        }
        if (event.code === 'Backspace' && !event.target.value.length) {
            this.clear();
            this.load();
        }
    }
    staticSelect(index) {
        if (!this.model) {
            this.keywordNgModel.reset();
        }
        const staticDirective = this.staticDirectives.toArray()[index];
        staticDirective.selected.emit();
    }
    ngOnDestroy() {
        this._destroy$.next();
        this._destroy$.complete();
    }
    clearResults(closePanel = true) {
        this.data = [];
        this.noResults = false;
        if (closePanel) {
            this.autocomplete.closePanel();
        }
    }
    clear(closePanel = true) {
        this.model = null;
        this.clearResults(closePanel);
        this.clearKeyword();
        this._onChange(null);
    }
    clearKeyword() {
        this.keyword = null;
        this._updateKeywordDisplay();
    }
    clearClick(event) {
        event.stopPropagation();
        this.clear(false);
        this.keywordInput.nativeElement.focus();
        this.cleared.emit();
    }
    _updateKeywordDisplay() {
        const value = this.model ? this.display(this.model) : '';
        this.keyword = this.model;
        this.keywordInput.nativeElement.value = value;
        this._cdRef.markForCheck();
    }
    _getKeyword() {
        return this.keywordInput.nativeElement.value;
    }
    _isMacOS() {
        return navigator.platform.indexOf('Mac') > -1;
    }
    _isWindows() {
        return navigator.platform.indexOf('Win') > -1;
    }
}
FsAutocompleteComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsAutocompleteComponent, deps: [{ token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
FsAutocompleteComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: FsAutocompleteComponent, selector: "fs-autocomplete", inputs: { fetch: "fetch", placeholder: "placeholder", displayWith: "displayWith", fetchOnFocus: "fetchOnFocus", readonly: "readonly", required: "required", disabled: "disabled", hint: "hint", panelWidth: "panelWidth", setPanelClass: ["panelClass", "setPanelClass"], showClear: "showClear" }, outputs: { cleared: "cleared" }, host: { properties: { "class.fs-form-wrapper": "this.formWrapper" } }, providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: forwardRef(() => FsAutocompleteComponent),
            multi: true
        }
    ], queries: [{ propertyName: "template", first: true, predicate: FsAutocompleteTemplateDirective, descendants: true, read: TemplateRef, static: true }, { propertyName: "noResultsTemplate", first: true, predicate: FsAutocompleteNoResultsDirective, descendants: true, read: TemplateRef, static: true }, { propertyName: "suffix", first: true, predicate: FsAutocompleteSuffixDirective, descendants: true, read: TemplateRef, static: true }, { propertyName: "hintTemplate", first: true, predicate: FsAutocompleteHintDirective, descendants: true, read: TemplateRef, static: true }, { propertyName: "staticTemplates", predicate: FsAutocompleteStaticDirective }, { propertyName: "staticDirectives", predicate: FsAutocompleteStaticDirective }], viewQueries: [{ propertyName: "autocomplete", first: true, predicate: MatAutocompleteTrigger, descendants: true, static: true }, { propertyName: "keywordInput", first: true, predicate: ["keywordInput"], descendants: true, static: true }, { propertyName: "keywordNgModel", first: true, predicate: ["keywordNgModel"], descendants: true, static: true }], ngImport: i0, template: "<mat-form-field>\n  <mat-label [attr.data-after-content]=\"placeholder\"></mat-label>\n  <input\n    #keywordInput\n    #keywordNgModel=\"ngModel\"\n    matInput\n    type=\"search\"\n    [(ngModel)]=\"keyword\"\n    [name]=\"name\"\n    [disabled]=\"disabled\"\n    [readonly]=\"readonly\"\n    [required]=\"required\"\n    (focus)=\"inputFocus($event)\"\n    (blur)=\"inputBlur()\"\n    (input)=\"input($event)\"\n    (keydown)=\"keyDown($event)\"\n    (keyup)=\"keyUp($event)\"\n    [matAutocomplete]=\"userAutocompleteInput\">\n\n  <div *ngIf=\"!disabled\" matSuffix>\n    <ng-container\n      [ngTemplateOutlet]=\"suffix\"\n      [ngTemplateOutletContext]=\"{ data: model }\">\n    </ng-container>\n\n    <mat-icon\n      *ngIf=\"showClear && model\"\n      class=\"clear\"\n      (click)=\"clearClick($event)\">clear</mat-icon>\n  </div>\n\n  <mat-autocomplete\n    #userAutocompleteInput=\"matAutocomplete\"\n    [autoActiveFirstOption]=\"true\"\n    [panelWidth]=\"panelWidth\"\n    [class]=\"panelClasses.join(' ')\"\n    [displayWith]=\"display\"\n    (optionSelected)=\"optionSelected($event)\">\n\n    <mat-option *ngFor=\"let item of data\" [value]=\"item\">\n      <ng-container\n        [ngTemplateOutlet]=\"template\"\n        [ngTemplateOutletContext]=\"{ data: item }\">\n      </ng-container>\n    </mat-option>\n\n    <ng-container *ngIf=\"!searching\">\n      <ng-container *ngIf=\"noResults\">\n        <ng-template\n          *ngIf=\"noResultsTemplate; else noResultsOption\"\n          [ngTemplateOutlet]=\"noResultsTemplate\"\n          [ngTemplateOutletContext]=\"{ $implicit: keyword }\">\n        </ng-template>\n        <ng-template #noResultsOption>\n          <mat-option disabled class=\"no-results\">\n            No results <ng-container *ngIf=\"keyword\">for \"{{keyword}}\"</ng-container>\n          </mat-option>\n        </ng-template>\n      </ng-container>\n\n      <ng-container *ngIf=\"!model && (!searching || keyword) && staticTemplates?.length\">\n        <div class=\"static-templates\">\n          <ng-container *ngFor=\"let staticTemplate of staticTemplates; let i = index\">\n            <ng-container *ngIf=\"!staticTemplate.showWhenKeyword || !!keyword\">\n              <mat-option\n                class=\"static-option\"\n                [value]=\"{ staticOptionIndex: i }\"\n                [ngClass]=\"{ 'static-option-first': !i }\">\n                <ng-template\n                  [ngTemplateOutlet]=\"staticTemplate.templateRef\"\n                  [ngTemplateOutletContext]=\"{ $implicit: keyword }\"\n                ></ng-template>\n              </mat-option>\n            </ng-container>\n          </ng-container>\n        </div>\n      </ng-container>\n    </ng-container>\n  </mat-autocomplete>\n\n  <mat-hint *ngIf=\"hint\">{{ hint }}</mat-hint>\n  <mat-hint *ngIf=\"hintTemplate\">\n    <ng-container\n      [ngTemplateOutlet]=\"hintTemplate\">\n    </ng-container>\n  </mat-hint>\n</mat-form-field>\n", styles: ["::ng-deep .fs-autocomplete-panel .static-templates{position:sticky;bottom:0;width:100%;background:#fff;border-top:1px solid #e0e0e0}::ng-deep .fs-autocomplete-panel.mat-autocomplete-hidden{visibility:visible!important}.mat-form-field{width:100%}.clear{cursor:pointer}mat-label:after{content:attr(data-after-content)}:host ::ng-deep .mat-form-field-suffix{align-self:flex-end}\n"], components: [{ type: i1.MatFormField, selector: "mat-form-field", inputs: ["color", "floatLabel", "appearance", "hideRequiredMarker", "hintLabel"], exportAs: ["matFormField"] }, { type: i2.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { type: i3.MatAutocomplete, selector: "mat-autocomplete", inputs: ["disableRipple"], exportAs: ["matAutocomplete"] }, { type: i4.MatOption, selector: "mat-option", exportAs: ["matOption"] }], directives: [{ type: i1.MatLabel, selector: "mat-label" }, { type: i5.MatInput, selector: "input[matInput], textarea[matInput], select[matNativeControl],      input[matNativeControl], textarea[matNativeControl]", inputs: ["id", "disabled", "required", "type", "value", "readonly", "placeholder", "errorStateMatcher", "aria-describedby"], exportAs: ["matInput"] }, { type: i6.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { type: i3.MatAutocompleteTrigger, selector: "input[matAutocomplete], textarea[matAutocomplete]", exportAs: ["matAutocompleteTrigger"] }, { type: i6.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i6.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { type: i6.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }, { type: i7.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1.MatSuffix, selector: "[matSuffix]" }, { type: i7.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }, { type: i7.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i7.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i1.MatHint, selector: "mat-hint", inputs: ["align", "id"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsAutocompleteComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'fs-autocomplete',
                    templateUrl: 'autocomplete.component.html',
                    styleUrls: ['autocomplete.component.scss'],
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(() => FsAutocompleteComponent),
                            multi: true
                        }
                    ],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }]; }, propDecorators: { autocomplete: [{
                type: ViewChild,
                args: [MatAutocompleteTrigger, { static: true }]
            }], template: [{
                type: ContentChild,
                args: [FsAutocompleteTemplateDirective, { read: TemplateRef, static: true }]
            }], staticTemplates: [{
                type: ContentChildren,
                args: [FsAutocompleteStaticDirective]
            }], staticDirectives: [{
                type: ContentChildren,
                args: [FsAutocompleteStaticDirective]
            }], noResultsTemplate: [{
                type: ContentChild,
                args: [FsAutocompleteNoResultsDirective, { read: TemplateRef, static: true }]
            }], suffix: [{
                type: ContentChild,
                args: [FsAutocompleteSuffixDirective, { read: TemplateRef, static: true }]
            }], hintTemplate: [{
                type: ContentChild,
                args: [FsAutocompleteHintDirective, { read: TemplateRef, static: true }]
            }], formWrapper: [{
                type: HostBinding,
                args: ['class.fs-form-wrapper']
            }], keywordInput: [{
                type: ViewChild,
                args: ['keywordInput', { static: true }]
            }], keywordNgModel: [{
                type: ViewChild,
                args: ['keywordNgModel', { static: true }]
            }], fetch: [{
                type: Input
            }], placeholder: [{
                type: Input
            }], displayWith: [{
                type: Input
            }], fetchOnFocus: [{
                type: Input
            }], readonly: [{
                type: Input
            }], required: [{
                type: Input
            }], disabled: [{
                type: Input
            }], hint: [{
                type: Input
            }], panelWidth: [{
                type: Input
            }], setPanelClass: [{
                type: Input,
                args: ['panelClass']
            }], showClear: [{
                type: Input
            }], cleared: [{
                type: Output
            }] } });

class FsAutocompleteModule {
}
FsAutocompleteModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsAutocompleteModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
FsAutocompleteModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsAutocompleteModule, declarations: [FsAutocompleteComponent,
        FsAutocompleteTemplateDirective,
        FsAutocompleteSuffixDirective,
        FsAutocompleteStaticDirective,
        FsAutocompleteNoResultsDirective,
        FsAutocompleteHintDirective], imports: [CommonModule,
        FormsModule,
        MatAutocompleteModule,
        MatChipsModule,
        MatInputModule,
        MatIconModule], exports: [FsAutocompleteComponent,
        FsAutocompleteTemplateDirective,
        FsAutocompleteSuffixDirective,
        FsAutocompleteStaticDirective,
        FsAutocompleteNoResultsDirective,
        FsAutocompleteHintDirective] });
FsAutocompleteModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsAutocompleteModule, providers: [], imports: [[
            CommonModule,
            FormsModule,
            MatAutocompleteModule,
            MatChipsModule,
            MatInputModule,
            MatIconModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsAutocompleteModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        FormsModule,
                        MatAutocompleteModule,
                        MatChipsModule,
                        MatInputModule,
                        MatIconModule,
                    ],
                    exports: [
                        FsAutocompleteComponent,
                        FsAutocompleteTemplateDirective,
                        FsAutocompleteSuffixDirective,
                        FsAutocompleteStaticDirective,
                        FsAutocompleteNoResultsDirective,
                        FsAutocompleteHintDirective,
                    ],
                    declarations: [
                        FsAutocompleteComponent,
                        FsAutocompleteTemplateDirective,
                        FsAutocompleteSuffixDirective,
                        FsAutocompleteStaticDirective,
                        FsAutocompleteNoResultsDirective,
                        FsAutocompleteHintDirective,
                    ],
                    providers: [],
                }]
        }] });

/*
 * Public API Surface of ngx-autocomplete
 */

/**
 * Generated bundle index. Do not edit.
 */

export { FsAutocompleteComponent, FsAutocompleteHintDirective, FsAutocompleteModule, FsAutocompleteNoResultsDirective, FsAutocompleteStaticDirective, FsAutocompleteSuffixDirective, FsAutocompleteTemplateDirective };
//# sourceMappingURL=firestitch-autocomplete.js.map
