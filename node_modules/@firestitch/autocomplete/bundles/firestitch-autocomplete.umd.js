(function (global, factory) {
        typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('@angular/forms'), require('@angular/material/autocomplete'), require('@angular/material/chips'), require('@angular/material/icon'), require('@angular/material/input'), require('rxjs/operators'), require('rxjs'), require('lodash-es'), require('@angular/material/form-field'), require('@angular/material/core')) :
        typeof define === 'function' && define.amd ? define('@firestitch/autocomplete', ['exports', '@angular/core', '@angular/common', '@angular/forms', '@angular/material/autocomplete', '@angular/material/chips', '@angular/material/icon', '@angular/material/input', 'rxjs/operators', 'rxjs', 'lodash-es', '@angular/material/form-field', '@angular/material/core'], factory) :
        (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.firestitch = global.firestitch || {}, global.firestitch.autocomplete = {}), global.ng.core, global.ng.common, global.ng.forms, global.ng.material.autocomplete, global.ng.material.chips, global.ng.material.icon, global.ng.material.input, global.rxjs.operators, global.rxjs, global.lodashEs, global.ng.material.formField, global.ng.material.core));
})(this, (function (exports, i0, i7, i6, i3, chips, i2, i5, operators, rxjs, lodashEs, i1, i4) { 'use strict';

        function _interopNamespace(e) {
                if (e && e.__esModule) return e;
                var n = Object.create(null);
                if (e) {
                        Object.keys(e).forEach(function (k) {
                                if (k !== 'default') {
                                        var d = Object.getOwnPropertyDescriptor(e, k);
                                        Object.defineProperty(n, k, d.get ? d : {
                                                enumerable: true,
                                                get: function () { return e[k]; }
                                        });
                                }
                        });
                }
                n["default"] = e;
                return Object.freeze(n);
        }

        var i0__namespace = /*#__PURE__*/_interopNamespace(i0);
        var i7__namespace = /*#__PURE__*/_interopNamespace(i7);
        var i6__namespace = /*#__PURE__*/_interopNamespace(i6);
        var i3__namespace = /*#__PURE__*/_interopNamespace(i3);
        var i2__namespace = /*#__PURE__*/_interopNamespace(i2);
        var i5__namespace = /*#__PURE__*/_interopNamespace(i5);
        var i1__namespace = /*#__PURE__*/_interopNamespace(i1);
        var i4__namespace = /*#__PURE__*/_interopNamespace(i4);

        var FsAutocompleteTemplateDirective = /** @class */ (function () {
            function FsAutocompleteTemplateDirective() {
            }
            return FsAutocompleteTemplateDirective;
        }());
        FsAutocompleteTemplateDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsAutocompleteTemplateDirective, deps: [], target: i0__namespace.ɵɵFactoryTarget.Directive });
        FsAutocompleteTemplateDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: FsAutocompleteTemplateDirective, selector: "[fsAutocompleteTemplate]", ngImport: i0__namespace });
        i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsAutocompleteTemplateDirective, decorators: [{
                    type: i0.Directive,
                    args: [{
                            selector: '[fsAutocompleteTemplate]'
                        }]
                }] });

        var FsAutocompleteSuffixDirective = /** @class */ (function () {
            function FsAutocompleteSuffixDirective() {
            }
            return FsAutocompleteSuffixDirective;
        }());
        FsAutocompleteSuffixDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsAutocompleteSuffixDirective, deps: [], target: i0__namespace.ɵɵFactoryTarget.Directive });
        FsAutocompleteSuffixDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: FsAutocompleteSuffixDirective, selector: "[fsAutocompleteSuffix]", ngImport: i0__namespace });
        i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsAutocompleteSuffixDirective, decorators: [{
                    type: i0.Directive,
                    args: [{
                            selector: '[fsAutocompleteSuffix]'
                        }]
                }] });

        var FsAutocompleteStaticDirective = /** @class */ (function () {
            function FsAutocompleteStaticDirective(templateRef) {
                this.templateRef = templateRef;
                this.showWhenKeyword = false;
                this.selected = new i0.EventEmitter();
            }
            return FsAutocompleteStaticDirective;
        }());
        FsAutocompleteStaticDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsAutocompleteStaticDirective, deps: [{ token: i0__namespace.TemplateRef }], target: i0__namespace.ɵɵFactoryTarget.Directive });
        FsAutocompleteStaticDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: FsAutocompleteStaticDirective, selector: "[fsAutocompleteStatic],[fsAutocompleteStaticTemplate]", inputs: { showWhenKeyword: "showWhenKeyword" }, outputs: { selected: "selected" }, ngImport: i0__namespace });
        i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsAutocompleteStaticDirective, decorators: [{
                    type: i0.Directive,
                    args: [{
                            selector: '[fsAutocompleteStatic],[fsAutocompleteStaticTemplate]'
                        }]
                }], ctorParameters: function () { return [{ type: i0__namespace.TemplateRef }]; }, propDecorators: { showWhenKeyword: [{
                        type: i0.Input
                    }], selected: [{
                        type: i0.Output
                    }] } });

        var FsAutocompleteNoResultsDirective = /** @class */ (function () {
            function FsAutocompleteNoResultsDirective() {
            }
            return FsAutocompleteNoResultsDirective;
        }());
        FsAutocompleteNoResultsDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsAutocompleteNoResultsDirective, deps: [], target: i0__namespace.ɵɵFactoryTarget.Directive });
        FsAutocompleteNoResultsDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: FsAutocompleteNoResultsDirective, selector: "[fsAutocompleteNoResults]", ngImport: i0__namespace });
        i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsAutocompleteNoResultsDirective, decorators: [{
                    type: i0.Directive,
                    args: [{
                            selector: '[fsAutocompleteNoResults]'
                        }]
                }] });

        var FsAutocompleteHintDirective = /** @class */ (function () {
            function FsAutocompleteHintDirective() {
            }
            return FsAutocompleteHintDirective;
        }());
        FsAutocompleteHintDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsAutocompleteHintDirective, deps: [], target: i0__namespace.ɵɵFactoryTarget.Directive });
        FsAutocompleteHintDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: FsAutocompleteHintDirective, selector: "[fsAutocompleteHint]", ngImport: i0__namespace });
        i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsAutocompleteHintDirective, decorators: [{
                    type: i0.Directive,
                    args: [{
                            selector: '[fsAutocompleteHint]'
                        }]
                }] });

        var FsAutocompleteComponent = /** @class */ (function () {
            function FsAutocompleteComponent(_cdRef) {
                var _this = this;
                this._cdRef = _cdRef;
                this.template = null;
                this.staticTemplates = null;
                this.noResultsTemplate = null;
                this.suffix = null;
                this.hintTemplate = null;
                this.formWrapper = true;
                this.fetch = null;
                this.placeholder = '';
                this.displayWith = null;
                this.fetchOnFocus = false;
                this.readonly = false;
                this.required = false;
                this.disabled = false;
                this.hint = null;
                this.panelWidth = null;
                this.cleared = new i0.EventEmitter();
                this.data = [];
                this.keyword = '';
                this.panelClasses = ['fs-autocomplete-panel'];
                this.noResults = false;
                this.name = 'autocomplete_'.concat(lodashEs.random(1, 9999999));
                this.model = null;
                this.searching = false;
                this._showClear = true;
                this._destroy$ = new rxjs.Subject();
                this._keyword$ = new rxjs.Subject();
                this._ignoreKeys = [
                    'Enter', 'Escape', 'ArrowUp', 'ArrowLeft', 'ArrowRight',
                    'ArrowDown', 'Alt', 'Control', 'Shift',
                ];
                this._onTouched = function () { };
                this._onChange = function (value) { };
                this.display = function (data) {
                    if (data && _this.displayWith) {
                        return _this.displayWith(data);
                    }
                    return '';
                };
            }
            Object.defineProperty(FsAutocompleteComponent.prototype, "setPanelClass", {
                set: function (value) {
                    this.panelClasses.push(value);
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(FsAutocompleteComponent.prototype, "showClear", {
                get: function () {
                    return this._showClear;
                },
                set: function (value) {
                    this._showClear = value;
                    this._cdRef.detectChanges();
                },
                enumerable: false,
                configurable: true
            });
            FsAutocompleteComponent.prototype.registerOnChange = function (fn) { this._onChange = fn; };
            FsAutocompleteComponent.prototype.registerOnTouched = function (fn) { this._onTouched = fn; };
            FsAutocompleteComponent.prototype.ngOnInit = function () {
                var _this = this;
                // Because the input display is set natively the delay
                // ensure its set after this.keyword
                setTimeout(function () {
                    _this._updateKeywordDisplay();
                });
                // _setValueAndClose() override to change the order of focus() and _onChange()
                var autocompleteTrigger = this.autocomplete;
                autocompleteTrigger._setValueAndClose = function (event) {
                    if (event && event.source) {
                        if (event.source.value.staticOptionIndex === undefined) {
                            autocompleteTrigger._clearPreviousSelectedOption(event.source);
                            autocompleteTrigger._setTriggerValue(event.source.value);
                            autocompleteTrigger._onChange(event.source.value);
                        }
                        autocompleteTrigger.autocomplete._emitSelectEvent(event.source);
                    }
                    autocompleteTrigger.closePanel();
                };
                this._keyword$
                    .pipe(operators.debounceTime(150), operators.filter(function (event) {
                    return !event || _this._ignoreKeys.indexOf(event.key) === -1;
                }), operators.switchMap(function (event) {
                    _this.data = [];
                    _this.searching = true;
                    _this._cdRef.markForCheck();
                    return _this.fetch(lodashEs.trim(event.target.value))
                        .pipe(operators.tap(function (response) {
                        _this.data = response;
                        _this.noResults = !response.length;
                        _this._cdRef.markForCheck();
                        _this.autocomplete.openPanel();
                        _this.searching = false;
                    }), operators.takeUntil(_this._destroy$));
                }), operators.takeUntil(this._destroy$))
                    .subscribe(function () {
                    _this._onTouched();
                });
            };
            FsAutocompleteComponent.prototype.load = function () {
                this.searching = true;
                this._keyword$.next({ target: { value: this._getKeyword() } });
            };
            FsAutocompleteComponent.prototype.focus = function () {
                this.keywordInput.nativeElement.focus();
            };
            FsAutocompleteComponent.prototype.inputFocus = function (e) {
                if (this.readonly || this.disabled) {
                    return;
                }
                if (this.fetchOnFocus) {
                    if (!this.model) {
                        this.load();
                    }
                }
            };
            FsAutocompleteComponent.prototype.inputBlur = function () {
                var _this = this;
                if (this.readonly || this.disabled) {
                    return;
                }
                setTimeout(function () {
                    if (!_this.model) {
                        _this.clearKeyword();
                    }
                    _this._updateKeywordDisplay();
                    _this.clearResults();
                }, 200);
            };
            FsAutocompleteComponent.prototype.select = function (value) {
                if (lodashEs.isObject(value) && value.staticOptionIndex !== undefined) {
                    this.staticSelect(value.staticOptionIndex);
                }
                else {
                    this.model = value;
                    this.data = [];
                    this._updateKeywordDisplay();
                    this._onChange(value);
                }
                this.clearResults();
            };
            FsAutocompleteComponent.prototype.optionSelected = function (event) {
                this.select(event.option.value);
                this.autocomplete.closePanel();
            };
            FsAutocompleteComponent.prototype.close = function () {
                this.autocomplete.closePanel();
            };
            FsAutocompleteComponent.prototype.writeValue = function (value) {
                this.model = value;
                this._updateKeywordDisplay();
            };
            FsAutocompleteComponent.prototype.setDisabledState = function (isDisabled) {
                this.disabled = isDisabled;
            };
            FsAutocompleteComponent.prototype.input = function (event) {
                if (this.readonly || this.disabled) {
                    return;
                }
                if (!event.target.value.length) {
                    return this.clear();
                }
                this._keyword$.next(event);
            };
            FsAutocompleteComponent.prototype.keyDown = function (event) {
                if (this.readonly || this.disabled) {
                    return;
                }
                if (event.code === 'Tab') {
                    if (!this.model && this.autocomplete.activeOption) {
                        this.keyword = 'dummy';
                        this.select(this.autocomplete.activeOption.value);
                    }
                }
                else if (event.code === 'Backspace') {
                    if (this.model) {
                        this.model = null;
                        this.clearKeyword();
                    }
                }
                else if (!this._isWindows() && !this._isMacOS()) {
                    if (this._ignoreKeys.indexOf(event.key) === -1) {
                        this.searching = true;
                        this.data = [];
                        if (this.model) {
                            this.clear();
                        }
                    }
                }
            };
            FsAutocompleteComponent.prototype.keyUp = function (event) {
                if (this.readonly || this.disabled) {
                    return;
                }
                if (event.code === 'Backspace' && !event.target.value.length) {
                    this.clear();
                    this.load();
                }
            };
            FsAutocompleteComponent.prototype.staticSelect = function (index) {
                if (!this.model) {
                    this.keywordNgModel.reset();
                }
                var staticDirective = this.staticDirectives.toArray()[index];
                staticDirective.selected.emit();
            };
            FsAutocompleteComponent.prototype.ngOnDestroy = function () {
                this._destroy$.next();
                this._destroy$.complete();
            };
            FsAutocompleteComponent.prototype.clearResults = function (closePanel) {
                if (closePanel === void 0) { closePanel = true; }
                this.data = [];
                this.noResults = false;
                if (closePanel) {
                    this.autocomplete.closePanel();
                }
            };
            FsAutocompleteComponent.prototype.clear = function (closePanel) {
                if (closePanel === void 0) { closePanel = true; }
                this.model = null;
                this.clearResults(closePanel);
                this.clearKeyword();
                this._onChange(null);
            };
            FsAutocompleteComponent.prototype.clearKeyword = function () {
                this.keyword = null;
                this._updateKeywordDisplay();
            };
            FsAutocompleteComponent.prototype.clearClick = function (event) {
                event.stopPropagation();
                this.clear(false);
                this.keywordInput.nativeElement.focus();
                this.cleared.emit();
            };
            FsAutocompleteComponent.prototype._updateKeywordDisplay = function () {
                var value = this.model ? this.display(this.model) : '';
                this.keyword = this.model;
                this.keywordInput.nativeElement.value = value;
                this._cdRef.markForCheck();
            };
            FsAutocompleteComponent.prototype._getKeyword = function () {
                return this.keywordInput.nativeElement.value;
            };
            FsAutocompleteComponent.prototype._isMacOS = function () {
                return navigator.platform.indexOf('Mac') > -1;
            };
            FsAutocompleteComponent.prototype._isWindows = function () {
                return navigator.platform.indexOf('Win') > -1;
            };
            return FsAutocompleteComponent;
        }());
        FsAutocompleteComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsAutocompleteComponent, deps: [{ token: i0__namespace.ChangeDetectorRef }], target: i0__namespace.ɵɵFactoryTarget.Component });
        FsAutocompleteComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: FsAutocompleteComponent, selector: "fs-autocomplete", inputs: { fetch: "fetch", placeholder: "placeholder", displayWith: "displayWith", fetchOnFocus: "fetchOnFocus", readonly: "readonly", required: "required", disabled: "disabled", hint: "hint", panelWidth: "panelWidth", setPanelClass: ["panelClass", "setPanelClass"], showClear: "showClear" }, outputs: { cleared: "cleared" }, host: { properties: { "class.fs-form-wrapper": "this.formWrapper" } }, providers: [
                {
                    provide: i6.NG_VALUE_ACCESSOR,
                    useExisting: i0.forwardRef(function () { return FsAutocompleteComponent; }),
                    multi: true
                }
            ], queries: [{ propertyName: "template", first: true, predicate: FsAutocompleteTemplateDirective, descendants: true, read: i0.TemplateRef, static: true }, { propertyName: "noResultsTemplate", first: true, predicate: FsAutocompleteNoResultsDirective, descendants: true, read: i0.TemplateRef, static: true }, { propertyName: "suffix", first: true, predicate: FsAutocompleteSuffixDirective, descendants: true, read: i0.TemplateRef, static: true }, { propertyName: "hintTemplate", first: true, predicate: FsAutocompleteHintDirective, descendants: true, read: i0.TemplateRef, static: true }, { propertyName: "staticTemplates", predicate: FsAutocompleteStaticDirective }, { propertyName: "staticDirectives", predicate: FsAutocompleteStaticDirective }], viewQueries: [{ propertyName: "autocomplete", first: true, predicate: i3.MatAutocompleteTrigger, descendants: true, static: true }, { propertyName: "keywordInput", first: true, predicate: ["keywordInput"], descendants: true, static: true }, { propertyName: "keywordNgModel", first: true, predicate: ["keywordNgModel"], descendants: true, static: true }], ngImport: i0__namespace, template: "<mat-form-field>\n  <mat-label [attr.data-after-content]=\"placeholder\"></mat-label>\n  <input\n    #keywordInput\n    #keywordNgModel=\"ngModel\"\n    matInput\n    type=\"search\"\n    [(ngModel)]=\"keyword\"\n    [name]=\"name\"\n    [disabled]=\"disabled\"\n    [readonly]=\"readonly\"\n    [required]=\"required\"\n    (focus)=\"inputFocus($event)\"\n    (blur)=\"inputBlur()\"\n    (input)=\"input($event)\"\n    (keydown)=\"keyDown($event)\"\n    (keyup)=\"keyUp($event)\"\n    [matAutocomplete]=\"userAutocompleteInput\">\n\n  <div *ngIf=\"!disabled\" matSuffix>\n    <ng-container\n      [ngTemplateOutlet]=\"suffix\"\n      [ngTemplateOutletContext]=\"{ data: model }\">\n    </ng-container>\n\n    <mat-icon\n      *ngIf=\"showClear && model\"\n      class=\"clear\"\n      (click)=\"clearClick($event)\">clear</mat-icon>\n  </div>\n\n  <mat-autocomplete\n    #userAutocompleteInput=\"matAutocomplete\"\n    [autoActiveFirstOption]=\"true\"\n    [panelWidth]=\"panelWidth\"\n    [class]=\"panelClasses.join(' ')\"\n    [displayWith]=\"display\"\n    (optionSelected)=\"optionSelected($event)\">\n\n    <mat-option *ngFor=\"let item of data\" [value]=\"item\">\n      <ng-container\n        [ngTemplateOutlet]=\"template\"\n        [ngTemplateOutletContext]=\"{ data: item }\">\n      </ng-container>\n    </mat-option>\n\n    <ng-container *ngIf=\"!searching\">\n      <ng-container *ngIf=\"noResults\">\n        <ng-template\n          *ngIf=\"noResultsTemplate; else noResultsOption\"\n          [ngTemplateOutlet]=\"noResultsTemplate\"\n          [ngTemplateOutletContext]=\"{ $implicit: keyword }\">\n        </ng-template>\n        <ng-template #noResultsOption>\n          <mat-option disabled class=\"no-results\">\n            No results <ng-container *ngIf=\"keyword\">for \"{{keyword}}\"</ng-container>\n          </mat-option>\n        </ng-template>\n      </ng-container>\n\n      <ng-container *ngIf=\"!model && (!searching || keyword) && staticTemplates?.length\">\n        <div class=\"static-templates\">\n          <ng-container *ngFor=\"let staticTemplate of staticTemplates; let i = index\">\n            <ng-container *ngIf=\"!staticTemplate.showWhenKeyword || !!keyword\">\n              <mat-option\n                class=\"static-option\"\n                [value]=\"{ staticOptionIndex: i }\"\n                [ngClass]=\"{ 'static-option-first': !i }\">\n                <ng-template\n                  [ngTemplateOutlet]=\"staticTemplate.templateRef\"\n                  [ngTemplateOutletContext]=\"{ $implicit: keyword }\"\n                ></ng-template>\n              </mat-option>\n            </ng-container>\n          </ng-container>\n        </div>\n      </ng-container>\n    </ng-container>\n  </mat-autocomplete>\n\n  <mat-hint *ngIf=\"hint\">{{ hint }}</mat-hint>\n  <mat-hint *ngIf=\"hintTemplate\">\n    <ng-container\n      [ngTemplateOutlet]=\"hintTemplate\">\n    </ng-container>\n  </mat-hint>\n</mat-form-field>\n", styles: ["::ng-deep .fs-autocomplete-panel .static-templates{position:sticky;bottom:0;width:100%;background:#fff;border-top:1px solid #e0e0e0}::ng-deep .fs-autocomplete-panel.mat-autocomplete-hidden{visibility:visible!important}.mat-form-field{width:100%}.clear{cursor:pointer}mat-label:after{content:attr(data-after-content)}:host ::ng-deep .mat-form-field-suffix{align-self:flex-end}\n"], components: [{ type: i1__namespace.MatFormField, selector: "mat-form-field", inputs: ["color", "floatLabel", "appearance", "hideRequiredMarker", "hintLabel"], exportAs: ["matFormField"] }, { type: i2__namespace.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { type: i3__namespace.MatAutocomplete, selector: "mat-autocomplete", inputs: ["disableRipple"], exportAs: ["matAutocomplete"] }, { type: i4__namespace.MatOption, selector: "mat-option", exportAs: ["matOption"] }], directives: [{ type: i1__namespace.MatLabel, selector: "mat-label" }, { type: i5__namespace.MatInput, selector: "input[matInput], textarea[matInput], select[matNativeControl],      input[matNativeControl], textarea[matNativeControl]", inputs: ["id", "disabled", "required", "type", "value", "readonly", "placeholder", "errorStateMatcher", "aria-describedby"], exportAs: ["matInput"] }, { type: i6__namespace.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { type: i3__namespace.MatAutocompleteTrigger, selector: "input[matAutocomplete], textarea[matAutocomplete]", exportAs: ["matAutocompleteTrigger"] }, { type: i6__namespace.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i6__namespace.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { type: i6__namespace.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }, { type: i7__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1__namespace.MatSuffix, selector: "[matSuffix]" }, { type: i7__namespace.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }, { type: i7__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i7__namespace.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i1__namespace.MatHint, selector: "mat-hint", inputs: ["align", "id"] }], changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
        i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsAutocompleteComponent, decorators: [{
                    type: i0.Component,
                    args: [{
                            selector: 'fs-autocomplete',
                            templateUrl: 'autocomplete.component.html',
                            styleUrls: ['autocomplete.component.scss'],
                            providers: [
                                {
                                    provide: i6.NG_VALUE_ACCESSOR,
                                    useExisting: i0.forwardRef(function () { return FsAutocompleteComponent; }),
                                    multi: true
                                }
                            ],
                            changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        }]
                }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }]; }, propDecorators: { autocomplete: [{
                        type: i0.ViewChild,
                        args: [i3.MatAutocompleteTrigger, { static: true }]
                    }], template: [{
                        type: i0.ContentChild,
                        args: [FsAutocompleteTemplateDirective, { read: i0.TemplateRef, static: true }]
                    }], staticTemplates: [{
                        type: i0.ContentChildren,
                        args: [FsAutocompleteStaticDirective]
                    }], staticDirectives: [{
                        type: i0.ContentChildren,
                        args: [FsAutocompleteStaticDirective]
                    }], noResultsTemplate: [{
                        type: i0.ContentChild,
                        args: [FsAutocompleteNoResultsDirective, { read: i0.TemplateRef, static: true }]
                    }], suffix: [{
                        type: i0.ContentChild,
                        args: [FsAutocompleteSuffixDirective, { read: i0.TemplateRef, static: true }]
                    }], hintTemplate: [{
                        type: i0.ContentChild,
                        args: [FsAutocompleteHintDirective, { read: i0.TemplateRef, static: true }]
                    }], formWrapper: [{
                        type: i0.HostBinding,
                        args: ['class.fs-form-wrapper']
                    }], keywordInput: [{
                        type: i0.ViewChild,
                        args: ['keywordInput', { static: true }]
                    }], keywordNgModel: [{
                        type: i0.ViewChild,
                        args: ['keywordNgModel', { static: true }]
                    }], fetch: [{
                        type: i0.Input
                    }], placeholder: [{
                        type: i0.Input
                    }], displayWith: [{
                        type: i0.Input
                    }], fetchOnFocus: [{
                        type: i0.Input
                    }], readonly: [{
                        type: i0.Input
                    }], required: [{
                        type: i0.Input
                    }], disabled: [{
                        type: i0.Input
                    }], hint: [{
                        type: i0.Input
                    }], panelWidth: [{
                        type: i0.Input
                    }], setPanelClass: [{
                        type: i0.Input,
                        args: ['panelClass']
                    }], showClear: [{
                        type: i0.Input
                    }], cleared: [{
                        type: i0.Output
                    }] } });

        var FsAutocompleteModule = /** @class */ (function () {
            function FsAutocompleteModule() {
            }
            return FsAutocompleteModule;
        }());
        FsAutocompleteModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsAutocompleteModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
        FsAutocompleteModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsAutocompleteModule, declarations: [FsAutocompleteComponent,
                FsAutocompleteTemplateDirective,
                FsAutocompleteSuffixDirective,
                FsAutocompleteStaticDirective,
                FsAutocompleteNoResultsDirective,
                FsAutocompleteHintDirective], imports: [i7.CommonModule,
                i6.FormsModule,
                i3.MatAutocompleteModule,
                chips.MatChipsModule,
                i5.MatInputModule,
                i2.MatIconModule], exports: [FsAutocompleteComponent,
                FsAutocompleteTemplateDirective,
                FsAutocompleteSuffixDirective,
                FsAutocompleteStaticDirective,
                FsAutocompleteNoResultsDirective,
                FsAutocompleteHintDirective] });
        FsAutocompleteModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsAutocompleteModule, providers: [], imports: [[
                    i7.CommonModule,
                    i6.FormsModule,
                    i3.MatAutocompleteModule,
                    chips.MatChipsModule,
                    i5.MatInputModule,
                    i2.MatIconModule,
                ]] });
        i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsAutocompleteModule, decorators: [{
                    type: i0.NgModule,
                    args: [{
                            imports: [
                                i7.CommonModule,
                                i6.FormsModule,
                                i3.MatAutocompleteModule,
                                chips.MatChipsModule,
                                i5.MatInputModule,
                                i2.MatIconModule,
                            ],
                            exports: [
                                FsAutocompleteComponent,
                                FsAutocompleteTemplateDirective,
                                FsAutocompleteSuffixDirective,
                                FsAutocompleteStaticDirective,
                                FsAutocompleteNoResultsDirective,
                                FsAutocompleteHintDirective,
                            ],
                            declarations: [
                                FsAutocompleteComponent,
                                FsAutocompleteTemplateDirective,
                                FsAutocompleteSuffixDirective,
                                FsAutocompleteStaticDirective,
                                FsAutocompleteNoResultsDirective,
                                FsAutocompleteHintDirective,
                            ],
                            providers: [],
                        }]
                }] });

        /*
         * Public API Surface of ngx-autocomplete
         */

        /**
         * Generated bundle index. Do not edit.
         */

        exports.FsAutocompleteComponent = FsAutocompleteComponent;
        exports.FsAutocompleteHintDirective = FsAutocompleteHintDirective;
        exports.FsAutocompleteModule = FsAutocompleteModule;
        exports.FsAutocompleteNoResultsDirective = FsAutocompleteNoResultsDirective;
        exports.FsAutocompleteStaticDirective = FsAutocompleteStaticDirective;
        exports.FsAutocompleteSuffixDirective = FsAutocompleteSuffixDirective;
        exports.FsAutocompleteTemplateDirective = FsAutocompleteTemplateDirective;

        Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=firestitch-autocomplete.umd.js.map
